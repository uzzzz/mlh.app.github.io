<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>两万字深入解密 Go 语言接口的那些事儿   技术头条 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="两万字深入解密 Go 语言接口的那些事儿   技术头条" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Go 语言的接口的原理是什么？是如何使用？它和C++接口有什么异同呢？本文作者用两万多字深入一一为你讲述Go语言interface的那些事儿。 作者 |&nbsp;饶全成 责编 | 伍杏玲 这篇文章的架构比较简单，直接抛出 10 个问题，一一解答。 Go 语言与鸭子类型的关系 先直接来看维基百科里的定义： If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. 翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。 Duck Typing，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。 例如，在动态语言 Python 中，定义一个这样的函数： def&nbsp;hello_world(coder):&nbsp;coder.say_hello() 当调用此函数的时候，可以传入任意类型，只要它实现了 say_hello() 函数就可以。如果没有实现，运行过程中会出现错误。 而在静态语言如 Java、C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 hello_world 函数，却传入了一个根本就没有实现 say_hello() 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。 动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。插一句，这也是我不喜欢用 Python 的一个原因。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写Python 的同学比较清楚。 Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。 来看个例子： 先定义一个接口，和使用此接口作为参数的函数： type&nbsp;IGreeting&nbsp;interface&nbsp;{&nbsp;sayHello()}func&nbsp;sayHello(i&nbsp;IGreeting)&nbsp;{&nbsp;i.sayHello()} ‍再来定义两个结构体： type&nbsp;Go&nbsp;struct&nbsp;{}func&nbsp;(g&nbsp;Go)&nbsp;sayHello()&nbsp;{&nbsp; fmt.Println(&quot;Hi,&nbsp;I&nbsp;am&nbsp;GO!&quot;)}type&nbsp;PHP&nbsp;struct&nbsp;{}func&nbsp;(p&nbsp;PHP)&nbsp;sayHello()&nbsp;{&nbsp; fmt.Println(&quot;Hi,&nbsp;I&nbsp;am&nbsp;PHP!&quot;)} 最后，在 main 函数里调用 sayHello() 函数： func&nbsp;main()&nbsp;{&nbsp; golang&nbsp;:=&nbsp;Go{}&nbsp; php&nbsp;:=&nbsp;PHP{}&nbsp; sayHello(golang)&nbsp; sayHello(php)} 程序输出： Hi,&nbsp;I&nbsp;am&nbsp;GO!Hi,&nbsp;I&nbsp;am&nbsp;PHP! 在 main 函数中，调用调用 sayHello() 函数时，传入了 golang、 php 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 golang、php 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。 顺带再提一下动态语言的特点： 变量绑定的类型是不确定的，在运行期间才能确定 函数和方法可以接收任何类型的参数，且调用时不检查参数类型 不需要实现接口 总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它&quot;当前方法和属性的集合&quot;决定。Go 作为一种静态语言，通过接口实现了 鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。 值接收者和指针接收者的区别 方法 方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。 在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。 也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。 来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Person&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Person)&nbsp;howOld()&nbsp;int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;p.age}func&nbsp;(p&nbsp;*Person)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;qcrao&nbsp;是值类型&nbsp;&nbsp;&nbsp;&nbsp;qcrao&nbsp;:=&nbsp;Person{age:&nbsp;18}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;值类型&nbsp;调用接收者也是值类型的方法&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;值类型&nbsp;调用接收者是指针类型的方法&nbsp;&nbsp;&nbsp;&nbsp;qcrao.growUp()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;----------------------&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;stefno&nbsp;是指针类型&nbsp;&nbsp;&nbsp;&nbsp;stefno&nbsp;:=&nbsp;&amp;Person{age:&nbsp;100}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指针类型&nbsp;调用接收者是值类型的方法&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指针类型&nbsp;调用接收者也是指针类型的方法&nbsp;&nbsp;&nbsp;&nbsp;stefno.growUp()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno.howOld())} 上例子的输出结果是： 1819100101 调用了 growUp 函数后，不管调用者是值类型还是指针类型，它的 Age 值都改变了。 实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现： - 值接收者 指针接收者 值类型调用者 方法会使用调用者的一个副本，类似于“传值” 使用值的引用来调用方法，上例中，qcrao.growUp()&nbsp;实际上是&nbsp;(&amp;qcrao).growUp() 指针类型调用者 指针被解引用为值，上例中，stefno.howOld()&nbsp;实际上是&nbsp;(*stefno).howOld() 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 值接收者和指针接收者 前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。 先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。 来看一个例子，就会完全明白： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;debug()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(p&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;coding&nbsp;%s&nbsp;language\n&quot;,&nbsp;p.language)}func&nbsp;(p&nbsp;*Gopher)&nbsp;debug()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;debuging&nbsp;%s&nbsp;language\n&quot;,&nbsp;p.language)}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;&amp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;c.code()&nbsp;&nbsp;&nbsp;&nbsp;c.debug()} 上述代码里定义了一个接口 coder，接口定义了两个函数：code()、debug()。 接着定义了一个结构体 Gopher，它实现了两个方法，一个值接收者，一个指针接收者。 最后，我们在 main 函数里通过接口类型的变量调用了定义的两个函数。 运行一下，结果： I&nbsp;am&nbsp;coding&nbsp;Go&nbsp;languageI&nbsp;am&nbsp;debuging&nbsp;Go&nbsp;language 但是如果我们把 main 函数的第一条语句换一下： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;c.code()&nbsp;&nbsp;&nbsp;&nbsp;c.debug()} 运行一下，报错： ./main.go:24:6:&nbsp;cannot&nbsp;use&nbsp;Programmer&nbsp;literal&nbsp;(type&nbsp;Programmer)&nbsp;as&nbsp;type&nbsp;coder&nbsp;in&nbsp;assignment:&nbsp;Programmer&nbsp;does&nbsp;not&nbsp;implement&nbsp;coder&nbsp;(debug&nbsp;method&nbsp;has&nbsp;pointer&nbsp;receiver) 看出这两处代码的差别了吗？第一次是将 &amp;Gopher 赋给了 coder；第二次则是将 Gopher 赋给了 coder。 第二次报错是说，Gopher 没有实现 coder。很明显了吧，因为 Gopher 类型并没有实现 debug 方法；表面上看， *Gopher 类型也没有实现 code 方法，但是因为 Gopher 类型实现了 code 方法，所以让 *Gopher 类型自动拥有了 code 方法。 当然，上面的说法有一个简单的解释：接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。 所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。 最后，只要记住下面这点就可以了： 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。 两者分别在何时使用 如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。 使用指针作为方法的接收者的理由： •方法能够修改接收者指向的值。 •避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。 是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。 如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。 如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。 这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。 iface 和 eface 的区别是什么 iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。 从源码层面看一下： type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;unsafe.Pointer}type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;&nbsp;*interfacetype&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;uint32&nbsp;//&nbsp;copy&nbsp;of&nbsp;_type.hash.&nbsp;Used&nbsp;for&nbsp;type&nbsp;switches.&nbsp;&nbsp;&nbsp;&nbsp;bad&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;type&nbsp;does&nbsp;not&nbsp;implement&nbsp;interface&nbsp;&nbsp;&nbsp;&nbsp;inhash&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;has&nbsp;this&nbsp;itab&nbsp;been&nbsp;added&nbsp;to&nbsp;hash?&nbsp;&nbsp;&nbsp;&nbsp;unused&nbsp;[2]byte&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;&nbsp;[1]uintptr&nbsp;//&nbsp;variable&nbsp;sized} iface 内部维护两个指针，tab 指向一个 itab 实体， 它表示接口的类型以及赋给这个接口的实体类型。data 则指向接口具体的值，一般而言是一个指向堆内存的指针。 再来仔细看一下 itab 结构体：_type 字段描述了实体的类型，包括内存对齐方式，大小等；inter 字段则描述了接口的类型。fun 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。 这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。 另外，你可能会觉得奇怪，为什么 fun 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。 再看一下 interfacetype 类型，它描述的是接口的类型： type&nbsp;interfacetype&nbsp;struct&nbsp;{&nbsp;typ&nbsp;_type&nbsp;pkgpath&nbsp;name&nbsp;mhdr&nbsp;[]imethod} 可以看到，它包装了 _type 类型，_type 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 mhdr 字段，表示接口所定义的函数列表， pkgpath 记录定义了接口的包名。 这里通过一张图来看下 iface 结构体的全貌： 接着来看一下 eface 的源码： type&nbsp;eface&nbsp;struct&nbsp;{&nbsp; _type&nbsp;*_type&nbsp; data&nbsp;unsafe.Pointer} 相比 iface，eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值。 我们来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;200&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;any&nbsp;interface{}&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(any)&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;:=&nbsp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c)}type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;debug()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(p&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;coding&nbsp;%s&nbsp;language\n&quot;,&nbsp;p.language)}func&nbsp;(p&nbsp;Gopher)&nbsp;debug()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;debuging&nbsp;%s&nbsp;language\n&quot;,&nbsp;p.language)} 执行命令，打印出汇编语言： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go 可以看到，main 函数里调用了两个函数： func&nbsp;convT2E64(t&nbsp;*_type,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(e&nbsp;eface)func&nbsp;convT2I(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface) 上面两个函数的参数和 iface 及 eface 结构体的字段是可以联系起来的：两个函数都是将参数组装一下，形成最终的接口。 作为补充，我们最后再来看下 _type 结构体： type&nbsp;_type&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型大小&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;ptrdata&nbsp;&nbsp;&nbsp;&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的&nbsp;flag，和反射相关&nbsp;&nbsp;&nbsp;&nbsp;tflag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tflag&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;内存对齐相关&nbsp;&nbsp;&nbsp;&nbsp;align&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;fieldalign&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的编号，有bool,&nbsp;slice,&nbsp;struct&nbsp;等等等等&nbsp;&nbsp;&nbsp;&nbsp;kind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;alg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*typeAlg&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;gc&nbsp;相关&nbsp;&nbsp;&nbsp;&nbsp;gcdata&nbsp;&nbsp;&nbsp;&nbsp;*byte&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nameOff&nbsp;&nbsp;&nbsp;&nbsp;ptrToThis&nbsp;typeOff} Go 语言各种数据类型都是在 _type 字段的基础上，增加一些额外的字段来进行管理的： type&nbsp;arraytype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;slice&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;&nbsp;&nbsp;uintptr}type&nbsp;chantype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;dir&nbsp;&nbsp;uintptr}type&nbsp;slicetype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;*_type}type&nbsp;structtype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;fields&nbsp;&nbsp;[]structfield} 这些数据类型的结构体定义，是反射实现的基础。 接口的动态类型和动态值 从源码里可以看到：iface包含两个字段：tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值。 【引申1】接口类型和&nbsp;nil&nbsp;作比较 接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。 来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;string}func&nbsp;(g&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%s&nbsp;is&nbsp;coding\n&quot;,&nbsp;g.name)}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;Coder&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;c:&nbsp;%T,&nbsp;%v\n&quot;,&nbsp;c,&nbsp;c)&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;g&nbsp;*Gopher&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(g&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;c:&nbsp;%T,&nbsp;%v\n&quot;,&nbsp;c,&nbsp;c)} 输出： truec:&nbsp;&lt;nil&gt;,&nbsp;&lt;nil&gt;truefalsec:&nbsp;*main.Gopher,&nbsp;&lt;nil&gt; 一开始，c 的 动态类型和动态值都为 nil，g 也为 nil，当把 g 赋值给 c 后，c 的动态类型变成了 *main.Gopher，仅管 c 的动态值仍为 nil，但是当 c 和 nil 作比较的时候，结果就是 false 了。 【引申2】 来看一个例子，看一下它的输出： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;MyError&nbsp;struct&nbsp;{}func&nbsp;(i&nbsp;MyError)&nbsp;Error()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;MyError&quot;}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;:=&nbsp;Process()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err&nbsp;==&nbsp;nil)}func&nbsp;Process()&nbsp;error&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;err&nbsp;*MyError&nbsp;=&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;err} 函数运行结果： &lt;nil&gt;false 这里先定义了一个 MyError 结构体，实现了 Error 函数，也就实现了 error 接口。Process 函数返回了一个 error 接口，这块隐含了类型转换。所以，虽然它的值是 nil，其实它的类型是 *MyError，最后和 nil 比较的时候，结果为 false。 【引申3】如何打印出接口的动态类型和值？ 直接看代码： package&nbsp;mainimport&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&quot;unsafe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&quot;fmt&quot;)type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;itab,&nbsp;data&nbsp;uintptr}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;a&nbsp;interface{}&nbsp;=&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;b&nbsp;interface{}&nbsp;=&nbsp;(*int)(nil)&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;interface{}&nbsp;=&nbsp;(*int)(&amp;x)&nbsp;&nbsp;&nbsp;&nbsp;ia&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;a))&nbsp;&nbsp;&nbsp;&nbsp;ib&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;b))&nbsp;&nbsp;&nbsp;&nbsp;ic&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;c))&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ia,&nbsp;ib,&nbsp;ic)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(*(*int)(unsafe.Pointer(ic.data)))} 代码里直接定义了一个 iface 结构体，用两个指针来描述 itab 和 data，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 iface。最后就可以打印出动态类型和动态值的地址。 运行结果如下： {0&nbsp;0}&nbsp;{17426912&nbsp;0}&nbsp;{17426912&nbsp;842350714568}5 a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 *int；最后，c 的动态值为 5。 编译器自动检测类型是否实现接口 经常看到一些开源库里会有一些类似下面这种奇怪的用法： var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil) 这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口。 来看一个例子： package&nbsp;mainimport&nbsp;&quot;io&quot;type&nbsp;myWriter&nbsp;struct&nbsp;{}/*func&nbsp;(w&nbsp;myWriter)&nbsp;Write(p&nbsp;[]byte)&nbsp;(n&nbsp;int,&nbsp;err&nbsp;error)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}*/func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查&nbsp;*myWriter&nbsp;类型是否实现了&nbsp;io.Writer&nbsp;接口&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查&nbsp;myWriter&nbsp;类型是否实现了&nbsp;io.Writer&nbsp;接口&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;myWriter{}} 注释掉为 myWriter 定义的 Write 函数后，运行程序： src/main.go:14:6:&nbsp;cannot&nbsp;use&nbsp;(*myWriter)(nil)&nbsp;(type&nbsp;*myWriter)&nbsp;as&nbsp;type&nbsp;io.Writer&nbsp;in&nbsp;assignment:&nbsp;&nbsp;&nbsp;&nbsp;*myWriter&nbsp;does&nbsp;not&nbsp;implement&nbsp;io.Writer&nbsp;(missing&nbsp;Write&nbsp;method)src/main.go:15:6:&nbsp;cannot&nbsp;use&nbsp;myWriter&nbsp;literal&nbsp;(type&nbsp;myWriter)&nbsp;as&nbsp;type&nbsp;io.Writer&nbsp;in&nbsp;assignment:&nbsp;&nbsp;&nbsp;&nbsp;myWriter&nbsp;does&nbsp;not&nbsp;implement&nbsp;io.Writer&nbsp;(missing&nbsp;Write&nbsp;method) 报错信息：*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。 解除注释后，运行程序不报错。 实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。 总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口： var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil)var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;myWriter{} 接口的构造过程是怎样的 我们已经看过了 iface 和 eface 的源码，知道 iface 最重要的是 itab 和 _type。 为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。 来看一个示例代码： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Person&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;growUp()}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Student)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;qcrao&nbsp;=&nbsp;Person(Student{age:&nbsp;18})&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao)} 执行命令： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go 得到 main 函数的汇编代码如下： 0x0000&nbsp;00000&nbsp;(./src/main.go:30)&nbsp;TEXT&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;.main(SB),&nbsp;$80-00x0000&nbsp;00000&nbsp;(./src/main.go:30)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;(TLS),&nbsp;CX0x0009&nbsp;00009&nbsp;(./src/main.go:30)&nbsp;CMPQ&nbsp;&nbsp;&nbsp;&nbsp;SP,&nbsp;16(CX)0x000d&nbsp;00013&nbsp;(./src/main.go:30)&nbsp;JLS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1570x0013&nbsp;00019&nbsp;(./src/main.go:30)&nbsp;SUBQ&nbsp;&nbsp;&nbsp;&nbsp;$80,&nbsp;SP0x0017&nbsp;00023&nbsp;(./src/main.go:30)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;BP,&nbsp;72(SP)0x001c&nbsp;00028&nbsp;(./src/main.go:30)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;72(SP),&nbsp;BP0x0021&nbsp;00033&nbsp;(./src/main.go:30)&nbsp;FUNCDATA$0,&nbsp;gclocals·69c1753bd5f81501d95132d08af04464(SB)0x0021&nbsp;00033&nbsp;(./src/main.go:30)&nbsp;FUNCDATA$1,&nbsp;gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)0x0021&nbsp;00033&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$18,&nbsp;&quot;&quot;..autotmp_1+48(SP)0x002a&nbsp;00042&nbsp;(./src/main.go:31)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB),&nbsp;AX0x0031&nbsp;00049&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;(SP)0x0035&nbsp;00053&nbsp;(./src/main.go:31)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;..autotmp_1+48(SP),&nbsp;AX0x003a&nbsp;00058&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;8(SP)0x003f&nbsp;00063&nbsp;(./src/main.go:31)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$00x003f&nbsp;00063&nbsp;(./src/main.go:31)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;runtime.convT2I64(SB)0x0044&nbsp;00068&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;24(SP),&nbsp;AX0x0049&nbsp;00073&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;16(SP),&nbsp;CX0x004e&nbsp;00078&nbsp;(./src/main.go:33)&nbsp;TESTQ&nbsp;&nbsp;&nbsp;CX,&nbsp;CX0x0051&nbsp;00081&nbsp;(./src/main.go:33)&nbsp;JEQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;870x0053&nbsp;00083&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;8(CX),&nbsp;CX0x0057&nbsp;00087&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$0,&nbsp;&quot;&quot;..autotmp_2+56(SP)0x0060&nbsp;00096&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$0,&nbsp;&quot;&quot;..autotmp_2+64(SP)0x0069&nbsp;00105&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;CX,&nbsp;&quot;&quot;..autotmp_2+56(SP)0x006e&nbsp;00110&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;&quot;&quot;..autotmp_2+64(SP)0x0073&nbsp;00115&nbsp;(./src/main.go:33)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;..autotmp_2+56(SP),&nbsp;AX0x0078&nbsp;00120&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;(SP)0x007c&nbsp;00124&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$1,&nbsp;8(SP)0x0085&nbsp;00133&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$1,&nbsp;16(SP)0x008e&nbsp;00142&nbsp;(./src/main.go:33)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$10x008e&nbsp;00142&nbsp;(./src/main.go:33)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(SB)0x0093&nbsp;00147&nbsp;(./src/main.go:34)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;72(SP),&nbsp;BP0x0098&nbsp;00152&nbsp;(./src/main.go:34)&nbsp;ADDQ&nbsp;&nbsp;&nbsp;&nbsp;$80,&nbsp;SP0x009c&nbsp;00156&nbsp;(./src/main.go:34)&nbsp;RET0x009d&nbsp;00157&nbsp;(./src/main.go:34)&nbsp;NOP0x009d&nbsp;00157&nbsp;(./src/main.go:30)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$-10x009d&nbsp;00157&nbsp;(./src/main.go:30)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;runtime.morestack_noctxt(SB)0x00a2&nbsp;00162&nbsp;(./src/main.go:30)&nbsp;JMP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。 汇编行数 操作 10-14 构造调用&nbsp;runtime.convT2I64(SB)&nbsp;的参数 我们来看下这个函数的参数形式： func&nbsp;convT2I64(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface)&nbsp;{&nbsp;//&nbsp;……} convT2I64 会构造出一个 inteface，也就是我们的 Person 接口。 第一个参数的位置是 (SP)，这里被赋上了 go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB) 的地址。 我们从生成的汇编找到： go.itab.&quot;&quot;.Student,&quot;&quot;.Person&nbsp;SNOPTRDATA&nbsp;dupok&nbsp;size=40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0010&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;da&nbsp;9f&nbsp;20&nbsp;d4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel&nbsp;0+8&nbsp;t=1&nbsp;type.&quot;&quot;.Person+0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel&nbsp;8+8&nbsp;t=1&nbsp;type.&quot;&quot;.Student+0 size=40 大小为40字节，回顾一下： type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;&nbsp;*interfacetype&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;*_type&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;&nbsp;&nbsp;*itab&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;uint32&nbsp;//&nbsp;4字节&nbsp;&nbsp;&nbsp;&nbsp;bad&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;1字节&nbsp;&nbsp;&nbsp;&nbsp;inhash&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;1字节&nbsp;&nbsp;&nbsp;&nbsp;unused&nbsp;[2]byte&nbsp;//&nbsp;2字节&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;&nbsp;[1]uintptr&nbsp;//&nbsp;variable&nbsp;sized&nbsp;//&nbsp;8字节} 把每个字段的大小相加，itab 结构体的大小就是 40 字节。上面那一串数字实际上是 itab 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 da 9f 20 d4 实际上是 itab 的 hash 值，这在判断两个类型是否相同的时候会用到。 下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 type.&quot;&quot;.Person 的地址，对应 itab 里的 inter 字段，表示接口类型；8-16 字节最终存储的是 type.&quot;&quot;.Student 的地址，对应 itab 里 _type 字段，表示具体类型。 第二个参数就比较简单了，它就是数字 18 的地址，这也是初始化 Student 结构体的时候会用到。 汇编行数 操作 15 调用&nbsp;runtime.convT2I64(SB) 具体看下代码： func&nbsp;convT2I64(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;tab._type&nbsp;&nbsp;&nbsp;&nbsp;//...&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;x&nbsp;unsafe.Pointer&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;*(*uint64)(elem)&nbsp;==&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;unsafe.Pointer(&amp;zeroVal[0])&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;mallocgc(8,&nbsp;t,&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(*uint64)(x)&nbsp;=&nbsp;*(*uint64)(elem)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;i.tab&nbsp;=&nbsp;tab&nbsp;&nbsp;&nbsp;&nbsp;i.data&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;return} ‍这块代码比较简单，把 tab 赋给了 iface 的 tab 字段；data 部分则是在堆上申请了一块内存，然后将 elem 指向的 18 拷贝过去。这样 iface 就组装好了。 汇编行数 操作 17 把&nbsp;i.tab&nbsp;赋给&nbsp;CX 18 把&nbsp;i.data&nbsp;赋给&nbsp;AX 19-21 检测&nbsp;i.tab&nbsp;是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把&nbsp;itab&nbsp;的&nbsp;_type&nbsp;字段赋给了 CX，这也是接口的实体类型，最终要作为&nbsp;fmt.Println&nbsp;函数的参数 后面，就是调用 fmt.Println 函数及之前的参数准备工作了，不再赘述。 这样，我们就把一个 interface 的构造过程说完了。 【引申1】 如何打印出接口类型的 Hash 值？ 这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下： type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;unsafe.Pointer}type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;uint32&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4]byte&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;[1]uintptr}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;qcrao&nbsp;=&nbsp;Person(Student{age:&nbsp;18})&nbsp;&nbsp;&nbsp;&nbsp;iface&nbsp;:=&nbsp;(*iface)(unsafe.Pointer(&amp;qcrao))&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;iface.tab.hash&nbsp;=&nbsp;%#x\n&quot;,&nbsp;iface.tab.hash)} ‍了一个山寨版的 iface 和 itab，说它山寨是因为 itab 里的一些关键数据结构都不具体展开了，比如 _type，对比一下正宗的定义就可以发现，但是山寨版依然能工作，因为 _type 就是一个指针而已嘛。 在 main 函数里，先构造出一个接口对象 qcrao，然后强制类型转换，最后读取出 hash 值，非常妙！你也可以自己动手试一下。 运行结果： iface.tab.hash&nbsp;=&nbsp;0xd4209fda 值得一提的是，构造接口 qcrao 的时候，即使我把 age 写成其他值，得到的 hash 值依然不变的，这应该是可以预料的，hash 值只和他的字段、方法相关。 类型转换和断言的区别 我们知道，Go 语言中不允许隐式类型转换，也就是说 = 两边，不允许出现类型不相同的变量。 类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。 类型转换 对于类型转换而言，转换前后的两个类型要相互兼容才行。类型转换的语法为： &lt;结果类型&gt; := &lt;目标类型&gt; (&lt;表达式&gt;) package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;int&nbsp;=&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;f&nbsp;float64&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;float64(i)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%T,&nbsp;%v\n&quot;,&nbsp;f,&nbsp;f)&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;10.8&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;:=&nbsp;int(f)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%T,&nbsp;%v\n&quot;,&nbsp;a,&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;s&nbsp;:=&nbsp;[]int(i) 上面的代码里，我定义了一个 int 型和 float64 型的变量，尝试在它们之前相互转换，结果是成功的：int 型和 float64 是相互兼容的。 如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误： cannot&nbsp;convert&nbsp;i&nbsp;(type&nbsp;int)&nbsp;to&nbsp;type&nbsp;[]int ‍断言 前面说过，因为空接口 interface{} 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。 断言的语法为： &nbsp;// 安全类型断言 &lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 )&nbsp;&nbsp; //非安全类型断言 &lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 ) 类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。 还是来看一个简短的例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;i.(Student)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)} ‍运行一下： panic:&nbsp;interface&nbsp;conversion:&nbsp;interface&nbsp;{}&nbsp;is&nbsp;*main.Student,&nbsp;not&nbsp;main.Student ‍直接 panic 了，这是因为 i 是 *Student 类型，并非 Student 类型，断言失败。这里直接发生了 panic，线上代码可能并不适合这样做，可以采用“安全断言”的语法： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;ok&nbsp;:=&nbsp;i.(Student)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ok&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)&nbsp;&nbsp;&nbsp;&nbsp;}} 这样，即使断言失败也不会 panic。 断言其实还有另一种形式，就是用在利用 switch 语句判断接口的类型。每一个 case 会被顺序地考虑。当命中一个 case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case 匹配的情况。 代码示例如下： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;//var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil)&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;i,&nbsp;i)&nbsp;&nbsp;&nbsp;&nbsp;judge(i)}func&nbsp;judge(v&nbsp;interface{})&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;v&nbsp;:=&nbsp;v.(type)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;nil:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;nil&nbsp;type[%T]&nbsp;%v\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Student:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;Student&nbsp;type[%T]&nbsp;%v\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;*Student:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;*Student&nbsp;type[%T]&nbsp;%v\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;unknow\n&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int} main 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果： //&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)0xc4200701b0&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]0xc4200701d0&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]0xc420080020&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]*Student&nbsp;type[*main.Student]&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil)0xc42000e1d0&nbsp;&lt;nil&gt;0xc42000e1f0&nbsp;&lt;nil&gt;0xc42000c030&nbsp;&lt;nil&gt;*Student&nbsp;type[*main.Student]&nbsp;&lt;nil&gt;//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}0xc42000e1d0&nbsp;&lt;nil&gt;0xc42000e1e0&nbsp;&lt;nil&gt;0xc42000e1f0&nbsp;&lt;nil&gt;nil&nbsp;type[&lt;nil&gt;]&nbsp;&lt;nil&gt; 对于第一行语句： var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student) ‍i 是一个 *Student 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 main 函数里有一个局部变量 i；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 v，它是 i 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。 对于第二行语句： var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil) ‍这里想说明的其实是 i 在这里动态类型是 (*Student), 数据为 nil，它的类型并不是 nil，它与 nil 作比较的时候，得到的结果也是 false。 最后一行语句： var&nbsp;i&nbsp;interface{} 这回 i 才是 nil 类型。 【引申1】 fmt.Println 函数的参数是 interface。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 String() 方法，如果实现了，则直接打印输出 String() 方法的结果；否则，会通过反射来遍历对象的成员进行打印。 再来看一个简短的例子，比较简单，不要紧张： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;s&nbsp;=&nbsp;Student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name:&nbsp;&quot;qcrao&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age:&nbsp;18,&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)} ‍因为 Student 结构体没有实现 String() 方法，所以 fmt.Println 会利用反射挨个打印成员变量： {qcrao&nbsp;18} ‍增加一个 String() 方法的实现： func&nbsp;(s&nbsp;Student)&nbsp;String()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fmt.Sprintf(&quot;[Name:&nbsp;%s],&nbsp;[Age:&nbsp;%d]&quot;,&nbsp;s.Name,&nbsp;s.Age)} 打印结果： [Name:&nbsp;qcrao],&nbsp;[Age:&nbsp;18] ‍按照我们自定义的方法来打印了。 【引申2】 针对上面的例子，如果改一下： func&nbsp;(s&nbsp;*Student)&nbsp;String()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fmt.Sprintf(&quot;[Name:&nbsp;%s],&nbsp;[Age:&nbsp;%d]&quot;,&nbsp;s.Name,&nbsp;s.Age)} 注意看两个函数的接受者类型不同，现在 Student 结构体只有一个接受者类型为 指针类型 的 String() 函数，打印结果： {qcrao&nbsp;18} ‍为什么？ 类型 T 只有接受者是 T 的方法；而类型 *T 拥有接受者是 T 和 *T 的方法。语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖。 所以，&nbsp;Student&nbsp;结构体定义了接受者类型是值类型的&nbsp;String()&nbsp;方法时，通过 fmt.Println(s)fmt.Println(&amp;s) 均可以按照自定义的格式来打印。 如果&nbsp;Student&nbsp;结构体定义了接受者类型是指针类型的&nbsp;String()&nbsp;方法时，只有通过 fmt.Println(&amp;s) 才能按照自定义的格式打印。 接口转换的原理 通过前面提到的 iface 的源码可以看到，实际上它包含接口的类型 interfacetype 和 实体类型的类型 _type，这两者都是 iface 的字段 itab 的成员。也就是说生成一个 itab 同时需要接口的类型和实体的类型。 &lt;interface 类型， 实体类型&gt; -&gt;itable 当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。 例如某类型有 m 个方法，某接口有 n 个方法，则很容易知道这种判定的时间复杂度为 O(mn)，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 O(m+n)。 这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。 直接来看一个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;run()}type&nbsp;runner&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;run()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(g&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(g&nbsp;Gopher)&nbsp;run()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;Gopher{}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;r&nbsp;runner&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c,&nbsp;r)} 简单解释下上述代码：定义了两个 interface: coder 和 runner。定义了一个实体类型 Gopher，类型 Gopher 实现了两个方法，分别是 run() 和 code()。main 函数里定义了一个接口变量 c，绑定了一个 Gopher 对象，之后将 c 赋值给另外一个接口变量 r 。赋值成功的原因是 c 中包含 run() 方法。这样，两个接口变量完成了转换。 执行命令： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go ‍得到 main 函数的汇编命令，可以看到：r = c 这一行语句实际上是调用了 runtime.convI2I(SB)，也就是 convI2I 函数，从函数名来看，就是将一个 interface 转换成另外一个 interface，看下它的源代码： func&nbsp;convI2I(inter&nbsp;*interfacetype,&nbsp;i&nbsp;iface)&nbsp;(r&nbsp;iface)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;:=&nbsp;i.tab&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tab&nbsp;==&nbsp;nil&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tab.inter&nbsp;==&nbsp;inter&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.tab&nbsp;=&nbsp;tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.data&nbsp;=&nbsp;i.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;r.tab&nbsp;=&nbsp;getitab(inter,&nbsp;tab._type,&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;r.data&nbsp;=&nbsp;i.data&nbsp;&nbsp;&nbsp;&nbsp;return} 代码比较简单，函数参数 inter 表示接口类型，i 表示绑定了实体类型的接口，r 则表示接口转换了之后的新的 iface。通过前面的分析，我们又知道， iface 是由 tab 和 data 两个字段组成。所以，实际上 convI2I 函数真正要做的事，找到新 interface 的 tab 和 data，就大功告成了。 我们还知道，tab 是由接口类型 interfacetype 和 实体类型 _type。所以最关键的语句是 r.tab = getitab(inter, tab._type, false)。 因此，重点来看下 getitab 函数的源码，只看关键的地方： func&nbsp;getitab(inter&nbsp;*interfacetype,&nbsp;typ&nbsp;*_type,&nbsp;canfail&nbsp;bool)&nbsp;*itab&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;根据&nbsp;inter,&nbsp;typ&nbsp;计算出&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;itabhash(inter,&nbsp;typ)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;look&nbsp;twice&nbsp;-&nbsp;once&nbsp;without&nbsp;lock,&nbsp;once&nbsp;with.&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;common&nbsp;case&nbsp;will&nbsp;be&nbsp;no&nbsp;lock&nbsp;contention.&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;m&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;locked&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;locked&nbsp;=&nbsp;0;&nbsp;locked&nbsp;&lt;&nbsp;2;&nbsp;locked++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;locked&nbsp;!=&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;遍历哈希表的一个&nbsp;slot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;m&nbsp;=&nbsp;(*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h])));&nbsp;m&nbsp;!=&nbsp;nil;&nbsp;m&nbsp;=&nbsp;m.link&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果在&nbsp;hash&nbsp;表中已经找到了&nbsp;itab（inter&nbsp;和&nbsp;typ&nbsp;指针都相同）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m.inter&nbsp;==&nbsp;inter&nbsp;&amp;&amp;&nbsp;m._type&nbsp;==&nbsp;typ&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;locked&nbsp;!=&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在&nbsp;hash&nbsp;表中没有找到&nbsp;itab，那么新生成一个&nbsp;itab&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;(*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize,&nbsp;0,&nbsp;&amp;memstats.other_sys))&nbsp;&nbsp;&nbsp;&nbsp;m.inter&nbsp;=&nbsp;inter&nbsp;&nbsp;&nbsp;&nbsp;m._type&nbsp;=&nbsp;typ&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;添加到全局的&nbsp;hash&nbsp;表中&nbsp;&nbsp;&nbsp;&nbsp;additab(m,&nbsp;true,&nbsp;canfail)&nbsp;&nbsp;&nbsp;&nbsp;unlock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m.bad&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m} 简单总结一下：getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 interfacetype 和 _type 新生成一个 itab，并插入到 itab 哈希表，这样下一次就可以直接拿到 itab。 这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 itab 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 itab 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 itab。 再来看一下 additab 函数的代码： //&nbsp;检查&nbsp;_type&nbsp;是否符合&nbsp;interface_type&nbsp;并且创建对应的&nbsp;itab&nbsp;结构体&nbsp;将其放到&nbsp;hash&nbsp;表中func&nbsp;additab(m&nbsp;*itab,&nbsp;locked,&nbsp;canfail&nbsp;bool)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;:=&nbsp;m.inter&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;:=&nbsp;m._type&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;typ.uncommon()&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;both&nbsp;inter&nbsp;and&nbsp;typ&nbsp;have&nbsp;method&nbsp;sorted&nbsp;by&nbsp;name,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;and&nbsp;interface&nbsp;names&nbsp;are&nbsp;unique,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;so&nbsp;can&nbsp;iterate&nbsp;over&nbsp;both&nbsp;in&nbsp;lock&nbsp;step;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;loop&nbsp;is&nbsp;O(ni+nt)&nbsp;not&nbsp;O(ni*nt).&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;inter&nbsp;和&nbsp;typ&nbsp;的方法都按方法名称进行了排序&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;并且方法名都是唯一的。所以循环的次数是固定的&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;只用循环&nbsp;O(ni+nt)，而非&nbsp;O(ni*nt)&nbsp;&nbsp;&nbsp;&nbsp;ni&nbsp;:=&nbsp;len(inter.mhdr)&nbsp;&nbsp;&nbsp;&nbsp;nt&nbsp;:=&nbsp;int(x.mcount)&nbsp;&nbsp;&nbsp;&nbsp;xmhdr&nbsp;:=&nbsp;(*[1&nbsp;&lt;&lt;&nbsp;16]method)(add(unsafe.Pointer(x),&nbsp;uintptr(x.moff)))[:nt:nt]&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;:=&nbsp;0;&nbsp;k&nbsp;&lt;&nbsp;ni;&nbsp;k++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;&amp;inter.mhdr[k]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itype&nbsp;:=&nbsp;inter.typ.typeOff(i.ityp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;:=&nbsp;inter.typ.nameOff(i.name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iname&nbsp;:=&nbsp;name.name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipkg&nbsp;:=&nbsp;name.pkgPath()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ipkg&nbsp;==&nbsp;&quot;&quot;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipkg&nbsp;=&nbsp;inter.pkgpath.name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;;&nbsp;j&nbsp;&lt;&nbsp;nt;&nbsp;j++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;&amp;xmhdr[j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tname&nbsp;:=&nbsp;typ.nameOff(t.name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查方法名字是否一致&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;typ.typeOff(t.mtyp)&nbsp;==&nbsp;itype&nbsp;&amp;&amp;&nbsp;tname.name()&nbsp;==&nbsp;iname&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;:=&nbsp;tname.pkgPath()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pkgPath&nbsp;==&nbsp;&quot;&quot;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;=&nbsp;typ.nameOff(x.pkgpath).name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tname.isExported()&nbsp;||&nbsp;pkgPath&nbsp;==&nbsp;ipkg&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m&nbsp;!=&nbsp;nil&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取函数地址，并加入到itab.fun数组中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifn&nbsp;:=&nbsp;typ.textOff(t.ifn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]),&nbsp;uintptr(k)*sys.PtrSize))&nbsp;=&nbsp;ifn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;nextimethod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.bad&nbsp;=&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;nextimethod:&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!locked&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(&quot;invalid&nbsp;itab&nbsp;locking&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;计算&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;itabhash(inter,&nbsp;typ)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;加到Hash&nbsp;Slot链表中&nbsp;&nbsp;&nbsp;&nbsp;m.link&nbsp;=&nbsp;hash[h]&nbsp;&nbsp;&nbsp;&nbsp;m.inhash&nbsp;=&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;atomicstorep(unsafe.Pointer(&amp;hash[h]),&nbsp;unsafe.Pointer(m))} additab 会检查 itab 持有的 interfacetype 和 _type 是否符合，就是看 _type 是否完全实现了 interfacetype 的方法，也就是看两者的方法列表重叠的部分就是 interfacetype 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 ni * nt，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 ni + nt 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。 求 hash 值的函数比较简单： func&nbsp;itabhash(inter&nbsp;*interfacetype,&nbsp;typ&nbsp;*_type)&nbsp;uint32&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;inter.typ.hash&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;+=&nbsp;17&nbsp;*&nbsp;typ.hash&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;h&nbsp;%&nbsp;hashSize} hashSize 的值是 1009。 更一般的，当把实体类型赋值给接口的时候，会调用 conv 系列函数，例如空接口调用 convT2E 系列、非空接口调用 convT2I 系列。这些函数比较相似： 1.具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。 2.具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。 3.而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。 如何用 interface 实现多态 Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。 多态是一种运行期的行为，它有以下几个特点： 1.一种类型具有多种类型的能力 2.允许不同的对象对同一消息做出灵活的反应 3.以一种通用的方式对待个使用的对象 4.非动态语言必须通过继承和接口的方式来实现 看一个实现了多态的代码例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;qcrao&nbsp;:=&nbsp;Student{age:&nbsp;18}&nbsp;&nbsp;&nbsp;&nbsp;whatJob(&amp;qcrao)&nbsp;&nbsp;&nbsp;&nbsp;growUp(&amp;qcrao)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao)&nbsp;&nbsp;&nbsp;&nbsp;stefno&nbsp;:=&nbsp;Programmer{age:&nbsp;100}&nbsp;&nbsp;&nbsp;&nbsp;whatJob(stefno)&nbsp;&nbsp;&nbsp;&nbsp;growUp(stefno)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno)}func&nbsp;whatJob(p&nbsp;Person)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.job()}func&nbsp;growUp(p&nbsp;Person)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.growUp()}type&nbsp;Person&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;job()&nbsp;&nbsp;&nbsp;&nbsp;growUp()}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Student)&nbsp;job()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;I&nbsp;am&nbsp;a&nbsp;student.&quot;)&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(p&nbsp;*Student)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;return}type&nbsp;Programmer&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Programmer)&nbsp;job()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;I&nbsp;am&nbsp;a&nbsp;programmer.&quot;)&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(p&nbsp;Programmer)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序员老得太快&nbsp;^_^&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;return} ‍代码里先定义了 1 个 Person 接口，包含两个函数： job()growUp() 然后，又定义了 2 个结构体，Student 和 Programmer，同时，类型 *Student、Programmer 实现了 Person 接口定义的两个函数。注意，*Student 类型实现了接口， Student 类型却没有。 之后，我又定义了函数参数是 Person 接口的两个函数： func&nbsp;whatJob(p&nbsp;Person)func&nbsp;growUp(p&nbsp;Person) main 函数里先生成 Student 和 Programmer 的对象，再将它们分别传入到函数 whatJob 和 growUp。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，多态就实现了。 更深入一点来说的话，在函数 whatJob() 或者 growUp() 内部，接口 person 绑定了实体类型 *Student 或者 Programmer。根据前面分析的 iface 源码，这里会直接调用 fun 里保存的函数，类似于：s.tab-&gt;fun[0]，而因为 fun 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。 运行一下代码： I&nbsp;am&nbsp;a&nbsp;student.{19}I&nbsp;am&nbsp;a&nbsp;programmer.{100} Go 接口与 C++ 接口有何异同 接口定义了一种规范，描述了类的行为和功能，而不做具体实现。 C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 &quot;= 0&quot; 来指定的。例如： class&nbsp;Shape{&nbsp;&nbsp;&nbsp;public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;纯虚函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;double&nbsp;getArea()&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;名称}; 设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。 派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。 C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。 C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 itab 中的 fun 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 itab， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。 参考资料，由于篇幅有限，参考资料有删减 【包含反射、接口等源码分析】https://zhuanlan.zhihu.com/p/27055513 【虚函数表和C++的区别】https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q 【具体类型向接口赋值】https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html 【Go夜读群的讨论】https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md 【廖雪峰 鸭子类型】https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000 【值类型和指针类型，iface源码】https://www.jianshu.com/p/5f8ecbe4f6af 【总体说明itab的生成方式、作用】http://www.codeceo.com/article/go-interface.html 【conv系列函数的作用】https://blog.csdn.net/zhonglinzhang/article/details/85772336 【convI2I itab作用】https://www.jianshu.com/p/a5e99b1d50b1 作者：饶全成，中科院计算所硕士，滴滴出行后端研发工程师。 声明：本文为作者投稿，版权归其个人所有。免责声明：文章广告为微信自动匹配，与本平台无关，如遇假冒伪劣请联系微信进行举报。 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞工作 10 年，月薪过万者不足三成，程序员却笑了！ ☞红帽取代 Oracle，接管 OpenJDK 8 和 OpenJDK 11 | 极客头条 ☞44 岁的微软下一步是什么？ ☞天才程序员：25 岁进贝尔实验室，32 岁创建信息论 ☞&nbsp;扎心！工作 10 年，月薪过万者不足三成，程序员却笑了 ☞6张图告诉你, 区块链的未来在哪里 ☞我们应聘BAT等互联网公司，关于Spring到底需要掌握什么？ ☞如何确定最佳训练数据集规模？6 大必备“锦囊”全给你了 | 技术头条 ☞&nbsp;她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢" />
<meta property="og:description" content="Go 语言的接口的原理是什么？是如何使用？它和C++接口有什么异同呢？本文作者用两万多字深入一一为你讲述Go语言interface的那些事儿。 作者 |&nbsp;饶全成 责编 | 伍杏玲 这篇文章的架构比较简单，直接抛出 10 个问题，一一解答。 Go 语言与鸭子类型的关系 先直接来看维基百科里的定义： If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. 翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。 Duck Typing，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。 例如，在动态语言 Python 中，定义一个这样的函数： def&nbsp;hello_world(coder):&nbsp;coder.say_hello() 当调用此函数的时候，可以传入任意类型，只要它实现了 say_hello() 函数就可以。如果没有实现，运行过程中会出现错误。 而在静态语言如 Java、C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 hello_world 函数，却传入了一个根本就没有实现 say_hello() 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。 动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。插一句，这也是我不喜欢用 Python 的一个原因。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写Python 的同学比较清楚。 Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。 来看个例子： 先定义一个接口，和使用此接口作为参数的函数： type&nbsp;IGreeting&nbsp;interface&nbsp;{&nbsp;sayHello()}func&nbsp;sayHello(i&nbsp;IGreeting)&nbsp;{&nbsp;i.sayHello()} ‍再来定义两个结构体： type&nbsp;Go&nbsp;struct&nbsp;{}func&nbsp;(g&nbsp;Go)&nbsp;sayHello()&nbsp;{&nbsp; fmt.Println(&quot;Hi,&nbsp;I&nbsp;am&nbsp;GO!&quot;)}type&nbsp;PHP&nbsp;struct&nbsp;{}func&nbsp;(p&nbsp;PHP)&nbsp;sayHello()&nbsp;{&nbsp; fmt.Println(&quot;Hi,&nbsp;I&nbsp;am&nbsp;PHP!&quot;)} 最后，在 main 函数里调用 sayHello() 函数： func&nbsp;main()&nbsp;{&nbsp; golang&nbsp;:=&nbsp;Go{}&nbsp; php&nbsp;:=&nbsp;PHP{}&nbsp; sayHello(golang)&nbsp; sayHello(php)} 程序输出： Hi,&nbsp;I&nbsp;am&nbsp;GO!Hi,&nbsp;I&nbsp;am&nbsp;PHP! 在 main 函数中，调用调用 sayHello() 函数时，传入了 golang、 php 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 golang、php 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。 顺带再提一下动态语言的特点： 变量绑定的类型是不确定的，在运行期间才能确定 函数和方法可以接收任何类型的参数，且调用时不检查参数类型 不需要实现接口 总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它&quot;当前方法和属性的集合&quot;决定。Go 作为一种静态语言，通过接口实现了 鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。 值接收者和指针接收者的区别 方法 方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。 在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。 也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。 来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Person&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Person)&nbsp;howOld()&nbsp;int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;p.age}func&nbsp;(p&nbsp;*Person)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;qcrao&nbsp;是值类型&nbsp;&nbsp;&nbsp;&nbsp;qcrao&nbsp;:=&nbsp;Person{age:&nbsp;18}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;值类型&nbsp;调用接收者也是值类型的方法&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;值类型&nbsp;调用接收者是指针类型的方法&nbsp;&nbsp;&nbsp;&nbsp;qcrao.growUp()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;----------------------&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;stefno&nbsp;是指针类型&nbsp;&nbsp;&nbsp;&nbsp;stefno&nbsp;:=&nbsp;&amp;Person{age:&nbsp;100}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指针类型&nbsp;调用接收者是值类型的方法&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指针类型&nbsp;调用接收者也是指针类型的方法&nbsp;&nbsp;&nbsp;&nbsp;stefno.growUp()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno.howOld())} 上例子的输出结果是： 1819100101 调用了 growUp 函数后，不管调用者是值类型还是指针类型，它的 Age 值都改变了。 实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现： - 值接收者 指针接收者 值类型调用者 方法会使用调用者的一个副本，类似于“传值” 使用值的引用来调用方法，上例中，qcrao.growUp()&nbsp;实际上是&nbsp;(&amp;qcrao).growUp() 指针类型调用者 指针被解引用为值，上例中，stefno.howOld()&nbsp;实际上是&nbsp;(*stefno).howOld() 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 值接收者和指针接收者 前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。 先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。 来看一个例子，就会完全明白： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;debug()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(p&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;coding&nbsp;%s&nbsp;language\n&quot;,&nbsp;p.language)}func&nbsp;(p&nbsp;*Gopher)&nbsp;debug()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;debuging&nbsp;%s&nbsp;language\n&quot;,&nbsp;p.language)}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;&amp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;c.code()&nbsp;&nbsp;&nbsp;&nbsp;c.debug()} 上述代码里定义了一个接口 coder，接口定义了两个函数：code()、debug()。 接着定义了一个结构体 Gopher，它实现了两个方法，一个值接收者，一个指针接收者。 最后，我们在 main 函数里通过接口类型的变量调用了定义的两个函数。 运行一下，结果： I&nbsp;am&nbsp;coding&nbsp;Go&nbsp;languageI&nbsp;am&nbsp;debuging&nbsp;Go&nbsp;language 但是如果我们把 main 函数的第一条语句换一下： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;c.code()&nbsp;&nbsp;&nbsp;&nbsp;c.debug()} 运行一下，报错： ./main.go:24:6:&nbsp;cannot&nbsp;use&nbsp;Programmer&nbsp;literal&nbsp;(type&nbsp;Programmer)&nbsp;as&nbsp;type&nbsp;coder&nbsp;in&nbsp;assignment:&nbsp;Programmer&nbsp;does&nbsp;not&nbsp;implement&nbsp;coder&nbsp;(debug&nbsp;method&nbsp;has&nbsp;pointer&nbsp;receiver) 看出这两处代码的差别了吗？第一次是将 &amp;Gopher 赋给了 coder；第二次则是将 Gopher 赋给了 coder。 第二次报错是说，Gopher 没有实现 coder。很明显了吧，因为 Gopher 类型并没有实现 debug 方法；表面上看， *Gopher 类型也没有实现 code 方法，但是因为 Gopher 类型实现了 code 方法，所以让 *Gopher 类型自动拥有了 code 方法。 当然，上面的说法有一个简单的解释：接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。 所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。 最后，只要记住下面这点就可以了： 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。 两者分别在何时使用 如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。 使用指针作为方法的接收者的理由： •方法能够修改接收者指向的值。 •避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。 是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。 如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。 如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。 这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。 iface 和 eface 的区别是什么 iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。 从源码层面看一下： type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;unsafe.Pointer}type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;&nbsp;*interfacetype&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;uint32&nbsp;//&nbsp;copy&nbsp;of&nbsp;_type.hash.&nbsp;Used&nbsp;for&nbsp;type&nbsp;switches.&nbsp;&nbsp;&nbsp;&nbsp;bad&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;type&nbsp;does&nbsp;not&nbsp;implement&nbsp;interface&nbsp;&nbsp;&nbsp;&nbsp;inhash&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;has&nbsp;this&nbsp;itab&nbsp;been&nbsp;added&nbsp;to&nbsp;hash?&nbsp;&nbsp;&nbsp;&nbsp;unused&nbsp;[2]byte&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;&nbsp;[1]uintptr&nbsp;//&nbsp;variable&nbsp;sized} iface 内部维护两个指针，tab 指向一个 itab 实体， 它表示接口的类型以及赋给这个接口的实体类型。data 则指向接口具体的值，一般而言是一个指向堆内存的指针。 再来仔细看一下 itab 结构体：_type 字段描述了实体的类型，包括内存对齐方式，大小等；inter 字段则描述了接口的类型。fun 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。 这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。 另外，你可能会觉得奇怪，为什么 fun 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。 再看一下 interfacetype 类型，它描述的是接口的类型： type&nbsp;interfacetype&nbsp;struct&nbsp;{&nbsp;typ&nbsp;_type&nbsp;pkgpath&nbsp;name&nbsp;mhdr&nbsp;[]imethod} 可以看到，它包装了 _type 类型，_type 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 mhdr 字段，表示接口所定义的函数列表， pkgpath 记录定义了接口的包名。 这里通过一张图来看下 iface 结构体的全貌： 接着来看一下 eface 的源码： type&nbsp;eface&nbsp;struct&nbsp;{&nbsp; _type&nbsp;*_type&nbsp; data&nbsp;unsafe.Pointer} 相比 iface，eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值。 我们来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;200&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;any&nbsp;interface{}&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(any)&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;:=&nbsp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c)}type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;debug()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(p&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;coding&nbsp;%s&nbsp;language\n&quot;,&nbsp;p.language)}func&nbsp;(p&nbsp;Gopher)&nbsp;debug()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;debuging&nbsp;%s&nbsp;language\n&quot;,&nbsp;p.language)} 执行命令，打印出汇编语言： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go 可以看到，main 函数里调用了两个函数： func&nbsp;convT2E64(t&nbsp;*_type,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(e&nbsp;eface)func&nbsp;convT2I(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface) 上面两个函数的参数和 iface 及 eface 结构体的字段是可以联系起来的：两个函数都是将参数组装一下，形成最终的接口。 作为补充，我们最后再来看下 _type 结构体： type&nbsp;_type&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型大小&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;ptrdata&nbsp;&nbsp;&nbsp;&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的&nbsp;flag，和反射相关&nbsp;&nbsp;&nbsp;&nbsp;tflag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tflag&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;内存对齐相关&nbsp;&nbsp;&nbsp;&nbsp;align&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;fieldalign&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的编号，有bool,&nbsp;slice,&nbsp;struct&nbsp;等等等等&nbsp;&nbsp;&nbsp;&nbsp;kind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;alg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*typeAlg&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;gc&nbsp;相关&nbsp;&nbsp;&nbsp;&nbsp;gcdata&nbsp;&nbsp;&nbsp;&nbsp;*byte&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nameOff&nbsp;&nbsp;&nbsp;&nbsp;ptrToThis&nbsp;typeOff} Go 语言各种数据类型都是在 _type 字段的基础上，增加一些额外的字段来进行管理的： type&nbsp;arraytype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;slice&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;&nbsp;&nbsp;uintptr}type&nbsp;chantype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;dir&nbsp;&nbsp;uintptr}type&nbsp;slicetype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;*_type}type&nbsp;structtype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;fields&nbsp;&nbsp;[]structfield} 这些数据类型的结构体定义，是反射实现的基础。 接口的动态类型和动态值 从源码里可以看到：iface包含两个字段：tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值。 【引申1】接口类型和&nbsp;nil&nbsp;作比较 接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。 来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;string}func&nbsp;(g&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%s&nbsp;is&nbsp;coding\n&quot;,&nbsp;g.name)}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;Coder&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;c:&nbsp;%T,&nbsp;%v\n&quot;,&nbsp;c,&nbsp;c)&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;g&nbsp;*Gopher&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(g&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;c:&nbsp;%T,&nbsp;%v\n&quot;,&nbsp;c,&nbsp;c)} 输出： truec:&nbsp;&lt;nil&gt;,&nbsp;&lt;nil&gt;truefalsec:&nbsp;*main.Gopher,&nbsp;&lt;nil&gt; 一开始，c 的 动态类型和动态值都为 nil，g 也为 nil，当把 g 赋值给 c 后，c 的动态类型变成了 *main.Gopher，仅管 c 的动态值仍为 nil，但是当 c 和 nil 作比较的时候，结果就是 false 了。 【引申2】 来看一个例子，看一下它的输出： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;MyError&nbsp;struct&nbsp;{}func&nbsp;(i&nbsp;MyError)&nbsp;Error()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;MyError&quot;}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;:=&nbsp;Process()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err&nbsp;==&nbsp;nil)}func&nbsp;Process()&nbsp;error&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;err&nbsp;*MyError&nbsp;=&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;err} 函数运行结果： &lt;nil&gt;false 这里先定义了一个 MyError 结构体，实现了 Error 函数，也就实现了 error 接口。Process 函数返回了一个 error 接口，这块隐含了类型转换。所以，虽然它的值是 nil，其实它的类型是 *MyError，最后和 nil 比较的时候，结果为 false。 【引申3】如何打印出接口的动态类型和值？ 直接看代码： package&nbsp;mainimport&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&quot;unsafe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&quot;fmt&quot;)type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;itab,&nbsp;data&nbsp;uintptr}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;a&nbsp;interface{}&nbsp;=&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;b&nbsp;interface{}&nbsp;=&nbsp;(*int)(nil)&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;interface{}&nbsp;=&nbsp;(*int)(&amp;x)&nbsp;&nbsp;&nbsp;&nbsp;ia&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;a))&nbsp;&nbsp;&nbsp;&nbsp;ib&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;b))&nbsp;&nbsp;&nbsp;&nbsp;ic&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;c))&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ia,&nbsp;ib,&nbsp;ic)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(*(*int)(unsafe.Pointer(ic.data)))} 代码里直接定义了一个 iface 结构体，用两个指针来描述 itab 和 data，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 iface。最后就可以打印出动态类型和动态值的地址。 运行结果如下： {0&nbsp;0}&nbsp;{17426912&nbsp;0}&nbsp;{17426912&nbsp;842350714568}5 a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 *int；最后，c 的动态值为 5。 编译器自动检测类型是否实现接口 经常看到一些开源库里会有一些类似下面这种奇怪的用法： var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil) 这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口。 来看一个例子： package&nbsp;mainimport&nbsp;&quot;io&quot;type&nbsp;myWriter&nbsp;struct&nbsp;{}/*func&nbsp;(w&nbsp;myWriter)&nbsp;Write(p&nbsp;[]byte)&nbsp;(n&nbsp;int,&nbsp;err&nbsp;error)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}*/func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查&nbsp;*myWriter&nbsp;类型是否实现了&nbsp;io.Writer&nbsp;接口&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查&nbsp;myWriter&nbsp;类型是否实现了&nbsp;io.Writer&nbsp;接口&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;myWriter{}} 注释掉为 myWriter 定义的 Write 函数后，运行程序： src/main.go:14:6:&nbsp;cannot&nbsp;use&nbsp;(*myWriter)(nil)&nbsp;(type&nbsp;*myWriter)&nbsp;as&nbsp;type&nbsp;io.Writer&nbsp;in&nbsp;assignment:&nbsp;&nbsp;&nbsp;&nbsp;*myWriter&nbsp;does&nbsp;not&nbsp;implement&nbsp;io.Writer&nbsp;(missing&nbsp;Write&nbsp;method)src/main.go:15:6:&nbsp;cannot&nbsp;use&nbsp;myWriter&nbsp;literal&nbsp;(type&nbsp;myWriter)&nbsp;as&nbsp;type&nbsp;io.Writer&nbsp;in&nbsp;assignment:&nbsp;&nbsp;&nbsp;&nbsp;myWriter&nbsp;does&nbsp;not&nbsp;implement&nbsp;io.Writer&nbsp;(missing&nbsp;Write&nbsp;method) 报错信息：*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。 解除注释后，运行程序不报错。 实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。 总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口： var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil)var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;myWriter{} 接口的构造过程是怎样的 我们已经看过了 iface 和 eface 的源码，知道 iface 最重要的是 itab 和 _type。 为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。 来看一个示例代码： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Person&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;growUp()}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Student)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;qcrao&nbsp;=&nbsp;Person(Student{age:&nbsp;18})&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao)} 执行命令： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go 得到 main 函数的汇编代码如下： 0x0000&nbsp;00000&nbsp;(./src/main.go:30)&nbsp;TEXT&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;.main(SB),&nbsp;$80-00x0000&nbsp;00000&nbsp;(./src/main.go:30)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;(TLS),&nbsp;CX0x0009&nbsp;00009&nbsp;(./src/main.go:30)&nbsp;CMPQ&nbsp;&nbsp;&nbsp;&nbsp;SP,&nbsp;16(CX)0x000d&nbsp;00013&nbsp;(./src/main.go:30)&nbsp;JLS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1570x0013&nbsp;00019&nbsp;(./src/main.go:30)&nbsp;SUBQ&nbsp;&nbsp;&nbsp;&nbsp;$80,&nbsp;SP0x0017&nbsp;00023&nbsp;(./src/main.go:30)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;BP,&nbsp;72(SP)0x001c&nbsp;00028&nbsp;(./src/main.go:30)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;72(SP),&nbsp;BP0x0021&nbsp;00033&nbsp;(./src/main.go:30)&nbsp;FUNCDATA$0,&nbsp;gclocals·69c1753bd5f81501d95132d08af04464(SB)0x0021&nbsp;00033&nbsp;(./src/main.go:30)&nbsp;FUNCDATA$1,&nbsp;gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)0x0021&nbsp;00033&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$18,&nbsp;&quot;&quot;..autotmp_1+48(SP)0x002a&nbsp;00042&nbsp;(./src/main.go:31)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB),&nbsp;AX0x0031&nbsp;00049&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;(SP)0x0035&nbsp;00053&nbsp;(./src/main.go:31)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;..autotmp_1+48(SP),&nbsp;AX0x003a&nbsp;00058&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;8(SP)0x003f&nbsp;00063&nbsp;(./src/main.go:31)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$00x003f&nbsp;00063&nbsp;(./src/main.go:31)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;runtime.convT2I64(SB)0x0044&nbsp;00068&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;24(SP),&nbsp;AX0x0049&nbsp;00073&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;16(SP),&nbsp;CX0x004e&nbsp;00078&nbsp;(./src/main.go:33)&nbsp;TESTQ&nbsp;&nbsp;&nbsp;CX,&nbsp;CX0x0051&nbsp;00081&nbsp;(./src/main.go:33)&nbsp;JEQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;870x0053&nbsp;00083&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;8(CX),&nbsp;CX0x0057&nbsp;00087&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$0,&nbsp;&quot;&quot;..autotmp_2+56(SP)0x0060&nbsp;00096&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$0,&nbsp;&quot;&quot;..autotmp_2+64(SP)0x0069&nbsp;00105&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;CX,&nbsp;&quot;&quot;..autotmp_2+56(SP)0x006e&nbsp;00110&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;&quot;&quot;..autotmp_2+64(SP)0x0073&nbsp;00115&nbsp;(./src/main.go:33)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;..autotmp_2+56(SP),&nbsp;AX0x0078&nbsp;00120&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;(SP)0x007c&nbsp;00124&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$1,&nbsp;8(SP)0x0085&nbsp;00133&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$1,&nbsp;16(SP)0x008e&nbsp;00142&nbsp;(./src/main.go:33)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$10x008e&nbsp;00142&nbsp;(./src/main.go:33)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(SB)0x0093&nbsp;00147&nbsp;(./src/main.go:34)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;72(SP),&nbsp;BP0x0098&nbsp;00152&nbsp;(./src/main.go:34)&nbsp;ADDQ&nbsp;&nbsp;&nbsp;&nbsp;$80,&nbsp;SP0x009c&nbsp;00156&nbsp;(./src/main.go:34)&nbsp;RET0x009d&nbsp;00157&nbsp;(./src/main.go:34)&nbsp;NOP0x009d&nbsp;00157&nbsp;(./src/main.go:30)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$-10x009d&nbsp;00157&nbsp;(./src/main.go:30)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;runtime.morestack_noctxt(SB)0x00a2&nbsp;00162&nbsp;(./src/main.go:30)&nbsp;JMP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。 汇编行数 操作 10-14 构造调用&nbsp;runtime.convT2I64(SB)&nbsp;的参数 我们来看下这个函数的参数形式： func&nbsp;convT2I64(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface)&nbsp;{&nbsp;//&nbsp;……} convT2I64 会构造出一个 inteface，也就是我们的 Person 接口。 第一个参数的位置是 (SP)，这里被赋上了 go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB) 的地址。 我们从生成的汇编找到： go.itab.&quot;&quot;.Student,&quot;&quot;.Person&nbsp;SNOPTRDATA&nbsp;dupok&nbsp;size=40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0010&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;da&nbsp;9f&nbsp;20&nbsp;d4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel&nbsp;0+8&nbsp;t=1&nbsp;type.&quot;&quot;.Person+0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel&nbsp;8+8&nbsp;t=1&nbsp;type.&quot;&quot;.Student+0 size=40 大小为40字节，回顾一下： type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;&nbsp;*interfacetype&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;*_type&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;&nbsp;&nbsp;*itab&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;uint32&nbsp;//&nbsp;4字节&nbsp;&nbsp;&nbsp;&nbsp;bad&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;1字节&nbsp;&nbsp;&nbsp;&nbsp;inhash&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;1字节&nbsp;&nbsp;&nbsp;&nbsp;unused&nbsp;[2]byte&nbsp;//&nbsp;2字节&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;&nbsp;[1]uintptr&nbsp;//&nbsp;variable&nbsp;sized&nbsp;//&nbsp;8字节} 把每个字段的大小相加，itab 结构体的大小就是 40 字节。上面那一串数字实际上是 itab 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 da 9f 20 d4 实际上是 itab 的 hash 值，这在判断两个类型是否相同的时候会用到。 下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 type.&quot;&quot;.Person 的地址，对应 itab 里的 inter 字段，表示接口类型；8-16 字节最终存储的是 type.&quot;&quot;.Student 的地址，对应 itab 里 _type 字段，表示具体类型。 第二个参数就比较简单了，它就是数字 18 的地址，这也是初始化 Student 结构体的时候会用到。 汇编行数 操作 15 调用&nbsp;runtime.convT2I64(SB) 具体看下代码： func&nbsp;convT2I64(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;tab._type&nbsp;&nbsp;&nbsp;&nbsp;//...&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;x&nbsp;unsafe.Pointer&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;*(*uint64)(elem)&nbsp;==&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;unsafe.Pointer(&amp;zeroVal[0])&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;mallocgc(8,&nbsp;t,&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(*uint64)(x)&nbsp;=&nbsp;*(*uint64)(elem)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;i.tab&nbsp;=&nbsp;tab&nbsp;&nbsp;&nbsp;&nbsp;i.data&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;return} ‍这块代码比较简单，把 tab 赋给了 iface 的 tab 字段；data 部分则是在堆上申请了一块内存，然后将 elem 指向的 18 拷贝过去。这样 iface 就组装好了。 汇编行数 操作 17 把&nbsp;i.tab&nbsp;赋给&nbsp;CX 18 把&nbsp;i.data&nbsp;赋给&nbsp;AX 19-21 检测&nbsp;i.tab&nbsp;是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把&nbsp;itab&nbsp;的&nbsp;_type&nbsp;字段赋给了 CX，这也是接口的实体类型，最终要作为&nbsp;fmt.Println&nbsp;函数的参数 后面，就是调用 fmt.Println 函数及之前的参数准备工作了，不再赘述。 这样，我们就把一个 interface 的构造过程说完了。 【引申1】 如何打印出接口类型的 Hash 值？ 这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下： type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;unsafe.Pointer}type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;uint32&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4]byte&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;[1]uintptr}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;qcrao&nbsp;=&nbsp;Person(Student{age:&nbsp;18})&nbsp;&nbsp;&nbsp;&nbsp;iface&nbsp;:=&nbsp;(*iface)(unsafe.Pointer(&amp;qcrao))&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;iface.tab.hash&nbsp;=&nbsp;%#x\n&quot;,&nbsp;iface.tab.hash)} ‍了一个山寨版的 iface 和 itab，说它山寨是因为 itab 里的一些关键数据结构都不具体展开了，比如 _type，对比一下正宗的定义就可以发现，但是山寨版依然能工作，因为 _type 就是一个指针而已嘛。 在 main 函数里，先构造出一个接口对象 qcrao，然后强制类型转换，最后读取出 hash 值，非常妙！你也可以自己动手试一下。 运行结果： iface.tab.hash&nbsp;=&nbsp;0xd4209fda 值得一提的是，构造接口 qcrao 的时候，即使我把 age 写成其他值，得到的 hash 值依然不变的，这应该是可以预料的，hash 值只和他的字段、方法相关。 类型转换和断言的区别 我们知道，Go 语言中不允许隐式类型转换，也就是说 = 两边，不允许出现类型不相同的变量。 类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。 类型转换 对于类型转换而言，转换前后的两个类型要相互兼容才行。类型转换的语法为： &lt;结果类型&gt; := &lt;目标类型&gt; (&lt;表达式&gt;) package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;int&nbsp;=&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;f&nbsp;float64&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;float64(i)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%T,&nbsp;%v\n&quot;,&nbsp;f,&nbsp;f)&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;10.8&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;:=&nbsp;int(f)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%T,&nbsp;%v\n&quot;,&nbsp;a,&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;s&nbsp;:=&nbsp;[]int(i) 上面的代码里，我定义了一个 int 型和 float64 型的变量，尝试在它们之前相互转换，结果是成功的：int 型和 float64 是相互兼容的。 如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误： cannot&nbsp;convert&nbsp;i&nbsp;(type&nbsp;int)&nbsp;to&nbsp;type&nbsp;[]int ‍断言 前面说过，因为空接口 interface{} 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。 断言的语法为： &nbsp;// 安全类型断言 &lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 )&nbsp;&nbsp; //非安全类型断言 &lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 ) 类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。 还是来看一个简短的例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;i.(Student)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)} ‍运行一下： panic:&nbsp;interface&nbsp;conversion:&nbsp;interface&nbsp;{}&nbsp;is&nbsp;*main.Student,&nbsp;not&nbsp;main.Student ‍直接 panic 了，这是因为 i 是 *Student 类型，并非 Student 类型，断言失败。这里直接发生了 panic，线上代码可能并不适合这样做，可以采用“安全断言”的语法： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;ok&nbsp;:=&nbsp;i.(Student)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ok&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)&nbsp;&nbsp;&nbsp;&nbsp;}} 这样，即使断言失败也不会 panic。 断言其实还有另一种形式，就是用在利用 switch 语句判断接口的类型。每一个 case 会被顺序地考虑。当命中一个 case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case 匹配的情况。 代码示例如下： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;//var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil)&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;i,&nbsp;i)&nbsp;&nbsp;&nbsp;&nbsp;judge(i)}func&nbsp;judge(v&nbsp;interface{})&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;v&nbsp;:=&nbsp;v.(type)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;nil:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;nil&nbsp;type[%T]&nbsp;%v\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Student:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;Student&nbsp;type[%T]&nbsp;%v\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;*Student:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;*Student&nbsp;type[%T]&nbsp;%v\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;unknow\n&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int} main 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果： //&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)0xc4200701b0&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]0xc4200701d0&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]0xc420080020&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]*Student&nbsp;type[*main.Student]&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil)0xc42000e1d0&nbsp;&lt;nil&gt;0xc42000e1f0&nbsp;&lt;nil&gt;0xc42000c030&nbsp;&lt;nil&gt;*Student&nbsp;type[*main.Student]&nbsp;&lt;nil&gt;//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}0xc42000e1d0&nbsp;&lt;nil&gt;0xc42000e1e0&nbsp;&lt;nil&gt;0xc42000e1f0&nbsp;&lt;nil&gt;nil&nbsp;type[&lt;nil&gt;]&nbsp;&lt;nil&gt; 对于第一行语句： var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student) ‍i 是一个 *Student 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 main 函数里有一个局部变量 i；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 v，它是 i 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。 对于第二行语句： var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil) ‍这里想说明的其实是 i 在这里动态类型是 (*Student), 数据为 nil，它的类型并不是 nil，它与 nil 作比较的时候，得到的结果也是 false。 最后一行语句： var&nbsp;i&nbsp;interface{} 这回 i 才是 nil 类型。 【引申1】 fmt.Println 函数的参数是 interface。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 String() 方法，如果实现了，则直接打印输出 String() 方法的结果；否则，会通过反射来遍历对象的成员进行打印。 再来看一个简短的例子，比较简单，不要紧张： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;s&nbsp;=&nbsp;Student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name:&nbsp;&quot;qcrao&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age:&nbsp;18,&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)} ‍因为 Student 结构体没有实现 String() 方法，所以 fmt.Println 会利用反射挨个打印成员变量： {qcrao&nbsp;18} ‍增加一个 String() 方法的实现： func&nbsp;(s&nbsp;Student)&nbsp;String()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fmt.Sprintf(&quot;[Name:&nbsp;%s],&nbsp;[Age:&nbsp;%d]&quot;,&nbsp;s.Name,&nbsp;s.Age)} 打印结果： [Name:&nbsp;qcrao],&nbsp;[Age:&nbsp;18] ‍按照我们自定义的方法来打印了。 【引申2】 针对上面的例子，如果改一下： func&nbsp;(s&nbsp;*Student)&nbsp;String()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fmt.Sprintf(&quot;[Name:&nbsp;%s],&nbsp;[Age:&nbsp;%d]&quot;,&nbsp;s.Name,&nbsp;s.Age)} 注意看两个函数的接受者类型不同，现在 Student 结构体只有一个接受者类型为 指针类型 的 String() 函数，打印结果： {qcrao&nbsp;18} ‍为什么？ 类型 T 只有接受者是 T 的方法；而类型 *T 拥有接受者是 T 和 *T 的方法。语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖。 所以，&nbsp;Student&nbsp;结构体定义了接受者类型是值类型的&nbsp;String()&nbsp;方法时，通过 fmt.Println(s)fmt.Println(&amp;s) 均可以按照自定义的格式来打印。 如果&nbsp;Student&nbsp;结构体定义了接受者类型是指针类型的&nbsp;String()&nbsp;方法时，只有通过 fmt.Println(&amp;s) 才能按照自定义的格式打印。 接口转换的原理 通过前面提到的 iface 的源码可以看到，实际上它包含接口的类型 interfacetype 和 实体类型的类型 _type，这两者都是 iface 的字段 itab 的成员。也就是说生成一个 itab 同时需要接口的类型和实体的类型。 &lt;interface 类型， 实体类型&gt; -&gt;itable 当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。 例如某类型有 m 个方法，某接口有 n 个方法，则很容易知道这种判定的时间复杂度为 O(mn)，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 O(m+n)。 这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。 直接来看一个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;run()}type&nbsp;runner&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;run()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(g&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(g&nbsp;Gopher)&nbsp;run()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;Gopher{}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;r&nbsp;runner&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c,&nbsp;r)} 简单解释下上述代码：定义了两个 interface: coder 和 runner。定义了一个实体类型 Gopher，类型 Gopher 实现了两个方法，分别是 run() 和 code()。main 函数里定义了一个接口变量 c，绑定了一个 Gopher 对象，之后将 c 赋值给另外一个接口变量 r 。赋值成功的原因是 c 中包含 run() 方法。这样，两个接口变量完成了转换。 执行命令： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go ‍得到 main 函数的汇编命令，可以看到：r = c 这一行语句实际上是调用了 runtime.convI2I(SB)，也就是 convI2I 函数，从函数名来看，就是将一个 interface 转换成另外一个 interface，看下它的源代码： func&nbsp;convI2I(inter&nbsp;*interfacetype,&nbsp;i&nbsp;iface)&nbsp;(r&nbsp;iface)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;:=&nbsp;i.tab&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tab&nbsp;==&nbsp;nil&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tab.inter&nbsp;==&nbsp;inter&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.tab&nbsp;=&nbsp;tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.data&nbsp;=&nbsp;i.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;r.tab&nbsp;=&nbsp;getitab(inter,&nbsp;tab._type,&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;r.data&nbsp;=&nbsp;i.data&nbsp;&nbsp;&nbsp;&nbsp;return} 代码比较简单，函数参数 inter 表示接口类型，i 表示绑定了实体类型的接口，r 则表示接口转换了之后的新的 iface。通过前面的分析，我们又知道， iface 是由 tab 和 data 两个字段组成。所以，实际上 convI2I 函数真正要做的事，找到新 interface 的 tab 和 data，就大功告成了。 我们还知道，tab 是由接口类型 interfacetype 和 实体类型 _type。所以最关键的语句是 r.tab = getitab(inter, tab._type, false)。 因此，重点来看下 getitab 函数的源码，只看关键的地方： func&nbsp;getitab(inter&nbsp;*interfacetype,&nbsp;typ&nbsp;*_type,&nbsp;canfail&nbsp;bool)&nbsp;*itab&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;根据&nbsp;inter,&nbsp;typ&nbsp;计算出&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;itabhash(inter,&nbsp;typ)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;look&nbsp;twice&nbsp;-&nbsp;once&nbsp;without&nbsp;lock,&nbsp;once&nbsp;with.&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;common&nbsp;case&nbsp;will&nbsp;be&nbsp;no&nbsp;lock&nbsp;contention.&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;m&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;locked&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;locked&nbsp;=&nbsp;0;&nbsp;locked&nbsp;&lt;&nbsp;2;&nbsp;locked++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;locked&nbsp;!=&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;遍历哈希表的一个&nbsp;slot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;m&nbsp;=&nbsp;(*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h])));&nbsp;m&nbsp;!=&nbsp;nil;&nbsp;m&nbsp;=&nbsp;m.link&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果在&nbsp;hash&nbsp;表中已经找到了&nbsp;itab（inter&nbsp;和&nbsp;typ&nbsp;指针都相同）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m.inter&nbsp;==&nbsp;inter&nbsp;&amp;&amp;&nbsp;m._type&nbsp;==&nbsp;typ&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;locked&nbsp;!=&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在&nbsp;hash&nbsp;表中没有找到&nbsp;itab，那么新生成一个&nbsp;itab&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;(*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize,&nbsp;0,&nbsp;&amp;memstats.other_sys))&nbsp;&nbsp;&nbsp;&nbsp;m.inter&nbsp;=&nbsp;inter&nbsp;&nbsp;&nbsp;&nbsp;m._type&nbsp;=&nbsp;typ&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;添加到全局的&nbsp;hash&nbsp;表中&nbsp;&nbsp;&nbsp;&nbsp;additab(m,&nbsp;true,&nbsp;canfail)&nbsp;&nbsp;&nbsp;&nbsp;unlock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m.bad&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m} 简单总结一下：getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 interfacetype 和 _type 新生成一个 itab，并插入到 itab 哈希表，这样下一次就可以直接拿到 itab。 这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 itab 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 itab 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 itab。 再来看一下 additab 函数的代码： //&nbsp;检查&nbsp;_type&nbsp;是否符合&nbsp;interface_type&nbsp;并且创建对应的&nbsp;itab&nbsp;结构体&nbsp;将其放到&nbsp;hash&nbsp;表中func&nbsp;additab(m&nbsp;*itab,&nbsp;locked,&nbsp;canfail&nbsp;bool)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;:=&nbsp;m.inter&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;:=&nbsp;m._type&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;typ.uncommon()&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;both&nbsp;inter&nbsp;and&nbsp;typ&nbsp;have&nbsp;method&nbsp;sorted&nbsp;by&nbsp;name,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;and&nbsp;interface&nbsp;names&nbsp;are&nbsp;unique,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;so&nbsp;can&nbsp;iterate&nbsp;over&nbsp;both&nbsp;in&nbsp;lock&nbsp;step;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;loop&nbsp;is&nbsp;O(ni+nt)&nbsp;not&nbsp;O(ni*nt).&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;inter&nbsp;和&nbsp;typ&nbsp;的方法都按方法名称进行了排序&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;并且方法名都是唯一的。所以循环的次数是固定的&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;只用循环&nbsp;O(ni+nt)，而非&nbsp;O(ni*nt)&nbsp;&nbsp;&nbsp;&nbsp;ni&nbsp;:=&nbsp;len(inter.mhdr)&nbsp;&nbsp;&nbsp;&nbsp;nt&nbsp;:=&nbsp;int(x.mcount)&nbsp;&nbsp;&nbsp;&nbsp;xmhdr&nbsp;:=&nbsp;(*[1&nbsp;&lt;&lt;&nbsp;16]method)(add(unsafe.Pointer(x),&nbsp;uintptr(x.moff)))[:nt:nt]&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;:=&nbsp;0;&nbsp;k&nbsp;&lt;&nbsp;ni;&nbsp;k++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;&amp;inter.mhdr[k]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itype&nbsp;:=&nbsp;inter.typ.typeOff(i.ityp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;:=&nbsp;inter.typ.nameOff(i.name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iname&nbsp;:=&nbsp;name.name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipkg&nbsp;:=&nbsp;name.pkgPath()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ipkg&nbsp;==&nbsp;&quot;&quot;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipkg&nbsp;=&nbsp;inter.pkgpath.name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;;&nbsp;j&nbsp;&lt;&nbsp;nt;&nbsp;j++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;&amp;xmhdr[j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tname&nbsp;:=&nbsp;typ.nameOff(t.name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查方法名字是否一致&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;typ.typeOff(t.mtyp)&nbsp;==&nbsp;itype&nbsp;&amp;&amp;&nbsp;tname.name()&nbsp;==&nbsp;iname&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;:=&nbsp;tname.pkgPath()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pkgPath&nbsp;==&nbsp;&quot;&quot;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;=&nbsp;typ.nameOff(x.pkgpath).name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tname.isExported()&nbsp;||&nbsp;pkgPath&nbsp;==&nbsp;ipkg&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m&nbsp;!=&nbsp;nil&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取函数地址，并加入到itab.fun数组中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifn&nbsp;:=&nbsp;typ.textOff(t.ifn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]),&nbsp;uintptr(k)*sys.PtrSize))&nbsp;=&nbsp;ifn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;nextimethod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.bad&nbsp;=&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;nextimethod:&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!locked&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(&quot;invalid&nbsp;itab&nbsp;locking&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;计算&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;itabhash(inter,&nbsp;typ)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;加到Hash&nbsp;Slot链表中&nbsp;&nbsp;&nbsp;&nbsp;m.link&nbsp;=&nbsp;hash[h]&nbsp;&nbsp;&nbsp;&nbsp;m.inhash&nbsp;=&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;atomicstorep(unsafe.Pointer(&amp;hash[h]),&nbsp;unsafe.Pointer(m))} additab 会检查 itab 持有的 interfacetype 和 _type 是否符合，就是看 _type 是否完全实现了 interfacetype 的方法，也就是看两者的方法列表重叠的部分就是 interfacetype 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 ni * nt，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 ni + nt 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。 求 hash 值的函数比较简单： func&nbsp;itabhash(inter&nbsp;*interfacetype,&nbsp;typ&nbsp;*_type)&nbsp;uint32&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;inter.typ.hash&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;+=&nbsp;17&nbsp;*&nbsp;typ.hash&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;h&nbsp;%&nbsp;hashSize} hashSize 的值是 1009。 更一般的，当把实体类型赋值给接口的时候，会调用 conv 系列函数，例如空接口调用 convT2E 系列、非空接口调用 convT2I 系列。这些函数比较相似： 1.具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。 2.具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。 3.而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。 如何用 interface 实现多态 Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。 多态是一种运行期的行为，它有以下几个特点： 1.一种类型具有多种类型的能力 2.允许不同的对象对同一消息做出灵活的反应 3.以一种通用的方式对待个使用的对象 4.非动态语言必须通过继承和接口的方式来实现 看一个实现了多态的代码例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;qcrao&nbsp;:=&nbsp;Student{age:&nbsp;18}&nbsp;&nbsp;&nbsp;&nbsp;whatJob(&amp;qcrao)&nbsp;&nbsp;&nbsp;&nbsp;growUp(&amp;qcrao)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao)&nbsp;&nbsp;&nbsp;&nbsp;stefno&nbsp;:=&nbsp;Programmer{age:&nbsp;100}&nbsp;&nbsp;&nbsp;&nbsp;whatJob(stefno)&nbsp;&nbsp;&nbsp;&nbsp;growUp(stefno)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno)}func&nbsp;whatJob(p&nbsp;Person)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.job()}func&nbsp;growUp(p&nbsp;Person)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.growUp()}type&nbsp;Person&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;job()&nbsp;&nbsp;&nbsp;&nbsp;growUp()}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Student)&nbsp;job()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;I&nbsp;am&nbsp;a&nbsp;student.&quot;)&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(p&nbsp;*Student)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;return}type&nbsp;Programmer&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Programmer)&nbsp;job()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;I&nbsp;am&nbsp;a&nbsp;programmer.&quot;)&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(p&nbsp;Programmer)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序员老得太快&nbsp;^_^&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;return} ‍代码里先定义了 1 个 Person 接口，包含两个函数： job()growUp() 然后，又定义了 2 个结构体，Student 和 Programmer，同时，类型 *Student、Programmer 实现了 Person 接口定义的两个函数。注意，*Student 类型实现了接口， Student 类型却没有。 之后，我又定义了函数参数是 Person 接口的两个函数： func&nbsp;whatJob(p&nbsp;Person)func&nbsp;growUp(p&nbsp;Person) main 函数里先生成 Student 和 Programmer 的对象，再将它们分别传入到函数 whatJob 和 growUp。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，多态就实现了。 更深入一点来说的话，在函数 whatJob() 或者 growUp() 内部，接口 person 绑定了实体类型 *Student 或者 Programmer。根据前面分析的 iface 源码，这里会直接调用 fun 里保存的函数，类似于：s.tab-&gt;fun[0]，而因为 fun 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。 运行一下代码： I&nbsp;am&nbsp;a&nbsp;student.{19}I&nbsp;am&nbsp;a&nbsp;programmer.{100} Go 接口与 C++ 接口有何异同 接口定义了一种规范，描述了类的行为和功能，而不做具体实现。 C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 &quot;= 0&quot; 来指定的。例如： class&nbsp;Shape{&nbsp;&nbsp;&nbsp;public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;纯虚函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;double&nbsp;getArea()&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;名称}; 设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。 派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。 C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。 C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 itab 中的 fun 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 itab， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。 参考资料，由于篇幅有限，参考资料有删减 【包含反射、接口等源码分析】https://zhuanlan.zhihu.com/p/27055513 【虚函数表和C++的区别】https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q 【具体类型向接口赋值】https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html 【Go夜读群的讨论】https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md 【廖雪峰 鸭子类型】https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000 【值类型和指针类型，iface源码】https://www.jianshu.com/p/5f8ecbe4f6af 【总体说明itab的生成方式、作用】http://www.codeceo.com/article/go-interface.html 【conv系列函数的作用】https://blog.csdn.net/zhonglinzhang/article/details/85772336 【convI2I itab作用】https://www.jianshu.com/p/a5e99b1d50b1 作者：饶全成，中科院计算所硕士，滴滴出行后端研发工程师。 声明：本文为作者投稿，版权归其个人所有。免责声明：文章广告为微信自动匹配，与本平台无关，如遇假冒伪劣请联系微信进行举报。 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞工作 10 年，月薪过万者不足三成，程序员却笑了！ ☞红帽取代 Oracle，接管 OpenJDK 8 和 OpenJDK 11 | 极客头条 ☞44 岁的微软下一步是什么？ ☞天才程序员：25 岁进贝尔实验室，32 岁创建信息论 ☞&nbsp;扎心！工作 10 年，月薪过万者不足三成，程序员却笑了 ☞6张图告诉你, 区块链的未来在哪里 ☞我们应聘BAT等互联网公司，关于Spring到底需要掌握什么？ ☞如何确定最佳训练数据集规模？6 大必备“锦囊”全给你了 | 技术头条 ☞&nbsp;她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢" />
<link rel="canonical" href="https://mlh.app/2019/05/06/729704.html" />
<meta property="og:url" content="https://mlh.app/2019/05/06/729704.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Go 语言的接口的原理是什么？是如何使用？它和C++接口有什么异同呢？本文作者用两万多字深入一一为你讲述Go语言interface的那些事儿。 作者 |&nbsp;饶全成 责编 | 伍杏玲 这篇文章的架构比较简单，直接抛出 10 个问题，一一解答。 Go 语言与鸭子类型的关系 先直接来看维基百科里的定义： If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. 翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。 Duck Typing，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。 例如，在动态语言 Python 中，定义一个这样的函数： def&nbsp;hello_world(coder):&nbsp;coder.say_hello() 当调用此函数的时候，可以传入任意类型，只要它实现了 say_hello() 函数就可以。如果没有实现，运行过程中会出现错误。 而在静态语言如 Java、C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 hello_world 函数，却传入了一个根本就没有实现 say_hello() 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。 动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。插一句，这也是我不喜欢用 Python 的一个原因。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写Python 的同学比较清楚。 Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。 来看个例子： 先定义一个接口，和使用此接口作为参数的函数： type&nbsp;IGreeting&nbsp;interface&nbsp;{&nbsp;sayHello()}func&nbsp;sayHello(i&nbsp;IGreeting)&nbsp;{&nbsp;i.sayHello()} ‍再来定义两个结构体： type&nbsp;Go&nbsp;struct&nbsp;{}func&nbsp;(g&nbsp;Go)&nbsp;sayHello()&nbsp;{&nbsp; fmt.Println(&quot;Hi,&nbsp;I&nbsp;am&nbsp;GO!&quot;)}type&nbsp;PHP&nbsp;struct&nbsp;{}func&nbsp;(p&nbsp;PHP)&nbsp;sayHello()&nbsp;{&nbsp; fmt.Println(&quot;Hi,&nbsp;I&nbsp;am&nbsp;PHP!&quot;)} 最后，在 main 函数里调用 sayHello() 函数： func&nbsp;main()&nbsp;{&nbsp; golang&nbsp;:=&nbsp;Go{}&nbsp; php&nbsp;:=&nbsp;PHP{}&nbsp; sayHello(golang)&nbsp; sayHello(php)} 程序输出： Hi,&nbsp;I&nbsp;am&nbsp;GO!Hi,&nbsp;I&nbsp;am&nbsp;PHP! 在 main 函数中，调用调用 sayHello() 函数时，传入了 golang、 php 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 golang、php 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。 顺带再提一下动态语言的特点： 变量绑定的类型是不确定的，在运行期间才能确定 函数和方法可以接收任何类型的参数，且调用时不检查参数类型 不需要实现接口 总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它&quot;当前方法和属性的集合&quot;决定。Go 作为一种静态语言，通过接口实现了 鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。 值接收者和指针接收者的区别 方法 方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。 在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。 也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。 来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Person&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Person)&nbsp;howOld()&nbsp;int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;p.age}func&nbsp;(p&nbsp;*Person)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;qcrao&nbsp;是值类型&nbsp;&nbsp;&nbsp;&nbsp;qcrao&nbsp;:=&nbsp;Person{age:&nbsp;18}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;值类型&nbsp;调用接收者也是值类型的方法&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;值类型&nbsp;调用接收者是指针类型的方法&nbsp;&nbsp;&nbsp;&nbsp;qcrao.growUp()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;----------------------&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;stefno&nbsp;是指针类型&nbsp;&nbsp;&nbsp;&nbsp;stefno&nbsp;:=&nbsp;&amp;Person{age:&nbsp;100}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指针类型&nbsp;调用接收者是值类型的方法&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno.howOld())&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;指针类型&nbsp;调用接收者也是指针类型的方法&nbsp;&nbsp;&nbsp;&nbsp;stefno.growUp()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno.howOld())} 上例子的输出结果是： 1819100101 调用了 growUp 函数后，不管调用者是值类型还是指针类型，它的 Age 值都改变了。 实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现： - 值接收者 指针接收者 值类型调用者 方法会使用调用者的一个副本，类似于“传值” 使用值的引用来调用方法，上例中，qcrao.growUp()&nbsp;实际上是&nbsp;(&amp;qcrao).growUp() 指针类型调用者 指针被解引用为值，上例中，stefno.howOld()&nbsp;实际上是&nbsp;(*stefno).howOld() 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 值接收者和指针接收者 前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。 先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。 来看一个例子，就会完全明白： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;debug()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(p&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;coding&nbsp;%s&nbsp;language\\n&quot;,&nbsp;p.language)}func&nbsp;(p&nbsp;*Gopher)&nbsp;debug()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;debuging&nbsp;%s&nbsp;language\\n&quot;,&nbsp;p.language)}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;&amp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;c.code()&nbsp;&nbsp;&nbsp;&nbsp;c.debug()} 上述代码里定义了一个接口 coder，接口定义了两个函数：code()、debug()。 接着定义了一个结构体 Gopher，它实现了两个方法，一个值接收者，一个指针接收者。 最后，我们在 main 函数里通过接口类型的变量调用了定义的两个函数。 运行一下，结果： I&nbsp;am&nbsp;coding&nbsp;Go&nbsp;languageI&nbsp;am&nbsp;debuging&nbsp;Go&nbsp;language 但是如果我们把 main 函数的第一条语句换一下： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;c.code()&nbsp;&nbsp;&nbsp;&nbsp;c.debug()} 运行一下，报错： ./main.go:24:6:&nbsp;cannot&nbsp;use&nbsp;Programmer&nbsp;literal&nbsp;(type&nbsp;Programmer)&nbsp;as&nbsp;type&nbsp;coder&nbsp;in&nbsp;assignment:&nbsp;Programmer&nbsp;does&nbsp;not&nbsp;implement&nbsp;coder&nbsp;(debug&nbsp;method&nbsp;has&nbsp;pointer&nbsp;receiver) 看出这两处代码的差别了吗？第一次是将 &amp;Gopher 赋给了 coder；第二次则是将 Gopher 赋给了 coder。 第二次报错是说，Gopher 没有实现 coder。很明显了吧，因为 Gopher 类型并没有实现 debug 方法；表面上看， *Gopher 类型也没有实现 code 方法，但是因为 Gopher 类型实现了 code 方法，所以让 *Gopher 类型自动拥有了 code 方法。 当然，上面的说法有一个简单的解释：接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。 所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。 最后，只要记住下面这点就可以了： 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。 两者分别在何时使用 如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。 使用指针作为方法的接收者的理由： •方法能够修改接收者指向的值。 •避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。 是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。 如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。 如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。 这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。 iface 和 eface 的区别是什么 iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。 从源码层面看一下： type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;unsafe.Pointer}type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;&nbsp;*interfacetype&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;uint32&nbsp;//&nbsp;copy&nbsp;of&nbsp;_type.hash.&nbsp;Used&nbsp;for&nbsp;type&nbsp;switches.&nbsp;&nbsp;&nbsp;&nbsp;bad&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;type&nbsp;does&nbsp;not&nbsp;implement&nbsp;interface&nbsp;&nbsp;&nbsp;&nbsp;inhash&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;has&nbsp;this&nbsp;itab&nbsp;been&nbsp;added&nbsp;to&nbsp;hash?&nbsp;&nbsp;&nbsp;&nbsp;unused&nbsp;[2]byte&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;&nbsp;[1]uintptr&nbsp;//&nbsp;variable&nbsp;sized} iface 内部维护两个指针，tab 指向一个 itab 实体， 它表示接口的类型以及赋给这个接口的实体类型。data 则指向接口具体的值，一般而言是一个指向堆内存的指针。 再来仔细看一下 itab 结构体：_type 字段描述了实体的类型，包括内存对齐方式，大小等；inter 字段则描述了接口的类型。fun 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。 这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。 另外，你可能会觉得奇怪，为什么 fun 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。 再看一下 interfacetype 类型，它描述的是接口的类型： type&nbsp;interfacetype&nbsp;struct&nbsp;{&nbsp;typ&nbsp;_type&nbsp;pkgpath&nbsp;name&nbsp;mhdr&nbsp;[]imethod} 可以看到，它包装了 _type 类型，_type 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 mhdr 字段，表示接口所定义的函数列表， pkgpath 记录定义了接口的包名。 这里通过一张图来看下 iface 结构体的全貌： 接着来看一下 eface 的源码： type&nbsp;eface&nbsp;struct&nbsp;{&nbsp; _type&nbsp;*_type&nbsp; data&nbsp;unsafe.Pointer} 相比 iface，eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值。 我们来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;200&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;any&nbsp;interface{}&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(any)&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;:=&nbsp;Gopher{&quot;Go&quot;}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c)}type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;debug()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(p&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;coding&nbsp;%s&nbsp;language\\n&quot;,&nbsp;p.language)}func&nbsp;(p&nbsp;Gopher)&nbsp;debug()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;I&nbsp;am&nbsp;debuging&nbsp;%s&nbsp;language\\n&quot;,&nbsp;p.language)} 执行命令，打印出汇编语言： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go 可以看到，main 函数里调用了两个函数： func&nbsp;convT2E64(t&nbsp;*_type,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(e&nbsp;eface)func&nbsp;convT2I(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface) 上面两个函数的参数和 iface 及 eface 结构体的字段是可以联系起来的：两个函数都是将参数组装一下，形成最终的接口。 作为补充，我们最后再来看下 _type 结构体： type&nbsp;_type&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型大小&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;ptrdata&nbsp;&nbsp;&nbsp;&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的&nbsp;flag，和反射相关&nbsp;&nbsp;&nbsp;&nbsp;tflag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tflag&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;内存对齐相关&nbsp;&nbsp;&nbsp;&nbsp;align&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;fieldalign&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;类型的编号，有bool,&nbsp;slice,&nbsp;struct&nbsp;等等等等&nbsp;&nbsp;&nbsp;&nbsp;kind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint8&nbsp;&nbsp;&nbsp;&nbsp;alg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*typeAlg&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;gc&nbsp;相关&nbsp;&nbsp;&nbsp;&nbsp;gcdata&nbsp;&nbsp;&nbsp;&nbsp;*byte&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nameOff&nbsp;&nbsp;&nbsp;&nbsp;ptrToThis&nbsp;typeOff} Go 语言各种数据类型都是在 _type 字段的基础上，增加一些额外的字段来进行管理的： type&nbsp;arraytype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;slice&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;&nbsp;&nbsp;uintptr}type&nbsp;chantype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;*_type&nbsp;&nbsp;&nbsp;&nbsp;dir&nbsp;&nbsp;uintptr}type&nbsp;slicetype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;*_type}type&nbsp;structtype&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;fields&nbsp;&nbsp;[]structfield} 这些数据类型的结构体定义，是反射实现的基础。 接口的动态类型和动态值 从源码里可以看到：iface包含两个字段：tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值。 【引申1】接口类型和&nbsp;nil&nbsp;作比较 接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。 来看个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;string}func&nbsp;(g&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%s&nbsp;is&nbsp;coding\\n&quot;,&nbsp;g.name)}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;Coder&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;c:&nbsp;%T,&nbsp;%v\\n&quot;,&nbsp;c,&nbsp;c)&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;g&nbsp;*Gopher&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(g&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c&nbsp;==&nbsp;nil)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;c:&nbsp;%T,&nbsp;%v\\n&quot;,&nbsp;c,&nbsp;c)} 输出： truec:&nbsp;&lt;nil&gt;,&nbsp;&lt;nil&gt;truefalsec:&nbsp;*main.Gopher,&nbsp;&lt;nil&gt; 一开始，c 的 动态类型和动态值都为 nil，g 也为 nil，当把 g 赋值给 c 后，c 的动态类型变成了 *main.Gopher，仅管 c 的动态值仍为 nil，但是当 c 和 nil 作比较的时候，结果就是 false 了。 【引申2】 来看一个例子，看一下它的输出： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;MyError&nbsp;struct&nbsp;{}func&nbsp;(i&nbsp;MyError)&nbsp;Error()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;MyError&quot;}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;:=&nbsp;Process()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err&nbsp;==&nbsp;nil)}func&nbsp;Process()&nbsp;error&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;err&nbsp;*MyError&nbsp;=&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;err} 函数运行结果： &lt;nil&gt;false 这里先定义了一个 MyError 结构体，实现了 Error 函数，也就实现了 error 接口。Process 函数返回了一个 error 接口，这块隐含了类型转换。所以，虽然它的值是 nil，其实它的类型是 *MyError，最后和 nil 比较的时候，结果为 false。 【引申3】如何打印出接口的动态类型和值？ 直接看代码： package&nbsp;mainimport&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;&quot;unsafe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&quot;fmt&quot;)type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;itab,&nbsp;data&nbsp;uintptr}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;a&nbsp;interface{}&nbsp;=&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;b&nbsp;interface{}&nbsp;=&nbsp;(*int)(nil)&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;interface{}&nbsp;=&nbsp;(*int)(&amp;x)&nbsp;&nbsp;&nbsp;&nbsp;ia&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;a))&nbsp;&nbsp;&nbsp;&nbsp;ib&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;b))&nbsp;&nbsp;&nbsp;&nbsp;ic&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;c))&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ia,&nbsp;ib,&nbsp;ic)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(*(*int)(unsafe.Pointer(ic.data)))} 代码里直接定义了一个 iface 结构体，用两个指针来描述 itab 和 data，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 iface。最后就可以打印出动态类型和动态值的地址。 运行结果如下： {0&nbsp;0}&nbsp;{17426912&nbsp;0}&nbsp;{17426912&nbsp;842350714568}5 a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 *int；最后，c 的动态值为 5。 编译器自动检测类型是否实现接口 经常看到一些开源库里会有一些类似下面这种奇怪的用法： var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil) 这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口。 来看一个例子： package&nbsp;mainimport&nbsp;&quot;io&quot;type&nbsp;myWriter&nbsp;struct&nbsp;{}/*func&nbsp;(w&nbsp;myWriter)&nbsp;Write(p&nbsp;[]byte)&nbsp;(n&nbsp;int,&nbsp;err&nbsp;error)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}*/func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查&nbsp;*myWriter&nbsp;类型是否实现了&nbsp;io.Writer&nbsp;接口&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查&nbsp;myWriter&nbsp;类型是否实现了&nbsp;io.Writer&nbsp;接口&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;myWriter{}} 注释掉为 myWriter 定义的 Write 函数后，运行程序： src/main.go:14:6:&nbsp;cannot&nbsp;use&nbsp;(*myWriter)(nil)&nbsp;(type&nbsp;*myWriter)&nbsp;as&nbsp;type&nbsp;io.Writer&nbsp;in&nbsp;assignment:&nbsp;&nbsp;&nbsp;&nbsp;*myWriter&nbsp;does&nbsp;not&nbsp;implement&nbsp;io.Writer&nbsp;(missing&nbsp;Write&nbsp;method)src/main.go:15:6:&nbsp;cannot&nbsp;use&nbsp;myWriter&nbsp;literal&nbsp;(type&nbsp;myWriter)&nbsp;as&nbsp;type&nbsp;io.Writer&nbsp;in&nbsp;assignment:&nbsp;&nbsp;&nbsp;&nbsp;myWriter&nbsp;does&nbsp;not&nbsp;implement&nbsp;io.Writer&nbsp;(missing&nbsp;Write&nbsp;method) 报错信息：*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。 解除注释后，运行程序不报错。 实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。 总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口： var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(nil)var&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;myWriter{} 接口的构造过程是怎样的 我们已经看过了 iface 和 eface 的源码，知道 iface 最重要的是 itab 和 _type。 为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。 来看一个示例代码： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Person&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;growUp()}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Student)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;qcrao&nbsp;=&nbsp;Person(Student{age:&nbsp;18})&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao)} 执行命令： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go 得到 main 函数的汇编代码如下： 0x0000&nbsp;00000&nbsp;(./src/main.go:30)&nbsp;TEXT&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;.main(SB),&nbsp;$80-00x0000&nbsp;00000&nbsp;(./src/main.go:30)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;(TLS),&nbsp;CX0x0009&nbsp;00009&nbsp;(./src/main.go:30)&nbsp;CMPQ&nbsp;&nbsp;&nbsp;&nbsp;SP,&nbsp;16(CX)0x000d&nbsp;00013&nbsp;(./src/main.go:30)&nbsp;JLS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1570x0013&nbsp;00019&nbsp;(./src/main.go:30)&nbsp;SUBQ&nbsp;&nbsp;&nbsp;&nbsp;$80,&nbsp;SP0x0017&nbsp;00023&nbsp;(./src/main.go:30)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;BP,&nbsp;72(SP)0x001c&nbsp;00028&nbsp;(./src/main.go:30)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;72(SP),&nbsp;BP0x0021&nbsp;00033&nbsp;(./src/main.go:30)&nbsp;FUNCDATA$0,&nbsp;gclocals·69c1753bd5f81501d95132d08af04464(SB)0x0021&nbsp;00033&nbsp;(./src/main.go:30)&nbsp;FUNCDATA$1,&nbsp;gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)0x0021&nbsp;00033&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$18,&nbsp;&quot;&quot;..autotmp_1+48(SP)0x002a&nbsp;00042&nbsp;(./src/main.go:31)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB),&nbsp;AX0x0031&nbsp;00049&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;(SP)0x0035&nbsp;00053&nbsp;(./src/main.go:31)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;..autotmp_1+48(SP),&nbsp;AX0x003a&nbsp;00058&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;8(SP)0x003f&nbsp;00063&nbsp;(./src/main.go:31)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$00x003f&nbsp;00063&nbsp;(./src/main.go:31)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;runtime.convT2I64(SB)0x0044&nbsp;00068&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;24(SP),&nbsp;AX0x0049&nbsp;00073&nbsp;(./src/main.go:31)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;16(SP),&nbsp;CX0x004e&nbsp;00078&nbsp;(./src/main.go:33)&nbsp;TESTQ&nbsp;&nbsp;&nbsp;CX,&nbsp;CX0x0051&nbsp;00081&nbsp;(./src/main.go:33)&nbsp;JEQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;870x0053&nbsp;00083&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;8(CX),&nbsp;CX0x0057&nbsp;00087&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$0,&nbsp;&quot;&quot;..autotmp_2+56(SP)0x0060&nbsp;00096&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$0,&nbsp;&quot;&quot;..autotmp_2+64(SP)0x0069&nbsp;00105&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;CX,&nbsp;&quot;&quot;..autotmp_2+56(SP)0x006e&nbsp;00110&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;&quot;&quot;..autotmp_2+64(SP)0x0073&nbsp;00115&nbsp;(./src/main.go:33)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;..autotmp_2+56(SP),&nbsp;AX0x0078&nbsp;00120&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;(SP)0x007c&nbsp;00124&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$1,&nbsp;8(SP)0x0085&nbsp;00133&nbsp;(./src/main.go:33)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$1,&nbsp;16(SP)0x008e&nbsp;00142&nbsp;(./src/main.go:33)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$10x008e&nbsp;00142&nbsp;(./src/main.go:33)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(SB)0x0093&nbsp;00147&nbsp;(./src/main.go:34)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;72(SP),&nbsp;BP0x0098&nbsp;00152&nbsp;(./src/main.go:34)&nbsp;ADDQ&nbsp;&nbsp;&nbsp;&nbsp;$80,&nbsp;SP0x009c&nbsp;00156&nbsp;(./src/main.go:34)&nbsp;RET0x009d&nbsp;00157&nbsp;(./src/main.go:34)&nbsp;NOP0x009d&nbsp;00157&nbsp;(./src/main.go:30)&nbsp;PCDATA&nbsp;&nbsp;$0,&nbsp;$-10x009d&nbsp;00157&nbsp;(./src/main.go:30)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;runtime.morestack_noctxt(SB)0x00a2&nbsp;00162&nbsp;(./src/main.go:30)&nbsp;JMP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。 汇编行数 操作 10-14 构造调用&nbsp;runtime.convT2I64(SB)&nbsp;的参数 我们来看下这个函数的参数形式： func&nbsp;convT2I64(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface)&nbsp;{&nbsp;//&nbsp;……} convT2I64 会构造出一个 inteface，也就是我们的 Person 接口。 第一个参数的位置是 (SP)，这里被赋上了 go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB) 的地址。 我们从生成的汇编找到： go.itab.&quot;&quot;.Student,&quot;&quot;.Person&nbsp;SNOPTRDATA&nbsp;dupok&nbsp;size=40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0010&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;00&nbsp;da&nbsp;9f&nbsp;20&nbsp;d4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel&nbsp;0+8&nbsp;t=1&nbsp;type.&quot;&quot;.Person+0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel&nbsp;8+8&nbsp;t=1&nbsp;type.&quot;&quot;.Student+0 size=40 大小为40字节，回顾一下： type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;&nbsp;*interfacetype&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;*_type&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;&nbsp;&nbsp;*itab&nbsp;//&nbsp;8字节&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;uint32&nbsp;//&nbsp;4字节&nbsp;&nbsp;&nbsp;&nbsp;bad&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;1字节&nbsp;&nbsp;&nbsp;&nbsp;inhash&nbsp;bool&nbsp;&nbsp;&nbsp;//&nbsp;1字节&nbsp;&nbsp;&nbsp;&nbsp;unused&nbsp;[2]byte&nbsp;//&nbsp;2字节&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;&nbsp;[1]uintptr&nbsp;//&nbsp;variable&nbsp;sized&nbsp;//&nbsp;8字节} 把每个字段的大小相加，itab 结构体的大小就是 40 字节。上面那一串数字实际上是 itab 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 da 9f 20 d4 实际上是 itab 的 hash 值，这在判断两个类型是否相同的时候会用到。 下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 type.&quot;&quot;.Person 的地址，对应 itab 里的 inter 字段，表示接口类型；8-16 字节最终存储的是 type.&quot;&quot;.Student 的地址，对应 itab 里 _type 字段，表示具体类型。 第二个参数就比较简单了，它就是数字 18 的地址，这也是初始化 Student 结构体的时候会用到。 汇编行数 操作 15 调用&nbsp;runtime.convT2I64(SB) 具体看下代码： func&nbsp;convT2I64(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)&nbsp;(i&nbsp;iface)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;tab._type&nbsp;&nbsp;&nbsp;&nbsp;//...&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;x&nbsp;unsafe.Pointer&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;*(*uint64)(elem)&nbsp;==&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;unsafe.Pointer(&amp;zeroVal[0])&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;mallocgc(8,&nbsp;t,&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(*uint64)(x)&nbsp;=&nbsp;*(*uint64)(elem)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;i.tab&nbsp;=&nbsp;tab&nbsp;&nbsp;&nbsp;&nbsp;i.data&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;return} ‍这块代码比较简单，把 tab 赋给了 iface 的 tab 字段；data 部分则是在堆上申请了一块内存，然后将 elem 指向的 18 拷贝过去。这样 iface 就组装好了。 汇编行数 操作 17 把&nbsp;i.tab&nbsp;赋给&nbsp;CX 18 把&nbsp;i.data&nbsp;赋给&nbsp;AX 19-21 检测&nbsp;i.tab&nbsp;是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把&nbsp;itab&nbsp;的&nbsp;_type&nbsp;字段赋给了 CX，这也是接口的实体类型，最终要作为&nbsp;fmt.Println&nbsp;函数的参数 后面，就是调用 fmt.Println 函数及之前的参数准备工作了，不再赘述。 这样，我们就把一个 interface 的构造过程说完了。 【引申1】 如何打印出接口类型的 Hash 值？ 这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下： type&nbsp;iface&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;unsafe.Pointer}type&nbsp;itab&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;uintptr&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;uint32&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4]byte&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;[1]uintptr}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;qcrao&nbsp;=&nbsp;Person(Student{age:&nbsp;18})&nbsp;&nbsp;&nbsp;&nbsp;iface&nbsp;:=&nbsp;(*iface)(unsafe.Pointer(&amp;qcrao))&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;iface.tab.hash&nbsp;=&nbsp;%#x\\n&quot;,&nbsp;iface.tab.hash)} ‍了一个山寨版的 iface 和 itab，说它山寨是因为 itab 里的一些关键数据结构都不具体展开了，比如 _type，对比一下正宗的定义就可以发现，但是山寨版依然能工作，因为 _type 就是一个指针而已嘛。 在 main 函数里，先构造出一个接口对象 qcrao，然后强制类型转换，最后读取出 hash 值，非常妙！你也可以自己动手试一下。 运行结果： iface.tab.hash&nbsp;=&nbsp;0xd4209fda 值得一提的是，构造接口 qcrao 的时候，即使我把 age 写成其他值，得到的 hash 值依然不变的，这应该是可以预料的，hash 值只和他的字段、方法相关。 类型转换和断言的区别 我们知道，Go 语言中不允许隐式类型转换，也就是说 = 两边，不允许出现类型不相同的变量。 类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。 类型转换 对于类型转换而言，转换前后的两个类型要相互兼容才行。类型转换的语法为： &lt;结果类型&gt; := &lt;目标类型&gt; (&lt;表达式&gt;) package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;int&nbsp;=&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;f&nbsp;float64&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;float64(i)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%T,&nbsp;%v\\n&quot;,&nbsp;f,&nbsp;f)&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;10.8&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;:=&nbsp;int(f)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%T,&nbsp;%v\\n&quot;,&nbsp;a,&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;s&nbsp;:=&nbsp;[]int(i) 上面的代码里，我定义了一个 int 型和 float64 型的变量，尝试在它们之前相互转换，结果是成功的：int 型和 float64 是相互兼容的。 如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误： cannot&nbsp;convert&nbsp;i&nbsp;(type&nbsp;int)&nbsp;to&nbsp;type&nbsp;[]int ‍断言 前面说过，因为空接口 interface{} 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。 断言的语法为： &nbsp;// 安全类型断言 &lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 )&nbsp;&nbsp; //非安全类型断言 &lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 ) 类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。 还是来看一个简短的例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;i.(Student)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)} ‍运行一下： panic:&nbsp;interface&nbsp;conversion:&nbsp;interface&nbsp;{}&nbsp;is&nbsp;*main.Student,&nbsp;not&nbsp;main.Student ‍直接 panic 了，这是因为 i 是 *Student 类型，并非 Student 类型，断言失败。这里直接发生了 panic，线上代码可能并不适合这样做，可以采用“安全断言”的语法： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;ok&nbsp;:=&nbsp;i.(Student)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ok&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)&nbsp;&nbsp;&nbsp;&nbsp;}} 这样，即使断言失败也不会 panic。 断言其实还有另一种形式，就是用在利用 switch 语句判断接口的类型。每一个 case 会被顺序地考虑。当命中一个 case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case 匹配的情况。 代码示例如下： func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)&nbsp;&nbsp;&nbsp;&nbsp;//var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil)&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\\n&quot;,&nbsp;&amp;i,&nbsp;i)&nbsp;&nbsp;&nbsp;&nbsp;judge(i)}func&nbsp;judge(v&nbsp;interface{})&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;v&nbsp;:=&nbsp;v.(type)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;nil:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;nil&nbsp;type[%T]&nbsp;%v\\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Student:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;Student&nbsp;type[%T]&nbsp;%v\\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;*Student:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;*Student&nbsp;type[%T]&nbsp;%v\\n&quot;,&nbsp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;%p&nbsp;%v\\n&quot;,&nbsp;&amp;v,&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(&quot;unknow\\n&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int} main 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果： //&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)0xc4200701b0&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]0xc4200701d0&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]0xc420080020&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]*Student&nbsp;type[*main.Student]&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;0]//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil)0xc42000e1d0&nbsp;&lt;nil&gt;0xc42000e1f0&nbsp;&lt;nil&gt;0xc42000c030&nbsp;&lt;nil&gt;*Student&nbsp;type[*main.Student]&nbsp;&lt;nil&gt;//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}0xc42000e1d0&nbsp;&lt;nil&gt;0xc42000e1e0&nbsp;&lt;nil&gt;0xc42000e1f0&nbsp;&lt;nil&gt;nil&nbsp;type[&lt;nil&gt;]&nbsp;&lt;nil&gt; 对于第一行语句： var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student) ‍i 是一个 *Student 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 main 函数里有一个局部变量 i；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 v，它是 i 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。 对于第二行语句： var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil) ‍这里想说明的其实是 i 在这里动态类型是 (*Student), 数据为 nil，它的类型并不是 nil，它与 nil 作比较的时候，得到的结果也是 false。 最后一行语句： var&nbsp;i&nbsp;interface{} 这回 i 才是 nil 类型。 【引申1】 fmt.Println 函数的参数是 interface。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 String() 方法，如果实现了，则直接打印输出 String() 方法的结果；否则，会通过反射来遍历对象的成员进行打印。 再来看一个简短的例子，比较简单，不要紧张： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;int}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;s&nbsp;=&nbsp;Student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name:&nbsp;&quot;qcrao&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age:&nbsp;18,&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)} ‍因为 Student 结构体没有实现 String() 方法，所以 fmt.Println 会利用反射挨个打印成员变量： {qcrao&nbsp;18} ‍增加一个 String() 方法的实现： func&nbsp;(s&nbsp;Student)&nbsp;String()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fmt.Sprintf(&quot;[Name:&nbsp;%s],&nbsp;[Age:&nbsp;%d]&quot;,&nbsp;s.Name,&nbsp;s.Age)} 打印结果： [Name:&nbsp;qcrao],&nbsp;[Age:&nbsp;18] ‍按照我们自定义的方法来打印了。 【引申2】 针对上面的例子，如果改一下： func&nbsp;(s&nbsp;*Student)&nbsp;String()&nbsp;string&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fmt.Sprintf(&quot;[Name:&nbsp;%s],&nbsp;[Age:&nbsp;%d]&quot;,&nbsp;s.Name,&nbsp;s.Age)} 注意看两个函数的接受者类型不同，现在 Student 结构体只有一个接受者类型为 指针类型 的 String() 函数，打印结果： {qcrao&nbsp;18} ‍为什么？ 类型 T 只有接受者是 T 的方法；而类型 *T 拥有接受者是 T 和 *T 的方法。语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖。 所以，&nbsp;Student&nbsp;结构体定义了接受者类型是值类型的&nbsp;String()&nbsp;方法时，通过 fmt.Println(s)fmt.Println(&amp;s) 均可以按照自定义的格式来打印。 如果&nbsp;Student&nbsp;结构体定义了接受者类型是指针类型的&nbsp;String()&nbsp;方法时，只有通过 fmt.Println(&amp;s) 才能按照自定义的格式打印。 接口转换的原理 通过前面提到的 iface 的源码可以看到，实际上它包含接口的类型 interfacetype 和 实体类型的类型 _type，这两者都是 iface 的字段 itab 的成员。也就是说生成一个 itab 同时需要接口的类型和实体的类型。 &lt;interface 类型， 实体类型&gt; -&gt;itable 当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。 例如某类型有 m 个方法，某接口有 n 个方法，则很容易知道这种判定的时间复杂度为 O(mn)，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 O(m+n)。 这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。 直接来看一个例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;type&nbsp;coder&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;code()&nbsp;&nbsp;&nbsp;&nbsp;run()}type&nbsp;runner&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;run()}type&nbsp;Gopher&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;string}func&nbsp;(g&nbsp;Gopher)&nbsp;code()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(g&nbsp;Gopher)&nbsp;run()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;c&nbsp;coder&nbsp;=&nbsp;Gopher{}&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;r&nbsp;runner&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c,&nbsp;r)} 简单解释下上述代码：定义了两个 interface: coder 和 runner。定义了一个实体类型 Gopher，类型 Gopher 实现了两个方法，分别是 run() 和 code()。main 函数里定义了一个接口变量 c，绑定了一个 Gopher 对象，之后将 c 赋值给另外一个接口变量 r 。赋值成功的原因是 c 中包含 run() 方法。这样，两个接口变量完成了转换。 执行命令： go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go ‍得到 main 函数的汇编命令，可以看到：r = c 这一行语句实际上是调用了 runtime.convI2I(SB)，也就是 convI2I 函数，从函数名来看，就是将一个 interface 转换成另外一个 interface，看下它的源代码： func&nbsp;convI2I(inter&nbsp;*interfacetype,&nbsp;i&nbsp;iface)&nbsp;(r&nbsp;iface)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;:=&nbsp;i.tab&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tab&nbsp;==&nbsp;nil&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tab.inter&nbsp;==&nbsp;inter&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.tab&nbsp;=&nbsp;tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.data&nbsp;=&nbsp;i.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;r.tab&nbsp;=&nbsp;getitab(inter,&nbsp;tab._type,&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;r.data&nbsp;=&nbsp;i.data&nbsp;&nbsp;&nbsp;&nbsp;return} 代码比较简单，函数参数 inter 表示接口类型，i 表示绑定了实体类型的接口，r 则表示接口转换了之后的新的 iface。通过前面的分析，我们又知道， iface 是由 tab 和 data 两个字段组成。所以，实际上 convI2I 函数真正要做的事，找到新 interface 的 tab 和 data，就大功告成了。 我们还知道，tab 是由接口类型 interfacetype 和 实体类型 _type。所以最关键的语句是 r.tab = getitab(inter, tab._type, false)。 因此，重点来看下 getitab 函数的源码，只看关键的地方： func&nbsp;getitab(inter&nbsp;*interfacetype,&nbsp;typ&nbsp;*_type,&nbsp;canfail&nbsp;bool)&nbsp;*itab&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;根据&nbsp;inter,&nbsp;typ&nbsp;计算出&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;itabhash(inter,&nbsp;typ)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;look&nbsp;twice&nbsp;-&nbsp;once&nbsp;without&nbsp;lock,&nbsp;once&nbsp;with.&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;common&nbsp;case&nbsp;will&nbsp;be&nbsp;no&nbsp;lock&nbsp;contention.&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;m&nbsp;*itab&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;locked&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;locked&nbsp;=&nbsp;0;&nbsp;locked&nbsp;&lt;&nbsp;2;&nbsp;locked++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;locked&nbsp;!=&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;遍历哈希表的一个&nbsp;slot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;m&nbsp;=&nbsp;(*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h])));&nbsp;m&nbsp;!=&nbsp;nil;&nbsp;m&nbsp;=&nbsp;m.link&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果在&nbsp;hash&nbsp;表中已经找到了&nbsp;itab（inter&nbsp;和&nbsp;typ&nbsp;指针都相同）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m.inter&nbsp;==&nbsp;inter&nbsp;&amp;&amp;&nbsp;m._type&nbsp;==&nbsp;typ&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;locked&nbsp;!=&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;在&nbsp;hash&nbsp;表中没有找到&nbsp;itab，那么新生成一个&nbsp;itab&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;(*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize,&nbsp;0,&nbsp;&amp;memstats.other_sys))&nbsp;&nbsp;&nbsp;&nbsp;m.inter&nbsp;=&nbsp;inter&nbsp;&nbsp;&nbsp;&nbsp;m._type&nbsp;=&nbsp;typ&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;添加到全局的&nbsp;hash&nbsp;表中&nbsp;&nbsp;&nbsp;&nbsp;additab(m,&nbsp;true,&nbsp;canfail)&nbsp;&nbsp;&nbsp;&nbsp;unlock(&amp;ifaceLock)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m.bad&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m} 简单总结一下：getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 interfacetype 和 _type 新生成一个 itab，并插入到 itab 哈希表，这样下一次就可以直接拿到 itab。 这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 itab 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 itab 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 itab。 再来看一下 additab 函数的代码： //&nbsp;检查&nbsp;_type&nbsp;是否符合&nbsp;interface_type&nbsp;并且创建对应的&nbsp;itab&nbsp;结构体&nbsp;将其放到&nbsp;hash&nbsp;表中func&nbsp;additab(m&nbsp;*itab,&nbsp;locked,&nbsp;canfail&nbsp;bool)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;:=&nbsp;m.inter&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;:=&nbsp;m._type&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;typ.uncommon()&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;both&nbsp;inter&nbsp;and&nbsp;typ&nbsp;have&nbsp;method&nbsp;sorted&nbsp;by&nbsp;name,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;and&nbsp;interface&nbsp;names&nbsp;are&nbsp;unique,&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;so&nbsp;can&nbsp;iterate&nbsp;over&nbsp;both&nbsp;in&nbsp;lock&nbsp;step;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;loop&nbsp;is&nbsp;O(ni+nt)&nbsp;not&nbsp;O(ni*nt).&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;inter&nbsp;和&nbsp;typ&nbsp;的方法都按方法名称进行了排序&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;并且方法名都是唯一的。所以循环的次数是固定的&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;只用循环&nbsp;O(ni+nt)，而非&nbsp;O(ni*nt)&nbsp;&nbsp;&nbsp;&nbsp;ni&nbsp;:=&nbsp;len(inter.mhdr)&nbsp;&nbsp;&nbsp;&nbsp;nt&nbsp;:=&nbsp;int(x.mcount)&nbsp;&nbsp;&nbsp;&nbsp;xmhdr&nbsp;:=&nbsp;(*[1&nbsp;&lt;&lt;&nbsp;16]method)(add(unsafe.Pointer(x),&nbsp;uintptr(x.moff)))[:nt:nt]&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;k&nbsp;:=&nbsp;0;&nbsp;k&nbsp;&lt;&nbsp;ni;&nbsp;k++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;&amp;inter.mhdr[k]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itype&nbsp;:=&nbsp;inter.typ.typeOff(i.ityp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;:=&nbsp;inter.typ.nameOff(i.name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iname&nbsp;:=&nbsp;name.name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipkg&nbsp;:=&nbsp;name.pkgPath()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ipkg&nbsp;==&nbsp;&quot;&quot;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipkg&nbsp;=&nbsp;inter.pkgpath.name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;;&nbsp;j&nbsp;&lt;&nbsp;nt;&nbsp;j++&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;&amp;xmhdr[j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tname&nbsp;:=&nbsp;typ.nameOff(t.name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查方法名字是否一致&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;typ.typeOff(t.mtyp)&nbsp;==&nbsp;itype&nbsp;&amp;&amp;&nbsp;tname.name()&nbsp;==&nbsp;iname&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;:=&nbsp;tname.pkgPath()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;pkgPath&nbsp;==&nbsp;&quot;&quot;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;=&nbsp;typ.nameOff(x.pkgpath).name()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;tname.isExported()&nbsp;||&nbsp;pkgPath&nbsp;==&nbsp;ipkg&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;m&nbsp;!=&nbsp;nil&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取函数地址，并加入到itab.fun数组中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifn&nbsp;:=&nbsp;typ.textOff(t.ifn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]),&nbsp;uintptr(k)*sys.PtrSize))&nbsp;=&nbsp;ifn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;nextimethod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.bad&nbsp;=&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;nextimethod:&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;!locked&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(&quot;invalid&nbsp;itab&nbsp;locking&quot;)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;计算&nbsp;hash&nbsp;值&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;itabhash(inter,&nbsp;typ)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;加到Hash&nbsp;Slot链表中&nbsp;&nbsp;&nbsp;&nbsp;m.link&nbsp;=&nbsp;hash[h]&nbsp;&nbsp;&nbsp;&nbsp;m.inhash&nbsp;=&nbsp;true&nbsp;&nbsp;&nbsp;&nbsp;atomicstorep(unsafe.Pointer(&amp;hash[h]),&nbsp;unsafe.Pointer(m))} additab 会检查 itab 持有的 interfacetype 和 _type 是否符合，就是看 _type 是否完全实现了 interfacetype 的方法，也就是看两者的方法列表重叠的部分就是 interfacetype 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 ni * nt，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 ni + nt 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。 求 hash 值的函数比较简单： func&nbsp;itabhash(inter&nbsp;*interfacetype,&nbsp;typ&nbsp;*_type)&nbsp;uint32&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;inter.typ.hash&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;+=&nbsp;17&nbsp;*&nbsp;typ.hash&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;h&nbsp;%&nbsp;hashSize} hashSize 的值是 1009。 更一般的，当把实体类型赋值给接口的时候，会调用 conv 系列函数，例如空接口调用 convT2E 系列、非空接口调用 convT2I 系列。这些函数比较相似： 1.具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。 2.具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。 3.而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。 如何用 interface 实现多态 Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。 多态是一种运行期的行为，它有以下几个特点： 1.一种类型具有多种类型的能力 2.允许不同的对象对同一消息做出灵活的反应 3.以一种通用的方式对待个使用的对象 4.非动态语言必须通过继承和接口的方式来实现 看一个实现了多态的代码例子： package&nbsp;mainimport&nbsp;&quot;fmt&quot;func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;qcrao&nbsp;:=&nbsp;Student{age:&nbsp;18}&nbsp;&nbsp;&nbsp;&nbsp;whatJob(&amp;qcrao)&nbsp;&nbsp;&nbsp;&nbsp;growUp(&amp;qcrao)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao)&nbsp;&nbsp;&nbsp;&nbsp;stefno&nbsp;:=&nbsp;Programmer{age:&nbsp;100}&nbsp;&nbsp;&nbsp;&nbsp;whatJob(stefno)&nbsp;&nbsp;&nbsp;&nbsp;growUp(stefno)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno)}func&nbsp;whatJob(p&nbsp;Person)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.job()}func&nbsp;growUp(p&nbsp;Person)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.growUp()}type&nbsp;Person&nbsp;interface&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;job()&nbsp;&nbsp;&nbsp;&nbsp;growUp()}type&nbsp;Student&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Student)&nbsp;job()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;I&nbsp;am&nbsp;a&nbsp;student.&quot;)&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(p&nbsp;*Student)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;return}type&nbsp;Programmer&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;int}func&nbsp;(p&nbsp;Programmer)&nbsp;job()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&quot;I&nbsp;am&nbsp;a&nbsp;programmer.&quot;)&nbsp;&nbsp;&nbsp;&nbsp;return}func&nbsp;(p&nbsp;Programmer)&nbsp;growUp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;程序员老得太快&nbsp;^_^&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;return} ‍代码里先定义了 1 个 Person 接口，包含两个函数： job()growUp() 然后，又定义了 2 个结构体，Student 和 Programmer，同时，类型 *Student、Programmer 实现了 Person 接口定义的两个函数。注意，*Student 类型实现了接口， Student 类型却没有。 之后，我又定义了函数参数是 Person 接口的两个函数： func&nbsp;whatJob(p&nbsp;Person)func&nbsp;growUp(p&nbsp;Person) main 函数里先生成 Student 和 Programmer 的对象，再将它们分别传入到函数 whatJob 和 growUp。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，多态就实现了。 更深入一点来说的话，在函数 whatJob() 或者 growUp() 内部，接口 person 绑定了实体类型 *Student 或者 Programmer。根据前面分析的 iface 源码，这里会直接调用 fun 里保存的函数，类似于：s.tab-&gt;fun[0]，而因为 fun 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。 运行一下代码： I&nbsp;am&nbsp;a&nbsp;student.{19}I&nbsp;am&nbsp;a&nbsp;programmer.{100} Go 接口与 C++ 接口有何异同 接口定义了一种规范，描述了类的行为和功能，而不做具体实现。 C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 &quot;= 0&quot; 来指定的。例如： class&nbsp;Shape{&nbsp;&nbsp;&nbsp;public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;纯虚函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;double&nbsp;getArea()&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;名称}; 设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。 派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。 C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。 C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 itab 中的 fun 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 itab， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。 参考资料，由于篇幅有限，参考资料有删减 【包含反射、接口等源码分析】https://zhuanlan.zhihu.com/p/27055513 【虚函数表和C++的区别】https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q 【具体类型向接口赋值】https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html 【Go夜读群的讨论】https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md 【廖雪峰 鸭子类型】https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000 【值类型和指针类型，iface源码】https://www.jianshu.com/p/5f8ecbe4f6af 【总体说明itab的生成方式、作用】http://www.codeceo.com/article/go-interface.html 【conv系列函数的作用】https://blog.csdn.net/zhonglinzhang/article/details/85772336 【convI2I itab作用】https://www.jianshu.com/p/a5e99b1d50b1 作者：饶全成，中科院计算所硕士，滴滴出行后端研发工程师。 声明：本文为作者投稿，版权归其个人所有。免责声明：文章广告为微信自动匹配，与本平台无关，如遇假冒伪劣请联系微信进行举报。 【END】 作为码一代，想教码二代却无从下手： 听说少儿编程很火，可它有哪些好处呢？ 孩子多大开始学习比较好呢？又该如何学习呢？ 最新的编程教育政策又有哪些呢？ 下面给大家介绍CSDN新成员：极客宝宝（ID：geek_baby） 戳他了解更多↓↓↓ &nbsp;热 文&nbsp;推 荐&nbsp; ☞工作 10 年，月薪过万者不足三成，程序员却笑了！ ☞红帽取代 Oracle，接管 OpenJDK 8 和 OpenJDK 11 | 极客头条 ☞44 岁的微软下一步是什么？ ☞天才程序员：25 岁进贝尔实验室，32 岁创建信息论 ☞&nbsp;扎心！工作 10 年，月薪过万者不足三成，程序员却笑了 ☞6张图告诉你, 区块链的未来在哪里 ☞我们应聘BAT等互联网公司，关于Spring到底需要掌握什么？ ☞如何确定最佳训练数据集规模？6 大必备“锦囊”全给你了 | 技术头条 ☞&nbsp;她说：为啥程序员都特想要机械键盘？这答案我服！ System.out.println(&quot;点个在看吧！&quot;);console.log(&quot;点个在看吧！&quot;);print(&quot;点个在看吧！&quot;);printf(&quot;点个在看吧！\\n&quot;);cout&nbsp;&lt;&lt;&nbsp;&quot;点个在看吧！&quot;&nbsp;&lt;&lt;&nbsp;endl;Console.WriteLine(&quot;点个在看吧！&quot;);Response.Write(&quot;点个在看吧！&quot;);alert(&quot;点个在看吧！&quot;)echo &quot;点个在看吧！&quot; 你点的每个“在看”，我都认真当成了喜欢","@type":"BlogPosting","url":"https://mlh.app/2019/05/06/729704.html","headline":"两万字深入解密 Go 语言接口的那些事儿   技术头条","dateModified":"2019-05-06T00:00:00+08:00","datePublished":"2019-05-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/05/06/729704.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>两万字深入解密&nbsp;Go&nbsp;语言接口的那些事儿&nbsp;|&nbsp;技术头条</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.15644171779141106" data-src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujHRSdcX3IznHduusnhVrSgibxlHEaKkBO8A7UcDdDzAnMIA2ZLfuoUKKJrwSA8HPTejcSLotzprZw/640?wx_fmt=gif" data-type="gif" data-w="652" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujHRSdcX3IznHduusnhVrSgibxlHEaKkBO8A7UcDdDzAnMIA2ZLfuoUKKJrwSA8HPTejcSLotzprZw/640?wx_fmt=gif"></p> 
<blockquote class="js_blockquote_wrap" data-type="2" data-url="" data-author-name="" data-content-utf8-length="70" data-source-title=""> 
 <section class="js_blockquote_digest"> 
  <section>
    Go 语言的接口的原理是什么？是如何使用？它和C++接口有什么异同呢？本文作者用两万多字深入一一为你讲述Go语言interface的那些事儿。 
  </section> 
 </section> 
</blockquote> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><img class="rich_pages" data-copyright="0" data-ratio="0.5482233502538071" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuianaCAc0dX3TvVSHZSeE5zk1oRqiaREq46Snia7N1cGDGszaupnhS1GHica5lkMrXPoeTOAt2lRutvMw/640?wx_fmt=jpeg" data-type="jpeg" data-w="591" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuianaCAc0dX3TvVSHZSeE5zk1oRqiaREq46Snia7N1cGDGszaupnhS1GHica5lkMrXPoeTOAt2lRutvMw/640?wx_fmt=jpeg"><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;font-variant-numeric: normal;font-variant-east-asian: normal;white-space: normal;widows: 1;text-align: right;letter-spacing: 1px;line-height: normal;background-color: rgb(255, 255, 255);"><span style="color: rgb(136, 136, 136);font-size: 14px;">作者 |&nbsp;饶全成</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;font-variant-numeric: normal;font-variant-east-asian: normal;white-space: normal;widows: 1;text-align: right;letter-spacing: 1px;line-height: normal;background-color: rgb(255, 255, 255);"><span style="color: rgb(136, 136, 136);font-size: 14px;">责编 | 伍杏玲</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这篇文章的架构比较简单，直接抛出 10 个问题，一一解答。</span></p> 
<p><img class="" data-ratio="1.1538461538461537" data-src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61tJTdWgO8Ngw5GcTPY5UOh4u0DOHJKHxWOuaIPIVwmbQQPldwHgCWUM1Yr5ZnAblwNCYibgEDgT0Q/640?wx_fmt=png" data-type="png" data-w="520" style="margin: 20px auto;line-height: 1.5;border-radius: 4px;display: block;width: 99%;box-shadow: rgb(170, 170, 170) 0em 0em 1em 0px;height: auto !important;" title="null" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61tJTdWgO8Ngw5GcTPY5UOh4u0DOHJKHxWOuaIPIVwmbQQPldwHgCWUM1Yr5ZnAblwNCYibgEDgT0Q/640?wx_fmt=png"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><br></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LXSAriayI15u06ibNNlXzIcor2tTtgJBKFxkIicJ8tiaRKRaictbrQEssdSg/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong>Go 语言与鸭子类型的关系</strong></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">先直接来看维基百科里的定义：</span></p> 
<blockquote> 
 <p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</span></p> 
</blockquote> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">Duck Typing，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">例如，在动态语言 Python 中，定义一个这样的函数：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">def</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">hello_world</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(coder)</span>:</span>&nbsp;</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">coder.say_hello()</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">当调用此函数的时候，可以传入任意类型，只要它实现了 say_hello() 函数就可以。如果没有实现，运行过程中会出现错误。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">而在静态语言如 Java、C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用 hello_world 函数，却传入了一个根本就没有实现 say_hello() 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。插一句，这也是我不喜欢用 Python 的一个原因。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写Python 的同学比较清楚。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">来看个例子：</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">先定义一个接口，和使用此接口作为参数的函数：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;IGreeting&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;{&nbsp;</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">sayHello()</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">}</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="color: rgb(248, 35, 117);font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><br></span></p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">sayHello</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(i&nbsp;IGreeting)</span></span>&nbsp;{&nbsp;</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">i.sayHello()</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">}</p></pre> 
</section> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">‍再来定义两个结构体：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Go&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{}</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(g&nbsp;Go)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">sayHello</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{&nbsp;</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">      fmt.Println(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Hi,&nbsp;I&nbsp;am&nbsp;GO!"</span>)</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">}</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;PHP&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{}</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;PHP)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">sayHello</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{&nbsp;</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">      fmt.Println(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Hi,&nbsp;I&nbsp;am&nbsp;PHP!"</span>)</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">}</code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">最后，在 main 函数里调用 sayHello() 函数：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{&nbsp;</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">     golang&nbsp;:=&nbsp;Go{}&nbsp;</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">     php&nbsp;:=&nbsp;PHP{}&nbsp;</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">     sayHello(golang)&nbsp;</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">     sayHello(php)</code><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">}</code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">程序输出：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">Hi,&nbsp;I&nbsp;am&nbsp;GO!</code><code class="hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">Hi,&nbsp;I&nbsp;am&nbsp;PHP!</code></pre> 
</section> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">在 main 函数中，调用调用 sayHello() 函数时，传入了 golang、 php 对象，它们并没有显式地声明实现了 IGreeting 类型，只是实现了接口所规定的 sayHello() 函数。实际上，编译器在调用 sayHello() 函数时，会隐式地将 golang、php 对象转换成 IGreeting 类型，这也是静态语言的类型检查功能。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">顺带再提一下动态语言的特点：</span></p> 
<blockquote> 
 <p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">变量绑定的类型是不确定的，在运行期间才能确定 函数和方法可以接收任何类型的参数，且调用时不检查参数类型 不需要实现接口</span></p> 
</blockquote> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它"当前方法和属性的集合"决定。Go 作为一种静态语言，通过接口实现了 鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;"> 
  <mpcpc js_editor_cpcad="" class="js_cpc_area res_iframe cpc_iframe" src="/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1556933123316" data-category_id_list="1|15|16|17|36|37|41|42|43|48|7|8" data-id="1556933123316"></mpcpc></span></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LwYnW1VvkaHWiaL6W1Mr1yiaNLQpxwhyqice9F1yJzMHticssPX515qyvog/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong>值接收者和指针接收者的区别</strong></span></h2> 
<p><strong><span style="font-size: 15px;"><br></span></strong></p> 
<h2 style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">方法</span></strong></h2> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">来看个例子：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Person&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Person)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">howOld</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">int</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;p.age<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;*Person)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">growUp</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;qcrao&nbsp;是值类型</span><br>&nbsp;&nbsp;&nbsp;&nbsp;qcrao&nbsp;:=&nbsp;Person{age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">18</span>}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;值类型&nbsp;调用接收者也是值类型的方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao.howOld())<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;值类型&nbsp;调用接收者是指针类型的方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;qcrao.growUp()<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao.howOld())<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;----------------------</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;stefno&nbsp;是指针类型</span><br>&nbsp;&nbsp;&nbsp;&nbsp;stefno&nbsp;:=&nbsp;&amp;Person{age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">100</span>}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;指针类型&nbsp;调用接收者是值类型的方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno.howOld())<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;指针类型&nbsp;调用接收者也是指针类型的方法</span><br>&nbsp;&nbsp;&nbsp;&nbsp;stefno.growUp()<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno.howOld())<br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">上例子的输出结果是：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">18</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">19</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">100</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">101</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">调用了 growUp 函数后，不管调用者是值类型还是指针类型，它的 Age 值都改变了。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：</span></p> 
<table> 
 <thead style="box-sizing: border-box;line-height: 1.5;background: rgba(0, 0, 0, 0.05);"> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">-</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">值接收者</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">指针接收者</span></p></td> 
  </tr> 
 </thead> 
 <tbody style="box-sizing: border-box;"> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">值类型调用者</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">方法会使用调用者的一个副本，类似于“传值”</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">使用值的引用来调用方法，上例中，qcrao.growUp()&nbsp;实际上是&nbsp;(&amp;qcrao).growUp()</span></p></td> 
  </tr> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">指针类型调用者</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">指针被解引用为值，上例中，stefno.howOld()&nbsp;实际上是&nbsp;(*stefno).howOld()</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</span></p></td> 
  </tr> 
 </tbody> 
</table> 
<h2 style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><strong><span style="font-size: 15px;">值接收者和指针接收者</span></strong></h2> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">先说结论：实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法；而实现了接收者是指针类型的方法，不会自动生成对应接收者是值类型的方法。</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">来看一个例子，就会完全明白：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;coder&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;code()<br>&nbsp;&nbsp;&nbsp;&nbsp;debug()<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Gopher&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">string</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Gopher)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">code</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"I&nbsp;am&nbsp;coding&nbsp;%s&nbsp;language\n"</span>,&nbsp;p.language)<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;*Gopher)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">debug</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"I&nbsp;am&nbsp;debuging&nbsp;%s&nbsp;language\n"</span>,&nbsp;p.language)<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;c&nbsp;coder&nbsp;=&nbsp;&amp;Gopher{<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Go"</span>}<br>&nbsp;&nbsp;&nbsp;&nbsp;c.code()<br>&nbsp;&nbsp;&nbsp;&nbsp;c.debug()<br>}</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">上述代码里定义了一个接口 coder，接口定义了两个函数：</span><span style="font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace;font-size: 14px;text-align: left;white-space: pre;background-color: rgba(0, 0, 0, 0.03);">code()、debug()。</span><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">接着定义了一个结构体 Gopher，它实现了两个方法，一个值接收者，一个指针接收者。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">最后，我们在 main 函数里通过接口类型的变量调用了定义的两个函数。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">运行一下，结果：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-attribute" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">I</span>&nbsp;am&nbsp;coding&nbsp;Go&nbsp;language<br>I&nbsp;am&nbsp;debuging&nbsp;Go&nbsp;language</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">但是如果我们把 main 函数的第一条语句换一下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;c&nbsp;coder&nbsp;=&nbsp;Gopher{<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Go"</span>}<br>&nbsp;&nbsp;&nbsp;&nbsp;c.code()<br>&nbsp;&nbsp;&nbsp;&nbsp;c.debug()<br>}</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">运行一下，报错：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">./main.go:24:6:&nbsp;cannot&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">use</span>&nbsp;Programmer&nbsp;literal&nbsp;(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Programmer)&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">as</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;coder&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">in</span>&nbsp;assignment:&nbsp;Programmer&nbsp;does&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">not</span>&nbsp;implement&nbsp;coder&nbsp;(debug&nbsp;method&nbsp;has&nbsp;pointer&nbsp;receiver)</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">看出这两处代码的差别了吗？第一次是将 &amp;Gopher 赋给了 coder；第二次则是将 Gopher 赋给了 coder。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">第二次报错是说，Gopher 没有实现 coder。很明显了吧，因为 Gopher 类型并没有实现 debug 方法；表面上看， *Gopher 类型也没有实现 code 方法，但是因为 Gopher 类型实现了 code 方法，所以让 *Gopher 类型自动拥有了 code 方法。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">当然，上面的说法有一个简单的解释：接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者；而对于接收者是值类型的方法，在方法中不会对接收者本身产生影响。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">最后，只要记住下面这点就可以了：</span></p> 
<blockquote> 
 <p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</span></p> 
</blockquote> 
<h2 style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><strong><span style="font-size: 15px;">两者分别在何时使用</span></strong></h2> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">使用指针作为方法的接收者的理由：</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">•方法能够修改接收者指向的值。</span></strong></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">•避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效</span></strong><span style="font-size: 15px;">。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><br></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lb4ybNEVGnaAvEDwENKzW27LUKFDGZPKcBneWwTaTpaJyG2C3em7libQ/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;"><strong><span style="letter-spacing: 1px;font-size: 18px;">iface 和 eface 的区别是什么</span></strong></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{}。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">从源码层面看一下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;iface&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;&nbsp;*itab<br>&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;unsafe.Pointer<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;itab&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;&nbsp;*interfacetype<br>&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;*_type<br>&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;&nbsp;&nbsp;*itab<br>&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint32</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;copy&nbsp;of&nbsp;_type.hash.&nbsp;Used&nbsp;for&nbsp;type&nbsp;switches.</span><br>&nbsp;&nbsp;&nbsp;&nbsp;bad&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">bool</span>&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;type&nbsp;does&nbsp;not&nbsp;implement&nbsp;interface</span><br>&nbsp;&nbsp;&nbsp;&nbsp;inhash&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">bool</span>&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;has&nbsp;this&nbsp;itab&nbsp;been&nbsp;added&nbsp;to&nbsp;hash?</span><br>&nbsp;&nbsp;&nbsp;&nbsp;unused&nbsp;[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">2</span>]<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">byte</span><br>&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>]<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;variable&nbsp;sized</span><br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">iface 内部维护两个指针，tab 指向一个 itab 实体， 它表示接口的类型以及赋给这个接口的实体类型。data 则指向接口具体的值，一般而言是一个指向堆内存的指针。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">再来仔细看一下 itab 结构体：_type 字段描述了实体的类型，包括内存对齐方式，大小等；inter 字段则描述了接口的类型。fun 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">另外，你可能会觉得奇怪，为什么 fun 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">再看一下 interfacetype 类型，它描述的是接口的类型：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">type&nbsp;interfacetype&nbsp;<span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{</span>&nbsp;</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">typ&nbsp;_type&nbsp;</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">pkgpath&nbsp;name&nbsp;</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">mhdr&nbsp;[]imethod</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">}</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">可以看到，它包装了 _type 类型，_type 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 mhdr 字段，表示接口所定义的函数列表， pkgpath 记录定义了接口的包名。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这里通过一张图来看下 iface 结构体的全貌：</span></p> 
<p><img class="" data-ratio="1.002212389380531" data-src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61tJTdWgO8Ngw5GcTPY5UOhJ9D0EyIib6mBLCUsy4vMBdXN0bAn6ibAbTUU5eLo7dyjhDh2EExARAJg/640?wx_fmt=png" data-type="png" data-w="904" style="margin: 20px auto;color: rgb(63, 63, 63);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;font-size: 16px;text-align: left;white-space: normal;line-height: 1.5;border-radius: 4px;display: block;width: 99%;height: auto !important;box-shadow: rgb(170, 170, 170) 0em 0em 1em 0px;" title="null" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61tJTdWgO8Ngw5GcTPY5UOhJ9D0EyIib6mBLCUsy4vMBdXN0bAn6ibAbTUU5eLo7dyjhDh2EExARAJg/640?wx_fmt=png"></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">接着来看一下 eface 的源码：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">type&nbsp;eface&nbsp;<span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{</span>&nbsp;</code><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">     _type&nbsp;*_type&nbsp;</code><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">     data&nbsp;unsafe.Pointer</code><code class="hljs cpp" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">}</code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">相比 iface，eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值。</span></p> 
<p><img class="" data-ratio="1.044776119402985" data-src="https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61tJTdWgO8Ngw5GcTPY5UOha5Am8RmXIaPoY24kicyjtLFZepMibYDjYvEm6yLoMx9EXw9CyFJWpVRA/640?wx_fmt=png" data-type="png" data-w="268" style="margin: 20px auto;color: rgb(63, 63, 63);font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;font-size: 16px;text-align: left;white-space: normal;line-height: 1.5;border-radius: 4px;display: block;width: 43%;box-shadow: rgb(170, 170, 170) 0em 0em 1em 0px;height: auto !important;" title="null" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/ASQrEXvmx61tJTdWgO8Ngw5GcTPY5UOha5Am8RmXIaPoY24kicyjtLFZepMibYDjYvEm6yLoMx9EXw9CyFJWpVRA/640?wx_fmt=png"></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">我们来看个例子：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">200</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;any&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>{}&nbsp;=&nbsp;x<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(any)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;:=&nbsp;Gopher{<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Go"</span>}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;c&nbsp;coder&nbsp;=&nbsp;g<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c)<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;coder&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;code()<br>&nbsp;&nbsp;&nbsp;&nbsp;debug()<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Gopher&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">string</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Gopher)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">code</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"I&nbsp;am&nbsp;coding&nbsp;%s&nbsp;language\n"</span>,&nbsp;p.language)<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Gopher)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">debug</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"I&nbsp;am&nbsp;debuging&nbsp;%s&nbsp;language\n"</span>,&nbsp;p.language)<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">执行命令，打印出汇编语言：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span><br></p></pre> 
</section> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">可以看到，main 函数里调用了两个函数：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">convT2E64</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(t&nbsp;*_type,&nbsp;elem&nbsp;unsafe.Pointer)</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(e&nbsp;eface)</span></span></p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">convT2I</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(i&nbsp;iface)</span></span></p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">上面两个函数的参数和 iface 及 eface 结构体的字段是可以联系起来的：两个函数都是将参数组装一下，形成最终的接口。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">作为补充，我们最后再来看下 _type 结构体：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;_type&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;类型大小</span><br>&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>&nbsp;&nbsp;&nbsp;&nbsp;ptrdata&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;类型的&nbsp;hash&nbsp;值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint32</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;类型的&nbsp;flag，和反射相关</span><br>&nbsp;&nbsp;&nbsp;&nbsp;tflag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tflag<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;内存对齐相关</span><br>&nbsp;&nbsp;&nbsp;&nbsp;align&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint8</span><br>&nbsp;&nbsp;&nbsp;&nbsp;fieldalign&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint8</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;类型的编号，有bool,&nbsp;slice,&nbsp;struct&nbsp;等等等等</span><br>&nbsp;&nbsp;&nbsp;&nbsp;kind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint8</span><br>&nbsp;&nbsp;&nbsp;&nbsp;alg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*typeAlg<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;gc&nbsp;相关</span><br>&nbsp;&nbsp;&nbsp;&nbsp;gcdata&nbsp;&nbsp;&nbsp;&nbsp;*<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">byte</span><br>&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nameOff<br>&nbsp;&nbsp;&nbsp;&nbsp;ptrToThis&nbsp;typeOff<br>}</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">Go 语言各种数据类型都是在 _type 字段的基础上，增加一些额外的字段来进行管理的：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;arraytype&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;&nbsp;_type<br>&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;&nbsp;*_type<br>&nbsp;&nbsp;&nbsp;&nbsp;slice&nbsp;*_type<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">len</span>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;chantype&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;_type<br>&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;*_type<br>&nbsp;&nbsp;&nbsp;&nbsp;dir&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;slicetype&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;_type<br>&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;*_type<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;structtype&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_type<br>&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;name<br>&nbsp;&nbsp;&nbsp;&nbsp;fields&nbsp;&nbsp;[]structfield<br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">这些数据类型的结构体定义，是反射实现的基础。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LLqyf6BY4rMfY2LsU81MibFjicKDLjMjib5R23h8uo6GtGDY8OufWJfpEw/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong>接口的动态类型和动态值</strong></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">从源码里可以看到：iface包含两个字段：tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">【引申1】接口类型和&nbsp;nil&nbsp;作比较</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">来看个例子：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Coder&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;code()<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Gopher&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">string</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(g&nbsp;Gopher)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">code</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%s&nbsp;is&nbsp;coding\n"</span>,&nbsp;g.name)<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;c&nbsp;Coder<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c&nbsp;==&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"c:&nbsp;%T,&nbsp;%v\n"</span>,&nbsp;c,&nbsp;c)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;g&nbsp;*Gopher<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(g&nbsp;==&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;g<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c&nbsp;==&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"c:&nbsp;%T,&nbsp;%v\n"</span>,&nbsp;c,&nbsp;c)<br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">输出：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">true</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">c:&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;</span>,&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;</span></p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">true</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">false</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">c:&nbsp;*main.Gopher,&nbsp;<span class="hljs-tag" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">&lt;<span class="hljs-name" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;</span></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">一开始，c 的 动态类型和动态值都为 nil，g 也为 nil，当把 g 赋值给 c 后，c 的动态类型变成了 *main.Gopher，仅管 c 的动态值仍为 nil，但是当 c 和 nil 作比较的时候，结果就是 false 了。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">【引申2】 来看一个例子，看一下它的输出：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;MyError&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(i&nbsp;MyError)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Error</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">string</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"MyError"</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;:=&nbsp;Process()<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err&nbsp;==&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>)<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Process</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">error</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;err&nbsp;*MyError&nbsp;=&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;err<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">函数运行结果：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs objectivec" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;</code><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">false</span></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">这里先定义了一个 MyError 结构体，实现了 Error 函数，也就实现了 error 接口。Process 函数返回了一个 error 接口，这块隐含了类型转换。所以，虽然它的值是 nil，其实它的类型是 *MyError，最后和 nil 比较的时候，结果为 false。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">【引申3】如何打印出接口的动态类型和值？</span></strong></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">直接看代码：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"unsafe"</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br>)<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;iface&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;itab,&nbsp;data&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;a&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>{}&nbsp;=&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;b&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>{}&nbsp;=&nbsp;(*<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>)(<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">5</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;c&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>{}&nbsp;=&nbsp;(*<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>)(&amp;x)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;ia&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;a))<br>&nbsp;&nbsp;&nbsp;&nbsp;ib&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;b))<br>&nbsp;&nbsp;&nbsp;&nbsp;ic&nbsp;:=&nbsp;*(*iface)(unsafe.Pointer(&amp;c))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ia,&nbsp;ib,&nbsp;ic)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(*(*<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>)(unsafe.Pointer(ic.data)))<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">代码里直接定义了一个 iface 结构体，用两个指针来描述 itab 和 data，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 iface。最后就可以打印出动态类型和动态值的地址。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">运行结果如下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">{0&nbsp;0}&nbsp;{17426912&nbsp;0}&nbsp;{17426912&nbsp;842350714568}</p><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">5</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 *int；最后，c 的动态值为 5。</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LzUzfol6q1COlZYpeYXqe0aia45DXyhcTQW8voWvibFJvEjfmkhPvCrEg/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong>编译器自动检测类型是否实现接口</strong></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">经常看到一些开源库里会有一些类似下面这种奇怪的用法：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">var&nbsp;_&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">io</span>.Writer&nbsp;=&nbsp;(*myWriter)(<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>)</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">来看一个例子：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"io"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;myWriter&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br><br>}<br><br><span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">/*func&nbsp;(w&nbsp;myWriter)&nbsp;Write(p&nbsp;[]byte)&nbsp;(n&nbsp;int,&nbsp;err&nbsp;error)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;return<br>}*/</span><br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;检查&nbsp;*myWriter&nbsp;类型是否实现了&nbsp;io.Writer&nbsp;接口</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;(*myWriter)(<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;检查&nbsp;myWriter&nbsp;类型是否实现了&nbsp;io.Writer&nbsp;接口</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;_&nbsp;io.Writer&nbsp;=&nbsp;myWriter{}<br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">注释掉为 myWriter 定义的 Write 函数后，运行程序：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">src/main.go:14:6:&nbsp;cannot&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">use</span>&nbsp;(*myWriter)(nil)&nbsp;(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;*myWriter)&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">as</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;io.Writer&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">in</span>&nbsp;assignment:<br>&nbsp;&nbsp;&nbsp;&nbsp;*myWriter&nbsp;does&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">not</span>&nbsp;implement&nbsp;io.Writer&nbsp;(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">missing</span>&nbsp;Write&nbsp;method)<br>src/main.go:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">15</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">6</span>:&nbsp;cannot&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">use</span>&nbsp;myWriter&nbsp;literal&nbsp;(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;myWriter)&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">as</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;io.Writer&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">in</span>&nbsp;assignment:<br>&nbsp;&nbsp;&nbsp;&nbsp;myWriter&nbsp;does&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">not</span>&nbsp;implement&nbsp;io.Writer&nbsp;(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">missing</span>&nbsp;Write&nbsp;method)</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">报错信息：*myWriter/myWriter 未实现 io.Writer 接口，也就是未实现 Write 方法。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">解除注释后，运行程序不报错。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs lua" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">var&nbsp;_&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">io</span>.Writer&nbsp;=&nbsp;(*myWriter)(<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>)</code><code class="hljs lua" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">var&nbsp;_&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">io</span>.Writer&nbsp;=&nbsp;myWriter{}<br></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;"></span><br></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L8DRknQu3FB9eZicibvOSlVrgnllB3XcGnsrw4zCk19ic0QjZkTPoqFMWw/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;"><strong><span style="letter-spacing: 1px;font-size: 18px;">接口的构造过程是怎样的</span></strong></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">我们已经看过了 iface 和 eface 的源码，知道 iface 最重要的是 itab 和 _type。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">来看一个示例代码：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Person&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;growUp()<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Student&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Student)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">growUp</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;qcrao&nbsp;=&nbsp;Person(Student{age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">18</span>})<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao)<br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">执行命令：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span></p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">得到 main 函数的汇编代码如下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0000</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00000</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;TEXT&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>.main(SB),&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">80-0</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0000</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00000</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;(TLS),&nbsp;CX<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0009</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00009</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;CMPQ&nbsp;&nbsp;&nbsp;&nbsp;SP,&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">16</span>(CX)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x000d</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00013</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;JLS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">157</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0013</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00019</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;SUBQ&nbsp;&nbsp;&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">80</span>,&nbsp;SP<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0017</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00023</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;BP,&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">72</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x001c</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00028</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">72</span>(SP),&nbsp;BP<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0021</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00033</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;FUNCDATA$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;gclocals·<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">69</span>c1753bd5f81501d95132d08af04464(SB)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0021</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00033</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;FUNCDATA$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>,&nbsp;gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0021</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00033</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">18</span>,&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>..autotmp_1+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">48</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x002a</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00042</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>.itab.<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>.Student,<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>.Person(SB),&nbsp;AX<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0031</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00049</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0035</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00053</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>..autotmp_1+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">48</span>(SP),&nbsp;AX<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x003a</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00058</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">8</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x003f</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00063</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;PCDATA&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x003f</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00063</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;runtime.convT2I64(SB)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0044</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00068</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">24</span>(SP),&nbsp;AX<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0049</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00073</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">31</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">16</span>(SP),&nbsp;CX<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x004e</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00078</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;TESTQ&nbsp;&nbsp;&nbsp;CX,&nbsp;CX<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0051</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00081</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;JEQ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">87</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0053</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00083</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">8</span>(CX),&nbsp;CX<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0057</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00087</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>..autotmp_2+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">56</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0060</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00096</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>..autotmp_2+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">64</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0069</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00105</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;CX,&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>..autotmp_2+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">56</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x006e</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00110</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>..autotmp_2+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">64</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0073</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00115</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;LEAQ&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>..autotmp_2+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">56</span>(SP),&nbsp;AX<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0078</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00120</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;AX,&nbsp;(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x007c</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00124</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>,&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">8</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0085</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00133</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>,&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">16</span>(SP)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x008e</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00142</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;PCDATA&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x008e</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00142</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">33</span>)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(SB)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0093</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00147</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">34</span>)&nbsp;MOVQ&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">72</span>(SP),&nbsp;BP<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0098</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00152</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">34</span>)&nbsp;ADDQ&nbsp;&nbsp;&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">80</span>,&nbsp;SP<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x009c</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00156</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">34</span>)&nbsp;RET<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x009d</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00157</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">34</span>)&nbsp;NOP<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x009d</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00157</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;PCDATA&nbsp;&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;$<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">-1</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x009d</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00157</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;CALL&nbsp;&nbsp;&nbsp;&nbsp;runtime.morestack_noctxt(SB)<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x00a2</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00162</span>&nbsp;(./src/main.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>:<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">30</span>)&nbsp;JMP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span><br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。</span></p> 
<table> 
 <thead style="box-sizing: border-box;line-height: 1.5;background: rgba(0, 0, 0, 0.05);"> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="119"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">汇编行数</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="371"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">操作</span></p></td> 
  </tr> 
 </thead> 
 <tbody style="box-sizing: border-box;"> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="79"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">10-14</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="375"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">构造调用&nbsp;runtime.convT2I64(SB)&nbsp;的参数</span></p></td> 
  </tr> 
 </tbody> 
</table> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">我们来看下这个函数的参数形式：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs go" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">convT2I64</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(i&nbsp;iface)</span></span>&nbsp;{&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;……}</span><br></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"></span><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">convT2I64 会构造出一个 inteface，也就是我们的 Person 接口。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">第一个参数的位置是 (SP)，这里被赋上了 go.itab."".Student,"".Person(SB) 的地址。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">我们从生成的汇编找到：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">go</span>.itab.<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>.Student,<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>.Person&nbsp;SNOPTRDATA&nbsp;dupok&nbsp;size=<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">40</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0000</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0x0010</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">00</span>&nbsp;da&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">9f</span>&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">20</span>&nbsp;d4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">8</span>&nbsp;t=<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>.<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>.Person+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rel&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">8</span>+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">8</span>&nbsp;t=<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>.<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>.Student+<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span><br></p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">size=40 大小为40字节，回顾一下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;itab&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;&nbsp;*interfacetype&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;8字节</span><br>&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;&nbsp;*_type&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;8字节</span><br>&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;&nbsp;&nbsp;*itab&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;8字节</span><br>&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint32</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;4字节</span><br>&nbsp;&nbsp;&nbsp;&nbsp;bad&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">bool</span>&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;1字节</span><br>&nbsp;&nbsp;&nbsp;&nbsp;inhash&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">bool</span>&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;1字节</span><br>&nbsp;&nbsp;&nbsp;&nbsp;unused&nbsp;[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">2</span>]<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">byte</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;2字节</span><br>&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>]<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;variable&nbsp;sized&nbsp;//&nbsp;8字节</span><br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">把每个字段的大小相加，itab 结构体的大小就是 40 字节。上面那一串数字实际上是 itab 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 da 9f 20 d4 实际上是 itab 的 hash 值，这在判断两个类型是否相同的时候会用到。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 type."".Person 的地址，对应 itab 里的 inter 字段，表示接口类型；8-16 字节最终存储的是 type."".Student 的地址，对应 itab 里 _type 字段，表示具体类型。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">第二个参数就比较简单了，它就是数字 18 的地址，这也是初始化 Student 结构体的时候会用到。</span></p> 
<table> 
 <thead style="box-sizing: border-box;line-height: 1.5;background: rgba(0, 0, 0, 0.05);"> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="119"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">汇编行数</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="369"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">操作</span></p></td> 
  </tr> 
 </thead> 
 <tbody style="box-sizing: border-box;"> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="71"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">15</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="369"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">调用&nbsp;runtime.convT2I64(SB)</span></p></td> 
  </tr> 
 </tbody> 
</table> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">具体看下代码：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">convT2I64</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(tab&nbsp;*itab,&nbsp;elem&nbsp;unsafe.Pointer)</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(i&nbsp;iface)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;tab._type<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//...</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;x&nbsp;unsafe.Pointer<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;*(*<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint64</span>)(elem)&nbsp;==&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;unsafe.Pointer(&amp;zeroVal[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>])<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;mallocgc(<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">8</span>,&nbsp;t,&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">false</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(*<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint64</span>)(x)&nbsp;=&nbsp;*(*<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint64</span>)(elem)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;i.tab&nbsp;=&nbsp;tab<br>&nbsp;&nbsp;&nbsp;&nbsp;i.data&nbsp;=&nbsp;x<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">‍这块代码比较简单，把 tab 赋给了 iface 的 tab 字段；data 部分则是在堆上申请了一块内存，然后将 elem 指向的 18 拷贝过去。这样 iface 就组装好了。</span></p> 
<table> 
 <thead style="box-sizing: border-box;line-height: 1.5;background: rgba(0, 0, 0, 0.05);"> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="127"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">汇编行数</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="388"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">操作</span></p></td> 
  </tr> 
 </thead> 
 <tbody style="box-sizing: border-box;"> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="122"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">17</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="388"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">把&nbsp;i.tab&nbsp;赋给&nbsp;CX</span></p></td> 
  </tr> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="122"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">18</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="388"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">把&nbsp;i.data&nbsp;赋给&nbsp;AX</span></p></td> 
  </tr> 
  <tr style="box-sizing: border-box;"> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="122"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">19-21</span></p></td> 
   <td style="box-sizing: border-box;padding: 4px 8px;line-height: 1.5;font-size: 12.8px;border-color: rgb(223, 223, 223);" width="388"><p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">检测&nbsp;i.tab&nbsp;是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把&nbsp;itab&nbsp;的&nbsp;_type&nbsp;字段赋给了 CX，这也是接口的实体类型，最终要作为&nbsp;fmt.Println&nbsp;函数的参数</span></p></td> 
  </tr> 
 </tbody> 
</table> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">后面，就是调用 fmt.Println 函数及之前的参数准备工作了，不再赘述。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这样，我们就把一个 interface 的构造过程说完了。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">【引申1】 如何打印出接口类型的 Hash 值？</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;iface&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;&nbsp;*itab<br>&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;unsafe.Pointer<br>}<br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;itab&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>&nbsp;&nbsp;&nbsp;&nbsp;_type&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>&nbsp;&nbsp;&nbsp;&nbsp;hash&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uint32</span><br>&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">4</span>]<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">byte</span><br>&nbsp;&nbsp;&nbsp;&nbsp;fun&nbsp;&nbsp;&nbsp;[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>]<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;qcrao&nbsp;=&nbsp;Person(Student{age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">18</span>})<br><br>&nbsp;&nbsp;&nbsp;&nbsp;iface&nbsp;:=&nbsp;(*iface)(unsafe.Pointer(&amp;qcrao))<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"iface.tab.hash&nbsp;=&nbsp;%#x\n"</span>,&nbsp;iface.tab.hash)<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">‍了一个山寨版的 iface 和 itab，说它山寨是因为 itab 里的一些关键数据结构都不具体展开了，比如 _type，对比一下正宗的定义就可以发现，但是山寨版依然能工作，因为 _type 就是一个指针而已嘛。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">在 main 函数里，先构造出一个接口对象 qcrao，然后强制类型转换，最后读取出 hash 值，非常妙！你也可以自己动手试一下。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">运行结果：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">iface.tab.hash&nbsp;=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xd4209fd</span>a</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">值得一提的是，构造接口 qcrao 的时候，即使我把 age 写成其他值，得到的 hash 值依然不变的，这应该是可以预料的，hash 值只和他的字段、方法相关。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LFV97HltQYlNPKDzX97K1Ll0EicLrBIuWQtgLtQYdFKkkLcWKGUeMTfg/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong>类型转换和断言的区别</strong></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">我们知道，Go 语言中不允许隐式类型转换，也就是说 = 两边，不允许出现类型不相同的变量。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。</span></p> 
<h2 style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><strong><span style="font-size: 15px;">类型转换</span></strong></h2> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">对于类型转换而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</span></p> 
<blockquote> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">&lt;结果类型&gt; := &lt;目标类型&gt; (&lt;表达式&gt;)</span></p> 
</blockquote> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;">
          
  <section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">
           
   <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;i&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>&nbsp;=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">9</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;f&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">float64</span><br>&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">float64</span>(i)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%T,&nbsp;%v\n"</span>,&nbsp;f,&nbsp;f)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">10.8</span><br>&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;:=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>(f)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%T,&nbsp;%v\n"</span>,&nbsp;a,&nbsp;a)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;s&nbsp;:=&nbsp;[]int(i)</span></p></pre>
          
  </section></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">上面的代码里，我定义了一个 int 型和 float64 型的变量，尝试在它们之前相互转换，结果是成功的：int 型和 float64 是相互兼容的。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">cannot&nbsp;convert&nbsp;i&nbsp;(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>)&nbsp;to&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;[]<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span></p></pre> 
</section> 
<h2 style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><strong><span style="font-size: 15px;">‍断言</span></strong></h2> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">前面说过，因为空接口 interface{} 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">断言的语法为：</span></p> 
<blockquote> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">&nbsp;// 安全类型断言</span></p> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 )&nbsp;&nbsp;</span></p> 
 <p><br></p> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">//非安全类型断言</span></p> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )</span></p> 
</blockquote> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">类型转换和类型断言有些相似，不同之处，在于类型断言是对接口进行的操作。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">还是来看一个简短的例子：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;">
          
  <section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">
           
   <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Student&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">string</span><br>&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;i&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>{}&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">new</span>(Student)<br>&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;i.(Student)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)<br>}</p></pre>
          
  </section></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">‍运行一下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">panic:&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;conversion:&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">{}</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">is</span>&nbsp;*main.Student,&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">not</span>&nbsp;main.Student</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">‍直接 panic 了，这是因为 i 是 *Student 类型，并非 Student 类型，断言失败。这里直接发生了 panic，线上代码可能并不适合这样做，可以采用“安全断言”的语法：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;">
          
  <section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;">
           
   <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;i&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>{}&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">new</span>(Student)<br>&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;ok&nbsp;:=&nbsp;i.(Student)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;ok&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p></pre>
          
  </section></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">这样，即使断言失败也不会 panic。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">断言其实还有另一种形式，就是用在利用 switch 语句判断接口的类型。每一个 case 会被顺序地考虑。当命中一个 case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case 匹配的情况。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">代码示例如下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;i&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>{}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%p&nbsp;%v\n"</span>,&nbsp;&amp;i,&nbsp;i)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;judge(i)<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">judge</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(v&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>{})</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%p&nbsp;%v\n"</span>,&nbsp;&amp;v,&nbsp;v)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">switch</span>&nbsp;v&nbsp;:=&nbsp;v.(<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">case</span>&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%p&nbsp;%v\n"</span>,&nbsp;&amp;v,&nbsp;v)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"nil&nbsp;type[%T]&nbsp;%v\n"</span>,&nbsp;v,&nbsp;v)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">case</span>&nbsp;Student:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%p&nbsp;%v\n"</span>,&nbsp;&amp;v,&nbsp;v)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"Student&nbsp;type[%T]&nbsp;%v\n"</span>,&nbsp;v,&nbsp;v)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">case</span>&nbsp;*Student:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%p&nbsp;%v\n"</span>,&nbsp;&amp;v,&nbsp;v)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"*Student&nbsp;type[%T]&nbsp;%v\n"</span>,&nbsp;v,&nbsp;v)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">default</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"%p&nbsp;%v\n"</span>,&nbsp;&amp;v,&nbsp;v)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"unknow\n"</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Student&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">string</span><br>&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span><br>}</p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">main 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;new(Student)</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc4200701b0</span>&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>]<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc4200701d</span>0&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>]<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc420080020</span>&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>]<br>*Student&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>[*main.Student]&nbsp;[Name:&nbsp;],&nbsp;[Age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>]<br><br><span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}&nbsp;=&nbsp;(*Student)(nil)</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc42000e1d</span>0&nbsp;&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc42000e1f</span>0&nbsp;&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc42000c030</span>&nbsp;&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;<br>*Student&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>[*main.Student]&nbsp;&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;<br><br><span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;---&nbsp;var&nbsp;i&nbsp;interface{}</span><br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc42000e1d</span>0&nbsp;&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc42000e1e0</span>&nbsp;&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;<br><span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0xc42000e1f</span>0&nbsp;&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;<br><span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>[&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;]&nbsp;&lt;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&gt;</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">对于第一行语句：</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="golang"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">var</span>&nbsp;i&nbsp;<span class="code-snippet__keyword">interface</span>{}&nbsp;=&nbsp;<span class="code-snippet__built_in">new</span>(Student)</span></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">‍i 是一个 *Student 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 main 函数里有一个局部变量 i；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 v，它是 i 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">对于第二行语句：</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="golang"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">var</span>&nbsp;i&nbsp;<span class="code-snippet__keyword">interface</span>{}&nbsp;=&nbsp;(*Student)(<span class="code-snippet__literal">nil</span>)</span></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">‍这里想说明的其实是 i 在这里动态类型是 (*Student), 数据为 nil，它的类型并不是 nil，它与 nil 作比较的时候，得到的结果也是 false。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">最后一行语句：</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="cs"><code><span class="code-snippet_outer"><span class="code-snippet__keyword">var</span>&nbsp;i&nbsp;<span class="code-snippet__keyword">interface</span>{}</span></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这回 i 才是 nil 类型。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">【引申1】 fmt.Println 函数的参数是 interface。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印。而对于自定义类型，首先确定该类型是否实现了 String() 方法，如果实现了，则直接打印输出 String() 方法的结果；否则，会通过反射来遍历对象的成员进行打印。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">再来看一个简短的例子，比较简单，不要紧张：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Student&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;Name&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">string</span><br>&nbsp;&nbsp;&nbsp;&nbsp;Age&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;s&nbsp;=&nbsp;Student{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name:&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"qcrao"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">18</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s)<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">‍因为 Student 结构体没有实现 String() 方法，所以 fmt.Println 会利用反射挨个打印成员变量：</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="shell"><code><span class="code-snippet_outer">{qcrao&nbsp;18}</span></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">‍增加一个 String() 方法的实现：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(s&nbsp;Student)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">String</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">string</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;fmt.Sprintf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"[Name:&nbsp;%s],&nbsp;[Age:&nbsp;%d]"</span>,&nbsp;s.Name,&nbsp;s.Age)<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">打印结果：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-selector-attr" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[Name:&nbsp;qcrao]</span>,&nbsp;<span class="hljs-selector-attr" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">[Age:&nbsp;18]</span></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">‍按照我们自定义的方法来打印了。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 0px;margin-right: 0px;"><span style="font-size: 15px;">【引申2】 针对上面的例子，如果改一下：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 0px;margin-right: 0px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(s&nbsp;*Student)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">String</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">string</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;fmt.Sprintf(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"[Name:&nbsp;%s],&nbsp;[Age:&nbsp;%d]"</span>,&nbsp;s.Name,&nbsp;s.Age)<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">注意看两个函数的接受者类型不同，现在 Student 结构体只有一个接受者类型为 指针类型 的 String() 函数，打印结果：</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="shell"><code><span class="code-snippet_outer">{qcrao&nbsp;18}</span></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">‍为什么？</span></p> 
<blockquote> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">类型 T 只有接受者是 T 的方法；而类型 *T 拥有接受者是 T 和 *T 的方法。语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖。</span></p> 
</blockquote> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">所以，&nbsp;Student&nbsp;结构体定义了接受者类型是值类型的&nbsp;String()&nbsp;方法时，通过</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="golang"><code><span class="code-snippet_outer">fmt.Println(s)fmt.Println(&amp;s)</span></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">均可以按照自定义的格式来打印。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">如果&nbsp;Student&nbsp;结构体定义了接受者类型是指针类型的&nbsp;String()&nbsp;方法时，只有通过</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="golang"><code><span class="code-snippet_outer">fmt.Println(&amp;s)</span></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">才能按照自定义的格式打印。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4Lf6AGBpotDb1DGltQgly1vKzgCCOtT3OQn43luu8r1JxUV1PmiaSAViaw/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;font-size: 18px;"><strong>接口转换的原理</strong></span></h2> 
<p style="text-align: center;margin-bottom: 15px;"><br></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">通过前面提到的 iface 的源码可以看到，实际上它包含接口的类型 interfacetype 和 实体类型的类型 _type，这两者都是 iface 的字段 itab 的成员。也就是说生成一个 itab 同时需要接口的类型和实体的类型。</span></p> 
<blockquote> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">&lt;interface 类型， 实体类型&gt; -&gt;itable</span></p> 
</blockquote> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">当判定一种类型是否满足某个接口时，Go 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">例如某类型有 m 个方法，某接口有 n 个方法，则很容易知道这种判定的时间复杂度为 O(mn)，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 O(m+n)。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">直接来看一个例子：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;coder&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;code()<br>&nbsp;&nbsp;&nbsp;&nbsp;run()<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;runner&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;run()<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Gopher&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">string</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(g&nbsp;Gopher)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">code</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(g&nbsp;Gopher)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">run</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;c&nbsp;coder&nbsp;=&nbsp;Gopher{}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;r&nbsp;runner<br>&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;c<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c,&nbsp;r)<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">简单解释下上述代码：定义了两个 interface: coder 和 runner。定义了一个实体类型 Gopher，类型 Gopher 实现了两个方法，分别是 run() 和 code()。main 函数里定义了一个接口变量 c，绑定了一个 Gopher 对象，之后将 c 赋值给另外一个接口变量 r 。赋值成功的原因是 c 中包含 run() 方法。这样，两个接口变量完成了转换。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">执行命令：</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="shell"><code><span class="code-snippet_outer">go&nbsp;tool&nbsp;compile&nbsp;-S&nbsp;./src/main.go</span></code></pre> 
</section> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">‍得到 main 函数的汇编命令，可以看到：r = c 这一行语句实际上是调用了 runtime.convI2I(SB)，也就是 convI2I 函数，从函数名来看，就是将一个 interface 转换成另外一个 interface，看下它的源代码：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">func&nbsp;convI2I(inter&nbsp;*interfacetype,&nbsp;i&nbsp;iface)&nbsp;(r&nbsp;iface)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;:=&nbsp;i.tab<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;tab&nbsp;==&nbsp;nil&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;tab.inter&nbsp;==&nbsp;inter&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.tab&nbsp;=&nbsp;tab<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">data</span>&nbsp;=&nbsp;i.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">data</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;r.tab&nbsp;=&nbsp;getitab(inter,&nbsp;tab._type,&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">false</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;r.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">data</span>&nbsp;=&nbsp;i.<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">data</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">代码比较简单，函数参数 inter 表示接口类型，i 表示绑定了实体类型的接口，r 则表示接口转换了之后的新的 iface。通过前面的分析，我们又知道， iface 是由 tab 和 data 两个字段组成。所以，实际上 convI2I 函数真正要做的事，找到新 interface 的 tab 和 data，就大功告成了。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">我们还知道，tab 是由接口类型 interfacetype 和 实体类型 _type。所以最关键的语句是 r.tab = getitab(inter, tab._type, false)。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">因此，重点来看下 getitab 函数的源码，只看关键的地方：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">getitab</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(inter&nbsp;*interfacetype,&nbsp;typ&nbsp;*_type,&nbsp;canfail&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">bool</span>)</span>&nbsp;*<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">itab</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;……</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;根据&nbsp;inter,&nbsp;typ&nbsp;计算出&nbsp;hash&nbsp;值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;itabhash(inter,&nbsp;typ)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;look&nbsp;twice&nbsp;-&nbsp;once&nbsp;without&nbsp;lock,&nbsp;once&nbsp;with.</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;common&nbsp;case&nbsp;will&nbsp;be&nbsp;no&nbsp;lock&nbsp;contention.</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;m&nbsp;*itab<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">var</span>&nbsp;locked&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;locked&nbsp;=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;&nbsp;locked&nbsp;&lt;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">2</span>;&nbsp;locked++&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;locked&nbsp;!=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock(&amp;ifaceLock)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;遍历哈希表的一个&nbsp;slot</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;m&nbsp;=&nbsp;(*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h])));&nbsp;m&nbsp;!=&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>;&nbsp;m&nbsp;=&nbsp;m.link&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;如果在&nbsp;hash&nbsp;表中已经找到了&nbsp;itab（inter&nbsp;和&nbsp;typ&nbsp;指针都相同）</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;m.inter&nbsp;==&nbsp;inter&nbsp;&amp;&amp;&nbsp;m._type&nbsp;==&nbsp;typ&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;……</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;locked&nbsp;!=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlock(&amp;ifaceLock)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;m<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;在&nbsp;hash&nbsp;表中没有找到&nbsp;itab，那么新生成一个&nbsp;itab</span><br>&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;(*itab)(persistentalloc(unsafe.Sizeof(itab{})+<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span>(<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">len</span>(inter.mhdr)<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">-1</span>)*sys.PtrSize,&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>,&nbsp;&amp;memstats.other_sys))<br>&nbsp;&nbsp;&nbsp;&nbsp;m.inter&nbsp;=&nbsp;inter<br>&nbsp;&nbsp;&nbsp;&nbsp;m._type&nbsp;=&nbsp;typ<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;添加到全局的&nbsp;hash&nbsp;表中</span><br>&nbsp;&nbsp;&nbsp;&nbsp;additab(m,&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">true</span>,&nbsp;canfail)<br>&nbsp;&nbsp;&nbsp;&nbsp;unlock(&amp;ifaceLock)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;m.bad&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;m<br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">简单总结一下：getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 interfacetype 和 _type 新生成一个 itab，并插入到 itab 哈希表，这样下一次就可以直接拿到 itab。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 itab 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 itab 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 itab。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">再来看一下 additab 函数的代码：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;检查&nbsp;_type&nbsp;是否符合&nbsp;interface_type&nbsp;并且创建对应的&nbsp;itab&nbsp;结构体&nbsp;将其放到&nbsp;hash&nbsp;表中</span><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">additab</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(m&nbsp;*itab,&nbsp;locked,&nbsp;canfail&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">bool</span>)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;inter&nbsp;:=&nbsp;m.inter<br>&nbsp;&nbsp;&nbsp;&nbsp;typ&nbsp;:=&nbsp;m._type<br>&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;:=&nbsp;typ.uncommon()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;both&nbsp;inter&nbsp;and&nbsp;typ&nbsp;have&nbsp;method&nbsp;sorted&nbsp;by&nbsp;name,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;and&nbsp;interface&nbsp;names&nbsp;are&nbsp;unique,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;so&nbsp;can&nbsp;iterate&nbsp;over&nbsp;both&nbsp;in&nbsp;lock&nbsp;step;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;the&nbsp;loop&nbsp;is&nbsp;O(ni+nt)&nbsp;not&nbsp;O(ni*nt).</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;inter&nbsp;和&nbsp;typ&nbsp;的方法都按方法名称进行了排序</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;并且方法名都是唯一的。所以循环的次数是固定的</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;只用循环&nbsp;O(ni+nt)，而非&nbsp;O(ni*nt)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;ni&nbsp;:=&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">len</span>(inter.mhdr)<br>&nbsp;&nbsp;&nbsp;&nbsp;nt&nbsp;:=&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span>(x.mcount)<br>&nbsp;&nbsp;&nbsp;&nbsp;xmhdr&nbsp;:=&nbsp;(*[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span>&nbsp;&lt;&lt;&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">16</span>]method)(add(unsafe.Pointer(x),&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span>(x.moff)))[:nt:nt]<br>&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;:=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;k&nbsp;:=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;&nbsp;k&nbsp;&lt;&nbsp;ni;&nbsp;k++&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;:=&nbsp;&amp;inter.mhdr[k]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itype&nbsp;:=&nbsp;inter.typ.typeOff(i.ityp)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;:=&nbsp;inter.typ.nameOff(i.name)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iname&nbsp;:=&nbsp;name.name()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipkg&nbsp;:=&nbsp;name.pkgPath()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;ipkg&nbsp;==&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipkg&nbsp;=&nbsp;inter.pkgpath.name()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">for</span>&nbsp;;&nbsp;j&nbsp;&lt;&nbsp;nt;&nbsp;j++&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;:=&nbsp;&amp;xmhdr[j]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tname&nbsp;:=&nbsp;typ.nameOff(t.name)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;检查方法名字是否一致</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;typ.typeOff(t.mtyp)&nbsp;==&nbsp;itype&nbsp;&amp;&amp;&nbsp;tname.name()&nbsp;==&nbsp;iname&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;:=&nbsp;tname.pkgPath()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;pkgPath&nbsp;==&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">""</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pkgPath&nbsp;=&nbsp;typ.nameOff(x.pkgpath).name()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;tname.isExported()&nbsp;||&nbsp;pkgPath&nbsp;==&nbsp;ipkg&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;m&nbsp;!=&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;获取函数地址，并加入到itab.fun数组中</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifn&nbsp;:=&nbsp;typ.textOff(t.ifn)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>]),&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">uintptr</span>(k)*sys.PtrSize))&nbsp;=&nbsp;ifn<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">goto</span>&nbsp;nextimethod<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;……</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.bad&nbsp;=&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">true</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">break</span><br>&nbsp;&nbsp;&nbsp;&nbsp;nextimethod:<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">if</span>&nbsp;!locked&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"invalid&nbsp;itab&nbsp;locking"</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;计算&nbsp;hash&nbsp;值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;itabhash(inter,&nbsp;typ)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;加到Hash&nbsp;Slot链表中</span><br>&nbsp;&nbsp;&nbsp;&nbsp;m.link&nbsp;=&nbsp;hash[h]<br>&nbsp;&nbsp;&nbsp;&nbsp;m.inhash&nbsp;=&nbsp;<span class="hljs-literal" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">true</span><br>&nbsp;&nbsp;&nbsp;&nbsp;atomicstorep(unsafe.Pointer(&amp;hash[h]),&nbsp;unsafe.Pointer(m))<br>}</p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">additab 会检查 itab 持有的 interfacetype 和 _type 是否符合，就是看 _type 是否完全实现了 interfacetype 的方法，也就是看两者的方法列表重叠的部分就是 interfacetype 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 ni * nt，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 ni + nt 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">求 hash 值的函数比较简单：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">itabhash</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(inter&nbsp;*interfacetype,&nbsp;typ&nbsp;*_type)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">uint32</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;:=&nbsp;inter.typ.hash<br>&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;+=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">17</span>&nbsp;*&nbsp;typ.hash<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span>&nbsp;h&nbsp;%&nbsp;hashSize<br>}<br></p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">hashSize 的值是 1009。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">更一般的，当把实体类型赋值给接口的时候，会调用 conv 系列函数，例如空接口调用 convT2E 系列、非空接口调用 convT2I 系列。这些函数比较相似：</span></p> 
<blockquote> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">1.具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</span></p> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">2.具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</span></p> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">3.而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。</span></p> 
</blockquote> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><br></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L7H0ibIdQobyzuicxzGicfibXUugu11UNG7jA3g0M1ibp02QOr8UTuTDiaDwA/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4L7H0ibIdQobyzuicxzGicfibXUugu11UNG7jA3g0M1ibp02QOr8UTuTDiaDwA/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;"><strong><span style="letter-spacing: 1px;font-size: 18px;">如何用 interface 实现多态</span></strong></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">Go 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">多态是一种运行期的行为，它有以下几个特点：</span></p> 
<blockquote> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">1.一种类型具有多种类型的能力</span></p> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">2.允许不同的对象对同一消息做出灵活的反应</span></p> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">3.以一种通用的方式对待个使用的对象</span></p> 
 <p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">4.非动态语言必须通过继承和接口的方式来实现</span></p> 
</blockquote> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">看一个实现了多态的代码例子：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">package</span>&nbsp;main<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">import</span>&nbsp;<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"fmt"</span><br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">main</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;qcrao&nbsp;:=&nbsp;Student{age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">18</span>}<br>&nbsp;&nbsp;&nbsp;&nbsp;whatJob(&amp;qcrao)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;growUp(&amp;qcrao)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(qcrao)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;stefno&nbsp;:=&nbsp;Programmer{age:&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">100</span>}<br>&nbsp;&nbsp;&nbsp;&nbsp;whatJob(stefno)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;growUp(stefno)<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stefno)<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">whatJob</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Person)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;p.job()<br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">growUp</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Person)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;p.growUp()<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Person&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">interface</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;job()<br>&nbsp;&nbsp;&nbsp;&nbsp;growUp()<br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Student&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Student)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">job</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"I&nbsp;am&nbsp;a&nbsp;student."</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;*Student)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">growUp</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br><br><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">type</span>&nbsp;Programmer&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">struct</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">int</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Programmer)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">job</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(<span class="hljs-string" style="font-size: inherit;line-height: inherit;color: rgb(238, 220, 112);overflow-wrap: inherit !important;word-break: inherit !important;">"I&nbsp;am&nbsp;a&nbsp;programmer."</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br><br><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Programmer)</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">growUp</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;程序员老得太快&nbsp;^_^</span><br>&nbsp;&nbsp;&nbsp;&nbsp;p.age&nbsp;+=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">10</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">return</span><br>}<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">‍代码里先定义了 1 个 Person 接口，包含两个函数：</span></p> 
<section class="code-snippet__fix code-snippet__js"> 
 <ul class="code-snippet__line-index code-snippet__js"> 
  <li></li> 
  <li></li> 
 </ul> 
 <pre class="code-snippet__js" data-lang="golang"><code><span class="code-snippet_outer">job()</span></code><code><span class="code-snippet_outer">growUp()</span></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">然后，又定义了 2 个结构体，Student 和 Programmer，同时，类型 *Student、Programmer 实现了 Person 接口定义的两个函数。注意，*Student 类型实现了接口， Student 类型却没有。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">之后，我又定义了函数参数是 Person 接口的两个函数：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">whatJob</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Person)</span><br><span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">func</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">growUp</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">(p&nbsp;Person)</span><br></span></p></pre> 
</section> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 15px;">main 函数里先生成 Student 和 Programmer 的对象，再将它们分别传入到函数 whatJob 和 growUp。函数中，直接调用接口函数，实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数。于是，不同对象针对同一消息就有多种表现，多态就实现了。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">更深入一点来说的话，在函数 whatJob() 或者 growUp() 内部，接口 person 绑定了实体类型 *Student 或者 Programmer。根据前面分析的 iface 源码，这里会直接调用 fun 里保存的函数，类似于：s.tab-&gt;fun[0]，而因为 fun 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">运行一下代码：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><code class="hljs" style="margin-right: 2px;margin-left: 2px;line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">I&nbsp;am&nbsp;a&nbsp;student.<br>{19}<br>I&nbsp;am&nbsp;a&nbsp;programmer.<br>{100}<br></code></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><br></p> 
<p style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;"><strong><img class="rich_pages" data-copyright="0" data-ratio="0.1625" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LdGlIRH3ub4BRGNibIPlF0AfOJV8WbVoznnD26JxrWdZEXJDpfUxaWqw/640?wx_fmt=png" data-type="png" data-w="160" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhSvZMAt2zKcxGQN3l1NV4LdGlIRH3ub4BRGNibIPlF0AfOJV8WbVoznnD26JxrWdZEXJDpfUxaWqw/640?wx_fmt=png"></strong></span></p> 
<h2 style="text-align: center;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;"><span style="letter-spacing: 1px;"><strong><span style="letter-spacing: 1px;font-size: 18px;">Go 接口与 C++ 接口有何异同</span></strong></span></h2> 
<p style="margin-bottom: 15px;"><span style="font-size: 15px;"><br></span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">接口定义了一种规范，描述了类的行为和功能，而不做具体实现。</span></p> 
<p style="text-align: justify;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;"><span style="font-size: 15px;">C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的。例如：</span></p> 
<section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"> 
 <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="line-height: 18px;font-size: 14px;letter-spacing: 0px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;color: rgb(169, 183, 198);background: rgb(40, 43, 46);padding: 0.5em;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;display: block !important;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;"><span class="hljs-class" style="font-size: inherit;color: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">class</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">Shape</span><br>{</span><br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">public</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;纯虚函数</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;"><span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">virtual</span>&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;overflow-wrap: inherit !important;word-break: inherit !important;">double</span>&nbsp;<span class="hljs-title" style="font-size: inherit;line-height: inherit;color: rgb(165, 218, 45);overflow-wrap: inherit !important;word-break: inherit !important;">getArea</span><span class="hljs-params" style="font-size: inherit;line-height: inherit;color: rgb(255, 152, 35);overflow-wrap: inherit !important;word-break: inherit !important;">()</span>&nbsp;</span>=&nbsp;<span class="hljs-number" style="font-size: inherit;line-height: inherit;color: rgb(174, 135, 250);overflow-wrap: inherit !important;word-break: inherit !important;">0</span>;<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">private</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size: inherit;line-height: inherit;color: rgb(248, 35, 117);overflow-wrap: inherit !important;word-break: inherit !important;">string</span>&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size: inherit;line-height: inherit;color: rgb(128, 128, 128);overflow-wrap: inherit !important;word-break: inherit !important;">//&nbsp;名称</span><br>};<br></p></pre> 
</section> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;line-height: 1.75em;letter-spacing: 1px;margin-bottom: 15px;"><span style="font-size: 15px;">设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</span></p> 
<p style="text-align: justify;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;line-height: 1.75em;letter-spacing: 1px;"><span style="font-size: 15px;">C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 itab 中的 fun 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 itab， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</span></p> 
<h2 style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">参考资料，由于篇幅有限，参考资料有删减<br></span></h2> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【包含反射、接口等源码分析】https://zhuanlan.zhihu.com/p/27055513</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【虚函数表和C++的区别】https://mp.weixin.qq.com/s/jU9HeR1tOyh-ME5iEYM5-Q</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【具体类型向接口赋值】https://tiancaiamao.gitbooks.io/go-internals/content/zh/07.2.html</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【Go夜读群的讨论】https://github.com/developer-learning/reading-go/blob/master/content/discuss/2018-08-30-understanding-go-interfaces.md</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【廖雪峰 鸭子类型】https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431865288798deef438d865e4c2985acff7e9fad15e3000</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【值类型和指针类型，iface源码】https://www.jianshu.com/p/5f8ecbe4f6af</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【总体说明itab的生成方式、作用】http://www.codeceo.com/article/go-interface.html</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【conv系列函数的作用】https://blog.csdn.net/zhonglinzhang/article/details/85772336</span></p> 
<p style="text-align: justify;line-height: 1.75em;letter-spacing: 1px;margin-left: 8px;margin-right: 8px;margin-bottom: 15px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【convI2I itab作用】https://www.jianshu.com/p/a5e99b1d50b1</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;font-variant-numeric: normal;font-variant-east-asian: normal;white-space: normal;widows: 1;line-height: 1.75em;letter-spacing: 1px;background-color: rgb(255, 255, 255);"><span style="color: rgb(136, 136, 136);font-size: 15px;">作者：饶全成，中科院计算所硕士，滴滴出行后端研发工程师。</span></p> 
<p style="margin: 5px 8px 15px;font-variant-numeric: normal;font-variant-east-asian: normal;white-space: normal;widows: 1;line-height: 1.75em;letter-spacing: 1px;background-color: rgb(255, 255, 255);"><span style="color: rgb(136, 136, 136);font-size: 15px;">声明：本文为作者投稿，版权归其个人所有。免责声明：文章广告为微信自动匹配，与本平台无关，如遇假冒伪劣请联系微信进行举报。</span></p> 
<p style="text-align: center;margin-left: 8px;margin-right: 8px;"><img class="rich_pages" data-copyright="0" data-ratio="0.5482233502538071" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAug39yByOmcISc1L0Exsb7CNugP5wV0jXZJO3A5phGZmodPk0Kic8270crj5QPOpzthxcuiaa8EhX8vg/640?wx_fmt=jpeg" data-type="jpeg" data-w="591" style="" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAug39yByOmcISc1L0Exsb7CNugP5wV0jXZJO3A5phGZmodPk0Kic8270crj5QPOpzthxcuiaa8EhX8vg/640?wx_fmt=jpeg"></p> 
<p style="letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;margin-left: 8px;margin-right: 8px;"><span style="font-size: 14px;color: rgb(136, 136, 136);">【END】</span></p> 
<p style="letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;"><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;"><span style="font-size: 15px;">作为码一代，想教码二代却无从下手：</span><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;"><span style="font-size: 15px;">听说少儿编程很火，可它有哪些好处呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;"><span style="font-size: 15px;">孩子多大开始学习比较好呢？又该如何学习呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;"><span style="font-size: 15px;">最新的编程教育政策又有哪些呢？</span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;text-align: center;line-height: normal;"><span style="font-size: 15px;">下面给大家介绍CSDN新成员：<strong>极客宝宝（ID：</strong><strong>geek_baby）</strong></span></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;letter-spacing: 1px;line-height: normal;"><strong><span style="font-size: 14px;color: rgb(0, 82, 255);">戳他了解更多↓↓↓</span></strong><br></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;line-height: 1.75em;letter-spacing: 1px;"><img class="rich_pages " data-copyright="0" data-cropselx1="180" data-cropselx2="438" data-cropsely1="0" data-cropsely2="258" data-ratio="0.3697916666666667" data-s="300,640" data-type="jpeg" data-w="960" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vbbgCLnCbTPs0mGuVrLHntraYT5MIPrhkqQCmnqobLOf7nkWPh5j6vw/640?wx_fmt=jpeg" style="visibility: visible !important;width: 618px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuh1bcXNq238J3vRKyXya05vbbgCLnCbTPs0mGuVrLHntraYT5MIPrhkqQCmnqobLOf7nkWPh5j6vw/640?wx_fmt=jpeg"></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);text-align: center;letter-spacing: 1px;line-height: normal;"><span style="background-color: rgb(0, 82, 255);"><strong style="color: rgb(255, 255, 255);font-size: 15px;"><strong>&nbsp;热 文</strong>&nbsp;推 荐&nbsp;</strong></span></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="font-size: 14px;color: rgb(0, 82, 255);">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719459&amp;idx=1&amp;sn=217d9877d34efbae12173849785f5c83&amp;chksm=bea6b53089d13c267ca062391449e230a18653a23a43e5a0af2cd15ea7aa704354153722271e&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="font-size: 14px;color: rgb(0, 82, 255);">工作 10 年，月薪过万者不足三成，程序员却笑了！</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="font-size: 14px;color: rgb(0, 82, 255);">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719459&amp;idx=2&amp;sn=ee3130e19ead463a7052eb3a6b53be34&amp;chksm=bea6b53089d13c2698dbb31b6f7e8e1453e0512ba9a58d7a4bf64a32ab6655600879040c62d4&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="font-size: 14px;color: rgb(0, 82, 255);">红帽取代 Oracle，接管 OpenJDK 8 和 OpenJDK 11 | 极客头条</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 10px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="font-size: 14px;color: rgb(0, 82, 255);">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;mid=2650719459&amp;idx=3&amp;sn=6cb988d2ab33e41c6e1bf85161dc4be6&amp;chksm=bea6b53089d13c26944cae9b54d6d53eece313c5276e63a901d920156fa03cc45eb8aa67ce34&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="font-size: 14px;color: rgb(0, 82, 255);">44 岁的微软下一步是什么？</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="color: rgb(0, 82, 255);font-size: 14px;">☞</span><a href="http://mp.weixin.qq.com/s?__biz=Mzg3MDA4NDkxMQ==&amp;mid=2247483906&amp;idx=1&amp;sn=028974f5b9a583116b453ea947113916&amp;chksm=ce927a42f9e5f354515bea6a993a29d8358602ba87db2f0ad480d01b4fa80503cf1b679ca39f&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="font-size: 14px;color: rgb(0, 82, 255);">天才程序员：25 岁进贝尔实验室，32 岁创建信息论</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="color: rgb(0, 82, 255);font-size: 14px;">☞&nbsp;</span><a href="http://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&amp;mid=2651010694&amp;idx=1&amp;sn=2961fbd0a2c64aab2fb9029e3087886b&amp;chksm=8bad8571bcda0c6728507245c9ef8d31513b9c9ba2b0569f63e5d9a30f8650110d2a49df7132&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="font-size: 14px;color: rgb(0, 82, 255);">扎心！工作 10 年，月薪过万者不足三成，程序员却笑了</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="font-size: 14px;color: rgb(0, 82, 255);">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MzU2MTE1NDk2Mg==&amp;mid=2247494910&amp;idx=1&amp;sn=b5de3589f59b15a4e5a2f203d4fd87d2&amp;chksm=fc7fb203cb083b15f1764c3da56a3a93298248469ccbb4652b119598e61c1748997b223c8636&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="font-size: 14px;color: rgb(0, 82, 255);">6张图告诉你, 区块链的未来在哪里</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="font-size: 14px;color: rgb(0, 82, 255);">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MzA3MjY1MTQwNQ==&amp;mid=2649827523&amp;idx=2&amp;sn=27f4a1910fc8c352b2cc87a00fe6a3df&amp;chksm=871e8f21b06906370895d2776392b5cea29da2197eec2f63b7681c614ed2fd5bc93a36838fd7&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="font-size: 14px;color: rgb(0, 82, 255);">我们应聘BAT等互联网公司，关于Spring到底需要掌握什么？</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="font-size: 14px;color: rgb(0, 82, 255);">☞</span><a href="http://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&amp;mid=2247504786&amp;idx=1&amp;sn=7eb90f5189c22a76ba0d63cff3c0a69f&amp;chksm=e99ee06bdee9697d3c88a257907bc4e139caa03c2604a634b7378e7b5daabb58d0e4a93ebf76&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="font-size: 14px;color: rgb(0, 82, 255);">如何确定最佳训练数据集规模？6 大必备“锦囊”全给你了 | 技术头条</span></a></p> 
<p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;white-space: normal;background-color: rgb(255, 255, 255);letter-spacing: 1px;line-height: normal;"><span style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);color: rgb(0, 82, 255);font-size: 14px;">☞&nbsp;</span><a href="http://mp.weixin.qq.com/s?__biz=MzA5MjcxNjc2Ng==&amp;mid=2650559816&amp;idx=1&amp;sn=380cfd3d18fb987c0073bf1b8289155a&amp;chksm=88601ef9bf1797ef9e671113fdeed0dac0e1750691de9c6a594dd46706f72aeafa9028b57fe5&amp;scene=21#wechat_redirect" target="_blank" data-itemshowtype="0" data-linktype="2" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"><span style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);font-size: 14px;color: rgb(0, 82, 255);">她说：为啥程序员都特想要机械键盘？这答案我服！</span></a></p> 
<section style="letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);"> 
 <section class="" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;"> 
  <pre style="font-size: inherit;color: inherit;line-height: inherit;"><p style="margin-right: 8px;margin-bottom: 15px;margin-left: 8px;padding: 0.5em;font-size: 14px;font-family: Consolas, Inconsolata, Courier, monospace;border-radius: 0px;background: rgb(34, 34, 34);color: rgb(170, 170, 170);line-height: 1.75em;letter-spacing: 1px;overflow-wrap: normal !important;word-break: normal !important;overflow: auto !important;">System.out.println(<span class="" style="font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br>console.log(<span class="" style="font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br><span class="" style="font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);overflow-wrap: inherit !important;word-break: inherit !important;">print</span>(<span class="" style="font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br><span class="" style="font-size: inherit;line-height: inherit;color: rgb(50, 170, 238);overflow-wrap: inherit !important;word-break: inherit !important;">printf</span>(<span class="" style="font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！\n"</span>);<br>cout&nbsp;&lt;&lt;&nbsp;<span class="" style="font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>&nbsp;&lt;&lt;&nbsp;endl;<br>Console.WriteLine(<span class="" style="font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br>Response.Write(<span class="" style="font-size: inherit;line-height: inherit;color: rgb(255, 204, 51);overflow-wrap: inherit !important;word-break: inherit !important;">"点个在看吧！"</span>);<br><span style="font-variant-numeric: normal;line-height: 24.5px;widows: 1;">alert(</span><span style="font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);">"点个在看吧！"</span><span style="font-variant-numeric: normal;line-height: 24.5px;widows: 1;">)</span><br style="font-variant-numeric: normal;line-height: 24.5px;widows: 1;"><span class="" style="font-size: inherit;font-variant-numeric: normal;line-height: inherit;widows: 1;color: rgb(50, 170, 238);overflow-wrap: inherit !important;word-break: inherit !important;">echo </span><span style="font-variant-numeric: normal;line-height: 24.5px;widows: 1;color: rgb(255, 204, 51);">"点个在看吧！"</span></p></pre> 
 </section> 
</section> 
<section class="" data-tools="135编辑器" data-id="94250" style="letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);border-width: 0px;border-style: none;border-color: initial;"> 
 <section class="" data-tools="135编辑器" data-id="91842" style="border-width: 0px;border-style: none;border-color: initial;text-align: right;"> 
  <section style="display: inline-block;clear: both;"> 
   <section class="" data-brushtype="text" style="padding: 18px 15px 20px 10px;color: rgb(86, 146, 214);background-image: url(&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdy66AHd7QqL7A2s5icSBE0aw4iaKOKPnXGYxQPhG7VMpbbYV6VJprSh7w/640?wx_fmt=png&quot;);background-repeat: no-repeat;text-align: center;background-size: 100% 100%;font-size: 16px;letter-spacing: 1.5px;"> 
    <section style="display: flex;justify-content: center;align-items: center;"> 
     <section style="margin-left: 2px;width: 20px;"> 
      <img class="" data-ratio="0.8936170212765957" data-type="png" data-w="47" data-src="https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png" style="margin-bottom: -6px;visibility: visible !important;width: 20px !important;" src="https://uzshare.com/_p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpplm16ibb8iaib7RoGQ5iaHEdvAd0o9e1LlUGA2k0Yib222agOxzweXhahA9GuzJcGBg0dA4DzlibxRqw/640?wx_fmt=png"> 
     </section> 
     <section class="" data-brushtype="text" style="font-size: 14px;color: rgb(51, 51, 51);text-align: right;"> 
      <span style="font-family: 楷体, 楷体_GB2312, SimKai;">你点的每个“在看”，我都认真当成了喜欢</span> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</section>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
