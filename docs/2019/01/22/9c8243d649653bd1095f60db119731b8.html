<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>基础排序算法总结（七种排序算法C代码） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="基础排序算法总结（七种排序算法C代码）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Linux编程 点击右侧关注，免费入门到精通！ 作者丨李伯特https://www.jianshu.com/p/5b432442275d 排序是最基础的算法，从排序的对象来说主要分为内部排序和外部排序。内部排序主要是针对内存中的数据进行排序，外部排序针对外存如硬盘、光盘中的数据进行排序。内部排序按工作方式主要分为：插入排序（直接插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、交换排序（冒泡排序、快速排序）、归并排序、基数排序。 1.直接插入排序 其基本原理就是从不断从待排序集合中选取元素，逐个插入到有序的集合中，直到取出待排序集合中全部元素。就像我们日常生活中玩扑克牌一样，一边从桌子上抽牌，一边将抽取的牌插入到手中合适的位置。其实现代码如下： /**&nbsp;*&nbsp;insertSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;void&nbsp;insertSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;key&nbsp;&lt;=&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} javascript版本 function&nbsp;insertSort(arr){&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;len&nbsp;=&nbsp;arr.length,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,&nbsp;j,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len&nbsp;-&nbsp;1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&gt;&nbsp;arr[j-1]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j-1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;}} 2.简单选择排序 其基本工作原理是从左只右开始对集合进行扫描，集合左部分为有序集合，集合右不分为待排序集合，每次从待排序集合中选出一个最大的放入左侧有序集合中个，直到右侧待排序集合元素为空。其实现代码如下： /**&nbsp;*&nbsp;selectSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;selectSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;k,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len-1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;i&nbsp;+&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;len;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[j]&nbsp;&lt;&nbsp;arr[k]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;k){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;arr[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[k]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 3.冒泡排序 其基本工作原理是对待排序集合进行遍历，从左至右开始，逐个元素进行扫描，如果左侧元素大于右侧（按升序）则对两个元素进行交换，直到待排序集合末尾，此时通过交换获得了最大的元素。调整右侧有序集合边界向左前进一个。其实现代码如下： /**&nbsp;*&nbsp;bubbleSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;bubbleSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;temp,&nbsp;flag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len-1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;len-i-1;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr[j]&nbsp;&gt;&nbsp;arr[j+1]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;&nbsp;&nbsp;=&nbsp;arr[j+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;flag)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 4.快速排序 其基本原理是采用分治思想，将待排序集合通过中间元素划分为两个子集合，使得中间元素大于其左侧集合中的每一个元素，并且小于其右侧集合中的每一个元素。重复上述过程指导子集合中的元素个数为1。其实现代码如下： /**&nbsp;*&nbsp;quickSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;void&nbsp;quickSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;mid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(l&nbsp;&lt;&nbsp;r){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;partition(arr,&nbsp;l,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;l,&nbsp;mid-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;mid+1,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;partition&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;int&nbsp;partition&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;mid,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;l-1,&nbsp;j&nbsp;=&nbsp;l;&nbsp;j&nbsp;&lt;&nbsp;r;&nbsp;j++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[r]&nbsp;&gt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;j){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[r];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[r]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;&nbsp;&nbsp;} javascript版本： function&nbsp;quickSort(arr,&nbsp;left,&nbsp;right)&nbsp;{&nbsp;&nbsp;var&nbsp;i&nbsp;=&nbsp;left&nbsp;-&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;left,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp;&nbsp;&nbsp;if(left&nbsp;&lt;&nbsp;right)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;j&nbsp;&lt;&nbsp;right;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[right]&nbsp;&gt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;j)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[right];&nbsp;&nbsp;&nbsp;&nbsp;arr[right]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;left,&nbsp;i-1);&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;i+1,&nbsp;right);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return;} 5.归并排序 归并排序也是采用分治思想的一种排序方法。先使每个子序列有序，再使子序列段间有序，然后将已有序的子序列合并，得到完全有序的序列。其处理流程：首先对待排序集合进行划分，划分为两个较小非集合；比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完；然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。其实现代码如下： /**&nbsp;*&nbsp;mergeSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;void&nbsp;mergeSort(int&nbsp;arr[],&nbsp;int&nbsp;result[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;mid,&nbsp;m;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;&lt;&nbsp;r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;(l&nbsp;+&nbsp;r)&nbsp;/&nbsp;2;&nbsp;//&nbsp;向下取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(arr,&nbsp;result,&nbsp;l,&nbsp;mid);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(arr,&nbsp;result&nbsp;,&nbsp;mid+1,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;合并arr[l,&nbsp;mid]和arr[mid+1,&nbsp;r]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;l;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;mid+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;l;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&lt;=mid&nbsp;&amp;&amp;&nbsp;j&lt;=r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[i]&nbsp;&lt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[i++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[j++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&lt;=mid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[i++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&lt;=r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[j++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=l;&nbsp;i&lt;=r;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;result[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 6.希尔排序 希尔排序是对直接插入排序的一种改进，首先采用分治的思想缩小排序集合的规模，也就说将待排序集合进行分组，然后对分组后的集合采用插入法进行排序，通过不断缩小分组数量再排序直到分组为1，就完成了全部排序过程。 /**&nbsp;*&nbsp;shellSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;shellSort(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;dk,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;分组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(dk&nbsp;=&nbsp;len&nbsp;/&nbsp;2;&nbsp;dk&nbsp;&gt;&nbsp;0;&nbsp;dk&nbsp;/=2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;插入排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;dk;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&lt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+dk]&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+dk]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} javascript版本 function&nbsp;shellSort(arr){&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;len&nbsp;=&nbsp;arr.length,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dk&nbsp;=&nbsp;Math.floor(len&nbsp;/&nbsp;2),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp,&nbsp;i,&nbsp;j;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;dk&nbsp;&gt;&nbsp;0;&nbsp;dk&nbsp;=&nbsp;Math.floor(dk&nbsp;/&nbsp;2))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;dk;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i&nbsp;+=&nbsp;dk)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&gt;&nbsp;arr[j-dk])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j-dk];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 7.堆排序 堆是一个数组，在逻辑上是一个近似的完全二叉树，树上的每一个节点对应数组中的元素，数组的索引被用作树中节点的序号。对于一个序号为i的节点来说，左叶子节点为2i，右叶子节点为奇数2i+1，父节点为i/2。 堆排序的基本思路是： ① 先将初始数组R[1..n]建成一个大根堆，此堆为初始的无序区； ② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key； ③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 void&nbsp;swap(int&nbsp;*a,&nbsp;int&nbsp;*b)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;*a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*a&nbsp;=&nbsp;*b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*b&nbsp;=&nbsp;temp;&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapAdjust&nbsp;*&nbsp;@description&nbsp;调整堆&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*&nbsp;@param&nbsp;int&nbsp;index&nbsp;当前节点索引&nbsp;*/&nbsp;&nbsp;void&nbsp;heapAdjust(int&nbsp;arr[],&nbsp;int&nbsp;len,&nbsp;int&nbsp;index)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;left&nbsp;&nbsp;=&nbsp;index*2+1;&nbsp;//&nbsp;左孩子节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;right&nbsp;=&nbsp;index*2+2;&nbsp;//&nbsp;右孩子节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;large&nbsp;=&nbsp;index;&nbsp;//&nbsp;最大节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(left&nbsp;&lt;=&nbsp;len-1&nbsp;&amp;&amp;&nbsp;arr[large]&nbsp;&lt;&nbsp;arr[left])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;=&nbsp;left;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(right&nbsp;&lt;=&nbsp;len-1&nbsp;&amp;&amp;&nbsp;arr[large]&nbsp;&lt;&nbsp;arr[right])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;=&nbsp;right;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(large&nbsp;!=&nbsp;index){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;arr[index],&nbsp;&amp;arr[large]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;len,&nbsp;large);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapBuild&nbsp;*&nbsp;@description&nbsp;创建堆&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;heapBuild(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;len&nbsp;/&nbsp;2&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;0&nbsp;;&nbsp;i--)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;len,&nbsp;i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;heapSort(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建堆&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapBuild(arr,&nbsp;len);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;交换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;len;&nbsp;i&nbsp;&gt;&nbsp;1;&nbsp;i--)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;arr[0],&nbsp;&amp;arr[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调整堆&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;i-1,&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 分析 （1）对于时间复杂度为O(N)的排序算法 时间复杂度为O(N)的算法主要有基数排序、计数排序，但是这两种算法都需要提前知道数组中元素的范围，以此来建立桶的数量，因此并不合适来解决这个问题。 （2）对于时间复杂度为O(N2)的排序算法 时间复杂度O(N2)常用的主要有冒泡、选择、插入，联系到题目所说的基本有序，插入排序是首选，每个元素移动的距离不超过K，因此插入排序中每个元素向前移动的距离也不会超过K，故此时插入排序的时间复杂度为O(N*K)，所以插入排序可以列入考虑。 （3）对于时间复杂度为O(N*logN)的排序算法 时间复杂度O(N*logN)常用的主要有快速排序、归并排序、堆排序，因为这两种排序方法跟数组元素的初始顺序无关，因此这两种方法也是比较好的一种。而堆排序在最好、最坏、平均情况下时间复杂度都为O(N*logN)。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行" />
<meta property="og:description" content="Linux编程 点击右侧关注，免费入门到精通！ 作者丨李伯特https://www.jianshu.com/p/5b432442275d 排序是最基础的算法，从排序的对象来说主要分为内部排序和外部排序。内部排序主要是针对内存中的数据进行排序，外部排序针对外存如硬盘、光盘中的数据进行排序。内部排序按工作方式主要分为：插入排序（直接插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、交换排序（冒泡排序、快速排序）、归并排序、基数排序。 1.直接插入排序 其基本原理就是从不断从待排序集合中选取元素，逐个插入到有序的集合中，直到取出待排序集合中全部元素。就像我们日常生活中玩扑克牌一样，一边从桌子上抽牌，一边将抽取的牌插入到手中合适的位置。其实现代码如下： /**&nbsp;*&nbsp;insertSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;void&nbsp;insertSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;key&nbsp;&lt;=&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} javascript版本 function&nbsp;insertSort(arr){&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;len&nbsp;=&nbsp;arr.length,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,&nbsp;j,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len&nbsp;-&nbsp;1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&gt;&nbsp;arr[j-1]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j-1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;}} 2.简单选择排序 其基本工作原理是从左只右开始对集合进行扫描，集合左部分为有序集合，集合右不分为待排序集合，每次从待排序集合中选出一个最大的放入左侧有序集合中个，直到右侧待排序集合元素为空。其实现代码如下： /**&nbsp;*&nbsp;selectSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;selectSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;k,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len-1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;i&nbsp;+&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;len;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[j]&nbsp;&lt;&nbsp;arr[k]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;k){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;arr[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[k]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 3.冒泡排序 其基本工作原理是对待排序集合进行遍历，从左至右开始，逐个元素进行扫描，如果左侧元素大于右侧（按升序）则对两个元素进行交换，直到待排序集合末尾，此时通过交换获得了最大的元素。调整右侧有序集合边界向左前进一个。其实现代码如下： /**&nbsp;*&nbsp;bubbleSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;bubbleSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;temp,&nbsp;flag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len-1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;len-i-1;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr[j]&nbsp;&gt;&nbsp;arr[j+1]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;&nbsp;&nbsp;=&nbsp;arr[j+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;flag)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 4.快速排序 其基本原理是采用分治思想，将待排序集合通过中间元素划分为两个子集合，使得中间元素大于其左侧集合中的每一个元素，并且小于其右侧集合中的每一个元素。重复上述过程指导子集合中的元素个数为1。其实现代码如下： /**&nbsp;*&nbsp;quickSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;void&nbsp;quickSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;mid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(l&nbsp;&lt;&nbsp;r){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;partition(arr,&nbsp;l,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;l,&nbsp;mid-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;mid+1,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;partition&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;int&nbsp;partition&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;mid,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;l-1,&nbsp;j&nbsp;=&nbsp;l;&nbsp;j&nbsp;&lt;&nbsp;r;&nbsp;j++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[r]&nbsp;&gt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;j){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[r];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[r]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;&nbsp;&nbsp;} javascript版本： function&nbsp;quickSort(arr,&nbsp;left,&nbsp;right)&nbsp;{&nbsp;&nbsp;var&nbsp;i&nbsp;=&nbsp;left&nbsp;-&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;left,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp;&nbsp;&nbsp;if(left&nbsp;&lt;&nbsp;right)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;j&nbsp;&lt;&nbsp;right;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[right]&nbsp;&gt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;j)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[right];&nbsp;&nbsp;&nbsp;&nbsp;arr[right]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;left,&nbsp;i-1);&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;i+1,&nbsp;right);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return;} 5.归并排序 归并排序也是采用分治思想的一种排序方法。先使每个子序列有序，再使子序列段间有序，然后将已有序的子序列合并，得到完全有序的序列。其处理流程：首先对待排序集合进行划分，划分为两个较小非集合；比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完；然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。其实现代码如下： /**&nbsp;*&nbsp;mergeSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;void&nbsp;mergeSort(int&nbsp;arr[],&nbsp;int&nbsp;result[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;mid,&nbsp;m;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;&lt;&nbsp;r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;(l&nbsp;+&nbsp;r)&nbsp;/&nbsp;2;&nbsp;//&nbsp;向下取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(arr,&nbsp;result,&nbsp;l,&nbsp;mid);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(arr,&nbsp;result&nbsp;,&nbsp;mid+1,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;合并arr[l,&nbsp;mid]和arr[mid+1,&nbsp;r]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;l;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;mid+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;l;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&lt;=mid&nbsp;&amp;&amp;&nbsp;j&lt;=r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[i]&nbsp;&lt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[i++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[j++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&lt;=mid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[i++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&lt;=r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[j++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=l;&nbsp;i&lt;=r;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;result[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 6.希尔排序 希尔排序是对直接插入排序的一种改进，首先采用分治的思想缩小排序集合的规模，也就说将待排序集合进行分组，然后对分组后的集合采用插入法进行排序，通过不断缩小分组数量再排序直到分组为1，就完成了全部排序过程。 /**&nbsp;*&nbsp;shellSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;shellSort(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;dk,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;分组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(dk&nbsp;=&nbsp;len&nbsp;/&nbsp;2;&nbsp;dk&nbsp;&gt;&nbsp;0;&nbsp;dk&nbsp;/=2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;插入排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;dk;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&lt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+dk]&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+dk]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} javascript版本 function&nbsp;shellSort(arr){&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;len&nbsp;=&nbsp;arr.length,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dk&nbsp;=&nbsp;Math.floor(len&nbsp;/&nbsp;2),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp,&nbsp;i,&nbsp;j;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;dk&nbsp;&gt;&nbsp;0;&nbsp;dk&nbsp;=&nbsp;Math.floor(dk&nbsp;/&nbsp;2))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;dk;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i&nbsp;+=&nbsp;dk)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&gt;&nbsp;arr[j-dk])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j-dk];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 7.堆排序 堆是一个数组，在逻辑上是一个近似的完全二叉树，树上的每一个节点对应数组中的元素，数组的索引被用作树中节点的序号。对于一个序号为i的节点来说，左叶子节点为2i，右叶子节点为奇数2i+1，父节点为i/2。 堆排序的基本思路是： ① 先将初始数组R[1..n]建成一个大根堆，此堆为初始的无序区； ② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key； ③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 void&nbsp;swap(int&nbsp;*a,&nbsp;int&nbsp;*b)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;*a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*a&nbsp;=&nbsp;*b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*b&nbsp;=&nbsp;temp;&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapAdjust&nbsp;*&nbsp;@description&nbsp;调整堆&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*&nbsp;@param&nbsp;int&nbsp;index&nbsp;当前节点索引&nbsp;*/&nbsp;&nbsp;void&nbsp;heapAdjust(int&nbsp;arr[],&nbsp;int&nbsp;len,&nbsp;int&nbsp;index)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;left&nbsp;&nbsp;=&nbsp;index*2+1;&nbsp;//&nbsp;左孩子节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;right&nbsp;=&nbsp;index*2+2;&nbsp;//&nbsp;右孩子节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;large&nbsp;=&nbsp;index;&nbsp;//&nbsp;最大节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(left&nbsp;&lt;=&nbsp;len-1&nbsp;&amp;&amp;&nbsp;arr[large]&nbsp;&lt;&nbsp;arr[left])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;=&nbsp;left;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(right&nbsp;&lt;=&nbsp;len-1&nbsp;&amp;&amp;&nbsp;arr[large]&nbsp;&lt;&nbsp;arr[right])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;=&nbsp;right;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(large&nbsp;!=&nbsp;index){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;arr[index],&nbsp;&amp;arr[large]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;len,&nbsp;large);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapBuild&nbsp;*&nbsp;@description&nbsp;创建堆&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;heapBuild(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;len&nbsp;/&nbsp;2&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;0&nbsp;;&nbsp;i--)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;len,&nbsp;i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;heapSort(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建堆&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapBuild(arr,&nbsp;len);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;交换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;len;&nbsp;i&nbsp;&gt;&nbsp;1;&nbsp;i--)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;arr[0],&nbsp;&amp;arr[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调整堆&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;i-1,&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 分析 （1）对于时间复杂度为O(N)的排序算法 时间复杂度为O(N)的算法主要有基数排序、计数排序，但是这两种算法都需要提前知道数组中元素的范围，以此来建立桶的数量，因此并不合适来解决这个问题。 （2）对于时间复杂度为O(N2)的排序算法 时间复杂度O(N2)常用的主要有冒泡、选择、插入，联系到题目所说的基本有序，插入排序是首选，每个元素移动的距离不超过K，因此插入排序中每个元素向前移动的距离也不会超过K，故此时插入排序的时间复杂度为O(N*K)，所以插入排序可以列入考虑。 （3）对于时间复杂度为O(N*logN)的排序算法 时间复杂度O(N*logN)常用的主要有快速排序、归并排序、堆排序，因为这两种排序方法跟数组元素的初始顺序无关，因此这两种方法也是比较好的一种。而堆排序在最好、最坏、平均情况下时间复杂度都为O(N*logN)。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行" />
<link rel="canonical" href="https://mlh.app/2019/01/22/9c8243d649653bd1095f60db119731b8.html" />
<meta property="og:url" content="https://mlh.app/2019/01/22/9c8243d649653bd1095f60db119731b8.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-22T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Linux编程 点击右侧关注，免费入门到精通！ 作者丨李伯特https://www.jianshu.com/p/5b432442275d 排序是最基础的算法，从排序的对象来说主要分为内部排序和外部排序。内部排序主要是针对内存中的数据进行排序，外部排序针对外存如硬盘、光盘中的数据进行排序。内部排序按工作方式主要分为：插入排序（直接插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、交换排序（冒泡排序、快速排序）、归并排序、基数排序。 1.直接插入排序 其基本原理就是从不断从待排序集合中选取元素，逐个插入到有序的集合中，直到取出待排序集合中全部元素。就像我们日常生活中玩扑克牌一样，一边从桌子上抽牌，一边将抽取的牌插入到手中合适的位置。其实现代码如下： /**&nbsp;*&nbsp;insertSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;void&nbsp;insertSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;key&nbsp;&lt;=&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} javascript版本 function&nbsp;insertSort(arr){&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;len&nbsp;=&nbsp;arr.length,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,&nbsp;j,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len&nbsp;-&nbsp;1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&gt;&nbsp;arr[j-1]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j-1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;}} 2.简单选择排序 其基本工作原理是从左只右开始对集合进行扫描，集合左部分为有序集合，集合右不分为待排序集合，每次从待排序集合中选出一个最大的放入左侧有序集合中个，直到右侧待排序集合元素为空。其实现代码如下： /**&nbsp;*&nbsp;selectSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;selectSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;k,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len-1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;i&nbsp;+&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;len;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[j]&nbsp;&lt;&nbsp;arr[k]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;k){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;arr[k];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[k]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 3.冒泡排序 其基本工作原理是对待排序集合进行遍历，从左至右开始，逐个元素进行扫描，如果左侧元素大于右侧（按升序）则对两个元素进行交换，直到待排序集合末尾，此时通过交换获得了最大的元素。调整右侧有序集合边界向左前进一个。其实现代码如下： /**&nbsp;*&nbsp;bubbleSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;bubbleSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;temp,&nbsp;flag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;len-1;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;len-i-1;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr[j]&nbsp;&gt;&nbsp;arr[j+1]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;&nbsp;&nbsp;=&nbsp;arr[j+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+1]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;flag)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 4.快速排序 其基本原理是采用分治思想，将待排序集合通过中间元素划分为两个子集合，使得中间元素大于其左侧集合中的每一个元素，并且小于其右侧集合中的每一个元素。重复上述过程指导子集合中的元素个数为1。其实现代码如下： /**&nbsp;*&nbsp;quickSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;void&nbsp;quickSort&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;mid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(l&nbsp;&lt;&nbsp;r){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;partition(arr,&nbsp;l,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;l,&nbsp;mid-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;mid+1,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;partition&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;int&nbsp;partition&nbsp;(int&nbsp;arr[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;mid,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;l-1,&nbsp;j&nbsp;=&nbsp;l;&nbsp;j&nbsp;&lt;&nbsp;r;&nbsp;j++){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[r]&nbsp;&gt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;j){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[r];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[r]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;&nbsp;&nbsp;} javascript版本： function&nbsp;quickSort(arr,&nbsp;left,&nbsp;right)&nbsp;{&nbsp;&nbsp;var&nbsp;i&nbsp;=&nbsp;left&nbsp;-&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;left,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp;&nbsp;&nbsp;if(left&nbsp;&lt;&nbsp;right)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;j&nbsp;&lt;&nbsp;right;&nbsp;j++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[right]&nbsp;&gt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;j)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[right];&nbsp;&nbsp;&nbsp;&nbsp;arr[right]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;left,&nbsp;i-1);&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;i+1,&nbsp;right);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return;} 5.归并排序 归并排序也是采用分治思想的一种排序方法。先使每个子序列有序，再使子序列段间有序，然后将已有序的子序列合并，得到完全有序的序列。其处理流程：首先对待排序集合进行划分，划分为两个较小非集合；比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完；然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。其实现代码如下： /**&nbsp;*&nbsp;mergeSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;l&nbsp;左边界&nbsp;*&nbsp;@param&nbsp;int&nbsp;r&nbsp;右边界&nbsp;*/&nbsp;&nbsp;void&nbsp;mergeSort(int&nbsp;arr[],&nbsp;int&nbsp;result[],&nbsp;int&nbsp;l,&nbsp;int&nbsp;r)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;mid,&nbsp;m;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;&lt;&nbsp;r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;(l&nbsp;+&nbsp;r)&nbsp;/&nbsp;2;&nbsp;//&nbsp;向下取整&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(arr,&nbsp;result,&nbsp;l,&nbsp;mid);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(arr,&nbsp;result&nbsp;,&nbsp;mid+1,&nbsp;r);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;合并arr[l,&nbsp;mid]和arr[mid+1,&nbsp;r]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;l;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;mid+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;l;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&lt;=mid&nbsp;&amp;&amp;&nbsp;j&lt;=r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(arr[i]&nbsp;&lt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[i++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[j++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&lt;=mid)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[i++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&lt;=r)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[j++];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=l;&nbsp;i&lt;=r;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;result[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 6.希尔排序 希尔排序是对直接插入排序的一种改进，首先采用分治的思想缩小排序集合的规模，也就说将待排序集合进行分组，然后对分组后的集合采用插入法进行排序，通过不断缩小分组数量再排序直到分组为1，就完成了全部排序过程。 /**&nbsp;*&nbsp;shellSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;shellSort(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;j,&nbsp;dk,&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;分组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(dk&nbsp;=&nbsp;len&nbsp;/&nbsp;2;&nbsp;dk&nbsp;&gt;&nbsp;0;&nbsp;dk&nbsp;/=2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;插入排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;dk;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;=&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&lt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+dk]&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+dk]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} javascript版本 function&nbsp;shellSort(arr){&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;len&nbsp;=&nbsp;arr.length,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dk&nbsp;=&nbsp;Math.floor(len&nbsp;/&nbsp;2),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp,&nbsp;i,&nbsp;j;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;dk&nbsp;&gt;&nbsp;0;&nbsp;dk&nbsp;=&nbsp;Math.floor(dk&nbsp;/&nbsp;2))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;dk;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i&nbsp;+=&nbsp;dk)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(j&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;temp&nbsp;&gt;&nbsp;arr[j-dk])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j-dk];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 7.堆排序 堆是一个数组，在逻辑上是一个近似的完全二叉树，树上的每一个节点对应数组中的元素，数组的索引被用作树中节点的序号。对于一个序号为i的节点来说，左叶子节点为2i，右叶子节点为奇数2i+1，父节点为i/2。 堆排序的基本思路是： ① 先将初始数组R[1..n]建成一个大根堆，此堆为初始的无序区； ② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key； ③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 void&nbsp;swap(int&nbsp;*a,&nbsp;int&nbsp;*b)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;temp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;*a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*a&nbsp;=&nbsp;*b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*b&nbsp;=&nbsp;temp;&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapAdjust&nbsp;*&nbsp;@description&nbsp;调整堆&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*&nbsp;@param&nbsp;int&nbsp;index&nbsp;当前节点索引&nbsp;*/&nbsp;&nbsp;void&nbsp;heapAdjust(int&nbsp;arr[],&nbsp;int&nbsp;len,&nbsp;int&nbsp;index)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;left&nbsp;&nbsp;=&nbsp;index*2+1;&nbsp;//&nbsp;左孩子节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;right&nbsp;=&nbsp;index*2+2;&nbsp;//&nbsp;右孩子节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;large&nbsp;=&nbsp;index;&nbsp;//&nbsp;最大节点索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(left&nbsp;&lt;=&nbsp;len-1&nbsp;&amp;&amp;&nbsp;arr[large]&nbsp;&lt;&nbsp;arr[left])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;=&nbsp;left;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(right&nbsp;&lt;=&nbsp;len-1&nbsp;&amp;&amp;&nbsp;arr[large]&nbsp;&lt;&nbsp;arr[right])&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;=&nbsp;right;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(large&nbsp;!=&nbsp;index){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;arr[index],&nbsp;&amp;arr[large]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;len,&nbsp;large);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapBuild&nbsp;*&nbsp;@description&nbsp;创建堆&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;heapBuild(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;len&nbsp;/&nbsp;2&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;0&nbsp;;&nbsp;i--)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;len,&nbsp;i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;/**&nbsp;*&nbsp;heapSort&nbsp;*&nbsp;@author&nbsp;liebert&nbsp;*&nbsp;@param&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;*&nbsp;@param&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;*/&nbsp;&nbsp;void&nbsp;heapSort(int&nbsp;arr[],&nbsp;int&nbsp;len)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;建堆&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapBuild(arr,&nbsp;len);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;交换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;len;&nbsp;i&nbsp;&gt;&nbsp;1;&nbsp;i--)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;arr[0],&nbsp;&amp;arr[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调整堆&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;i-1,&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;} 分析 （1）对于时间复杂度为O(N)的排序算法 时间复杂度为O(N)的算法主要有基数排序、计数排序，但是这两种算法都需要提前知道数组中元素的范围，以此来建立桶的数量，因此并不合适来解决这个问题。 （2）对于时间复杂度为O(N2)的排序算法 时间复杂度O(N2)常用的主要有冒泡、选择、插入，联系到题目所说的基本有序，插入排序是首选，每个元素移动的距离不超过K，因此插入排序中每个元素向前移动的距离也不会超过K，故此时插入排序的时间复杂度为O(N*K)，所以插入排序可以列入考虑。 （3）对于时间复杂度为O(N*logN)的排序算法 时间复杂度O(N*logN)常用的主要有快速排序、归并排序、堆排序，因为这两种排序方法跟数组元素的初始顺序无关，因此这两种方法也是比较好的一种。而堆排序在最好、最坏、平均情况下时间复杂度都为O(N*logN)。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行","@type":"BlogPosting","url":"https://mlh.app/2019/01/22/9c8243d649653bd1095f60db119731b8.html","headline":"基础排序算法总结（七种排序算法C代码）","dateModified":"2019-01-22T00:00:00+08:00","datePublished":"2019-01-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/01/22/9c8243d649653bd1095f60db119731b8.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>基础排序算法总结（七种排序算法C代码）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/XUfq62QbuNhyG8Y9IxZUNMLyjv7k7dsq3bia9CRMmdkOM1WyLYEHlib4MFfrqRE97iaUqJ7NwhZEoHu0U8NCXWzsA/640?wx_fmt=gif" alt="640?wx_fmt=gif"></p>
   <p style="min-height:1em;text-align:center;"><a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span class="js_jump_icon h5_image_link"><img style="letter-spacing:.544px;text-align:justify;color:rgb(62,62,62);width:76px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/XUfq62QbuNiaFZIbV1icByYIGKRlUcFt6IBMGhWJcyxibORgs6MEmSnJlA3ibibR7ibpudwZAbFZdqISttPaQTBkPPtQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></span></a></p>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span style="font-family:'宋体', SimSun;"><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"><strong>Linux编程</strong></span></strong></span></a>
   <span style="font-family:'黑体', SimHei;"><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong></span>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span style="letter-spacing:.544px;color:rgb(165,165,165);font-family:'黑体', SimHei;"><span>点击右侧关注，免费入门到精通！</span></span></a>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span class="js_jump_icon h5_image_link"><img style="width:56px;" title="1081255447.jpg" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/XUfq62QbuNiaFZIbV1icByYIGKRlUcFt6IldAicZsKdD8KXBZkWQz1eHWULt7Sy2XUdKWbFt8oY6f6nL5deCuF9yg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></span></a>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:14px;color:rgb(136,136,136);"><span style="font-size:14px;letter-spacing:1px;line-height:34.1333px;">作者丨李伯特</span><br style="color:rgb(74,74,74);font-size:16px;letter-spacing:1px;line-height:34.1333px;"><span style="font-size:14px;letter-spacing:1px;line-height:34.1333px;">https://www.jianshu.com/p/5b432442275d</span></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><span style="color:rgb(74,74,74);font-size:16px;letter-spacing:1px;line-height:34.1333px;"><br></span></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">排序是最基础的算法，从排序的对象来说主要分为内部排序和外部排序。内部排序主要是针对内存中的数据进行排序，外部排序针对外存如硬盘、光盘中的数据进行排序。内部排序按工作方式主要分为：插入排序（直接插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、交换排序（冒泡排序、快速排序）、归并排序、基数排序。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">1.直接插入排序</span></h4>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">其基本原理就是从不断从待排序集合中选取元素，逐个插入到有序的集合中，直到取出待排序集合中全部元素。就像我们日常生活中玩扑克牌一样，一边从桌子上抽牌，一边将抽取的牌插入到手中合适的位置。其实现代码如下：</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs java" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;insertSort&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;<br>*/</span>&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">insertSort</span>&nbsp;<span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;len)</span>&nbsp;&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i,&nbsp;j,&nbsp;key;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">while</span>&nbsp;(j&nbsp;&gt;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>&nbsp;&amp;&amp;&nbsp;key&nbsp;&lt;=&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>]&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>]&nbsp;=&nbsp;key;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>}<br></code></pre>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">javascript版本</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs lua" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">function</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">insertSort</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(arr)</span></span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span>&nbsp;=&nbsp;arr.length,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,&nbsp;j,&nbsp;temp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;&nbsp;i&nbsp;&lt;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span>&nbsp;-&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">while</span>&nbsp;(j&nbsp;&gt;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>&nbsp;&amp;&amp;&nbsp;temp&nbsp;&gt;&nbsp;arr[j<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-1</span>]){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-1</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">--;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></h4>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">2.简单选择排序</span></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">其基本工作原理是从左只右开始对集合进行扫描，集合左部分为有序集合，集合右不分为待排序集合，每次从待排序集合中选出一个最大的放入左侧有序集合中个，直到右侧待排序集合元素为空。其实现代码如下：</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs vbscript" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">/**&nbsp;<br>*&nbsp;selectSort&nbsp;<br>*&nbsp;@author&nbsp;liebert&nbsp;<br>*&nbsp;@param&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[]&nbsp;待排序数组&nbsp;<br>*&nbsp;@param&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span>&nbsp;数组长度&nbsp;<br>*/&nbsp;&nbsp;<br>void&nbsp;selectSort&nbsp;(<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span>)&nbsp;&nbsp;&nbsp;<br>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i,&nbsp;j,&nbsp;k,&nbsp;temp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;&nbsp;i&nbsp;&lt;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span><span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-1</span>;&nbsp;i++)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;i;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(j&nbsp;=&nbsp;i&nbsp;+&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;j&nbsp;&lt;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span>;&nbsp;j++)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(arr[j]&nbsp;&lt;&nbsp;arr[k]){&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;j;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(i&nbsp;!=&nbsp;k){&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;arr[k];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[k]&nbsp;=&nbsp;temp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>}<br></code></pre>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></h4>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">3.冒泡排序</span></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">其基本工作原理是对待排序集合进行遍历，从左至右开始，逐个元素进行扫描，如果左侧元素大于右侧（按升序）则对两个元素进行交换，直到待排序集合末尾，此时通过交换获得了最大的元素。调整右侧有序集合边界向左前进一个。其实现代码如下：</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs java" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;bubbleSort&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;<br>*/</span>&nbsp;&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">bubbleSort</span>&nbsp;<span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;len)</span>&nbsp;&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i,&nbsp;j,&nbsp;temp,&nbsp;flag;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;&nbsp;i&nbsp;&lt;&nbsp;len-<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;i++)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(j&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;&nbsp;j&nbsp;&lt;&nbsp;len-i-<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;j++)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>(arr[j]&nbsp;&gt;&nbsp;arr[j+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>]){&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;&nbsp;&nbsp;=&nbsp;arr[j+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>]&nbsp;=&nbsp;temp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag&nbsp;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>&nbsp;==&nbsp;flag)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>}<br></code></pre>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></h4>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">4.快速排序</span></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">其基本原理是采用分治思想，将待排序集合通过中间元素划分为两个子集合，使得中间元素大于其左侧集合中的每一个元素，并且小于其右侧集合中的每一个元素。重复上述过程指导子集合中的元素个数为1。其实现代码如下：</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs java" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;quickSort&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待排序数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;l&nbsp;左边界&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;r&nbsp;右边界&nbsp;<br>*/</span>&nbsp;&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">quickSort</span>&nbsp;<span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;l,&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;r)</span>&nbsp;&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;mid;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>(l&nbsp;&lt;&nbsp;r){&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;partition(arr,&nbsp;l,&nbsp;r);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;l,&nbsp;mid-<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;mid+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,&nbsp;r);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>}&nbsp;&nbsp;<br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;partition&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;l&nbsp;左边界&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;r&nbsp;右边界&nbsp;<br>*/</span>&nbsp;&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">int</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">partition</span>&nbsp;<span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;l,&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;r)</span>&nbsp;&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i,&nbsp;j,&nbsp;mid,&nbsp;temp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;l-<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,&nbsp;j&nbsp;=&nbsp;l;&nbsp;j&nbsp;&lt;&nbsp;r;&nbsp;j++){&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(arr[r]&nbsp;&gt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(i&nbsp;!=&nbsp;j){&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;=&nbsp;arr[r];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;arr[r]&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;i;&nbsp;&nbsp;<br>}<br></code></pre>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">javascript版本：</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs vbscript" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">function</span>&nbsp;quickSort(arr,&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">left</span>,&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">right</span>)&nbsp;{<br>&nbsp;&nbsp;var&nbsp;i&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">left</span>&nbsp;-&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">left</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp;<br><br>&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>(<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">left</span>&nbsp;&lt;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">right</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(;&nbsp;j&nbsp;&lt;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">right</span>;&nbsp;j++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(arr[<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">right</span>]&nbsp;&gt;&nbsp;arr[j])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(i&nbsp;!=&nbsp;j)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;i++;<br>&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">right</span>];<br>&nbsp;&nbsp;&nbsp;&nbsp;arr[<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">right</span>]&nbsp;=&nbsp;arr[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;temp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">left</span>,&nbsp;i<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">-1</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;quickSort(arr,&nbsp;i+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">right</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>}<br></code></pre>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></h4>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">5.归并排序</span></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">归并排序也是采用分治思想的一种排序方法。先使每个子序列有序，再使子序列段间有序，然后将已有序的子序列合并，得到完全有序的序列。其处理流程：首先对待排序集合进行划分，划分为两个较小非集合；比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完；然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。其实现代码如下：</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs java" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;mergeSort&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;l&nbsp;左边界&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;r&nbsp;右边界&nbsp;<br>*/</span>&nbsp;&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">mergeSort</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;result[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;l,&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;r)</span>&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i,&nbsp;j,&nbsp;mid,&nbsp;m;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(l&nbsp;&lt;&nbsp;r)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid&nbsp;=&nbsp;(l&nbsp;+&nbsp;r)&nbsp;/&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;向下取整&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(arr,&nbsp;result,&nbsp;l,&nbsp;mid);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergeSort(arr,&nbsp;result&nbsp;,&nbsp;mid+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,&nbsp;r);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;合并arr[l,&nbsp;mid]和arr[mid+1,&nbsp;r]&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;l;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;mid+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;l;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">while</span>&nbsp;(i&lt;=mid&nbsp;&amp;&amp;&nbsp;j&lt;=r)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(arr[i]&nbsp;&lt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[i++];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">else</span>&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[j++];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">while</span>&nbsp;(i&lt;=mid)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[i++];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">while</span>&nbsp;(j&lt;=r)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[m++]&nbsp;=&nbsp;arr[j++];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>(i=l;&nbsp;i&lt;=r;&nbsp;i++)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[i]&nbsp;=&nbsp;result[i];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>}<br></code></pre>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></h4>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">6.希尔排序</span></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">希尔排序是对直接插入排序的一种改进，首先采用分治的思想缩小排序集合的规模，也就说将待排序集合进行分组，然后对分组后的集合采用插入法进行排序，通过不断缩小分组数量再排序直到分组为1，就完成了全部排序过程。</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs java" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;shellSort&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;<br>*/</span>&nbsp;&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">shellSort</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;len)</span>&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i,&nbsp;j,&nbsp;dk,&nbsp;temp;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;分组&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(dk&nbsp;=&nbsp;len&nbsp;/&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>;&nbsp;dk&nbsp;&gt;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;&nbsp;dk&nbsp;/=<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;插入排序&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;dk;&nbsp;i&nbsp;&lt;&nbsp;len;&nbsp;i++)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[i];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i&nbsp;-&nbsp;dk;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">while</span>&nbsp;(j&nbsp;&gt;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>&nbsp;&amp;&amp;&nbsp;temp&nbsp;&lt;&nbsp;arr[j])&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+dk]&nbsp;=&nbsp;arr[j];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j+dk]&nbsp;=&nbsp;temp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>}<br></code></pre>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">javascript版本</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs lua" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">function</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">shellSort</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(arr)</span></span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span>&nbsp;=&nbsp;arr.length,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dk&nbsp;=&nbsp;Math.<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">floor</span>(<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span>&nbsp;/&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp,&nbsp;i,&nbsp;j;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(;&nbsp;dk&nbsp;&gt;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>;&nbsp;dk&nbsp;=&nbsp;Math.<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">floor</span>(dk&nbsp;/&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;dk;&nbsp;i&nbsp;&lt;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">len</span>;&nbsp;i&nbsp;+=&nbsp;dk)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;arr[j];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">while</span>&nbsp;(j&nbsp;&gt;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>&nbsp;&amp;&amp;&nbsp;temp&nbsp;&gt;&nbsp;arr[j-dk])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;arr[j-dk];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;-=&nbsp;dk;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[j]&nbsp;=&nbsp;temp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></h4>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">7.堆排序</span></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">堆是一个数组，在逻辑上是一个近似的完全二叉树，树上的每一个节点对应数组中的元素，数组的索引被用作树中节点的序号。对于一个序号为i的节点来说，左叶子节点为2i，右叶子节点为奇数2i+1，父节点为i/2。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">堆排序的基本思路是：</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>① 先将初始数组R[1..n]建成一个大根堆，此堆为初始的无序区；</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key；</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs java" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">swap</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;*a,&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;*b)</span>&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;temp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;*a;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;*a&nbsp;=&nbsp;*b;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;*b&nbsp;=&nbsp;temp;&nbsp;&nbsp;<br>}&nbsp;&nbsp;<br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;heapAdjust&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@description</span>&nbsp;调整堆&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;index&nbsp;当前节点索引&nbsp;<br>*/</span>&nbsp;&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">heapAdjust</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;len,&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;index)</span>&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;left&nbsp;&nbsp;=&nbsp;index*<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;左孩子节点索引&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;right&nbsp;=&nbsp;index*<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>+<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;右孩子节点索引&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;large&nbsp;=&nbsp;index;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;最大节点索引&nbsp;&nbsp;</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(left&nbsp;&lt;=&nbsp;len-<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>&nbsp;&amp;&amp;&nbsp;arr[large]&nbsp;&lt;&nbsp;arr[left])&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;=&nbsp;left;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(right&nbsp;&lt;=&nbsp;len-<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>&nbsp;&amp;&amp;&nbsp;arr[large]&nbsp;&lt;&nbsp;arr[right])&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;=&nbsp;right;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">if</span>&nbsp;(large&nbsp;!=&nbsp;index){&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;arr[index],&nbsp;&amp;arr[large]);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;len,&nbsp;large);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>}&nbsp;&nbsp;<br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;heapBuild&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@description</span>&nbsp;创建堆&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;<br>*/</span>&nbsp;&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">heapBuild</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;len)</span>&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i;&nbsp;&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;len&nbsp;/&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">2</span>&nbsp;-&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;i&nbsp;&gt;=&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>&nbsp;;&nbsp;i--)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;len,&nbsp;i);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br>}&nbsp;&nbsp;<br><br><span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">/**&nbsp;<br>*&nbsp;heapSort&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@author</span>&nbsp;liebert&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;arr[]&nbsp;待分割数组&nbsp;<br>*&nbsp;<span class="hljs-doctag" style="font-size:inherit;color:inherit;line-height:inherit;">@param</span>&nbsp;int&nbsp;len&nbsp;数组长度&nbsp;<br>*/</span>&nbsp;&nbsp;<br><span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">heapSort</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;arr[],&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;len)</span>&nbsp;&nbsp;<br></span>{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">int</span>&nbsp;i&nbsp;;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;建堆&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;heapBuild(arr,&nbsp;len);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;交换&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">for</span>&nbsp;(i&nbsp;=&nbsp;len;&nbsp;i&nbsp;&gt;&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>;&nbsp;i--)&nbsp;{&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;arr[<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>],&nbsp;&amp;arr[i]);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="font-size:inherit;line-height:inherit;color:rgb(128,128,128);">//&nbsp;调整堆&nbsp;&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heapAdjust(arr,&nbsp;i-<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">1</span>,&nbsp;<span class="hljs-number" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">0</span>);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br><br>}<br></code></pre>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></h4>
   <h4 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="font-size:8px;color:rgb(0,128,255);font-family:'宋体';text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">分析</span></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">（1）对于时间复杂度为O(N)的排序算法</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>时间复杂度为O(N)的算法主要有基数排序、计数排序，但是这两种算法都需要提前知道数组中元素的范围，以此来建立桶的数量，因此并不合适来解决这个问题。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">（2）对于时间复杂度为O(N2)的排序算法</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>时间复杂度O(N2)常用的主要有冒泡、选择、插入，联系到题目所说的基本有序，插入排序是首选，每个元素移动的距离不超过K，因此插入排序中每个元素向前移动的距离也不会超过K，故此时插入排序的时间复杂度为O(N*K)，所以插入排序可以列入考虑。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">（3）对于时间复杂度为O(N*logN)的排序算法</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>时间复杂度O(N*logN)常用的主要有快速排序、归并排序、堆排序，因为这两种排序方法跟数组元素的初始顺序无关，因此这两种方法也是比较好的一种。而堆排序在最好、最坏、平均情况下时间复杂度都为O(N*logN)。</span></p>
   <p><br></p>
   <p style="text-align:center;letter-spacing:1.5px;"><span style="color:rgb(255,255,255);"><strong><span style="font-size:20px;">&nbsp;推荐↓↓↓&nbsp;</span></strong></span></p>
   <img style="vertical-align:middle;width:313px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/IwiaNBuWUDUzX3vMCt57DzWD1FUkicYK3C3VObzhyt4YU3rXujLwMXHoHqpB6B72h44DNib9J9jbQHk3giaxAeABWg/640?wx_fmt=png" alt="640?wx_fmt=png">
   <p><strong>长</strong></p>
   <p><strong>按</strong></p>
   <p><strong>关</strong></p>
   <p><strong>注</strong></p>
   <p style="letter-spacing:0px;"><strong><span style="font-size:18px;">👉</span></strong><span style="font-size:17px;"><strong>【</strong></span><a href="https://mp.weixin.qq.com/s?__biz=MzUzMDc0NzU4Nw==&amp;mid=2247483768&amp;idx=1&amp;sn=4ef4f1510616baa395c507e32bb439d7&amp;scene=21#wechat_redirect" rel="nofollow" style="text-decoration:underline;color:rgb(255,79,121);font-size:17px;"><span style="color:rgb(255,79,121);font-size:17px;"><strong>16个技术公众号</strong></span></a><span style="font-size:17px;"><strong>】都在这里！</strong></span></p>
   <p><span style="color:rgb(136,136,136);font-size:15px;">涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。</span></p>
   <img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/ol72Wnba7fLkfGhCjKwHfZOmHMkVTIomtmHARHGo86u52ZIGicxfPPFBQ85dBUWf3trqDHPUuN7E2e26DpvfJdQ/640?wx_fmt=png" alt="640?wx_fmt=png">万水千山总是情，点个 “
   <strong><span style="color:rgb(0,112,192);">好看</span></strong>” 行不行
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
