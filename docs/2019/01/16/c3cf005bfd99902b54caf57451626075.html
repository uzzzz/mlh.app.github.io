<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>机器学习项目入门篇：一个完整的机器学习项目 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="机器学习项目入门篇：一个完整的机器学习项目" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本部分，我们会作为被一家地产公司雇佣的数据科学家，完整地学习一个项目。下面是主要步骤： 项目概述。 获取数据。 发现并可视化数据，发现规律。 为机器学习算法准备数据。 选择模型，进行训练。 微调模型。 给出解决方案。 部署、监控、维护系统。 一、项目概述 任务是利用加州普查数据，建立一个加州房价模型。这个数据包含每个分区组的人口、收入中位数、房价中位数等指标。分区组是美国调查局发布样本数据的最小地理单位（一个分区通常有600到3000人）。我们将其简称为“分区”。你的模型要利用这个数据进行学习，然后根据其它指标，预测任何分区的的房价中位数。 1.划定问题 首先，你需要划定问题：监督或非监督，还是强化学习？这是个分类任务、回归任务，还是其它的？要使用批量学习还是线上学习？ 答：这是一个典型的监督学习任务，因为你要使用的是有标签的训练样本（每个实例都有预定的产出，即分区的房价中位数）。并且，这是一个典型的回归任务，因为你要预测一个值。讲的更细些，这是一个多变量回归问题，因为系统要使用多个变量进行预测（要使用分区的人口，收入中位数等等）。最后，没有连续的数据流进入系统，没有特别需求需要对数据变动作出快速适应。数据量不大可以放到内存中，因此批量学习就够了。 2.选择性能指标 下一步是选择性能指标。回归问题的典型指标是均方根误差（RMSE）。均方根误差测量的是系统预测误差的标准差。计算RMSE的计算方法如下： 虽然大多数时候RMSE是回归任务可靠的性能指标，在有些情况下，你可能需要另外的函数。例如，假设存在许多异常的分区。此时，你可能需要使用绝对平均误差（Mean Absolute Error，也称作平均绝对偏差。MAE的计算如下： 二、获取数据 1.创建工作环境 我的工作环境是Jupyter notebook，使用python3.0版本，安装Python模块：Jupyter、NumPy、Pandas、Matplotlib和Scikit-Learn。 2.下载数据 import os import tarfile from six.moves import urllib DOWNLOAD_ROOT = &quot;https://raw.githubusercontent.com/ageron/handson-ml/master/&quot; HOUSING_PATH = &quot;datasets/housing&quot; HOUSING_URL = DOWNLOAD_ROOT + HOUSING_PATH + &quot;/housing.tgz&quot; def fetch_housing_data(housing_url=HOUSING_URL, housing_path=HOUSING_PATH): if not os.path.isdir(housing_path): os.makedirs(housing_path) tgz_path = os.path.join(housing_path, &quot;housing.tgz&quot;) urllib.request.urlretrieve(housing_url, tgz_path) housing_tgz = tarfile.open(tgz_path) housing_tgz.extractall(path=housing_path) housing_tgz.close() fetch_housing_data() 然后使用Pandas加载数据:&nbsp; import pandas as pd def load_housing_data(housing_path=HOUSING_PATH): csv_path = os.path.join(housing_path, &quot;housing.csv&quot;) return pd.read_csv(csv_path) 3.查看数据结构 使用DataFrame的head()方法查看该数据集的顶部5行。 housing = load_housing_data() housing.head() 每一行都表示一个分区。共有10个属性（截图中可以看到6个）：经度、维度、房屋年龄中位数、总房间数、卧室数量、人口数、家庭数、收入中位数、房屋价值中位数、大海距离。 info()方法可以快速查看数据的描述，包括总行数、每个属性的类型和非空值的数量。 housing.info() 所有的属性都是数值的，除了大海距离这项。它的类型是对象，因此可以包含任意Python对象，但是因为是从CSV文件加载的，所以必然是文本。当查看顶部的五行时，你可能注意到那一列的值是重复的，意味着它可能是一个分类属性。可以使用value_counts()方法查看都有什么类型，每个类都有多少分区： housing[&quot;ocean_proximity&quot;].value_counts() &nbsp; describe()方法展示了数值属性的概括: housing.describe() count、mean、min和max几行的意思很明了。注意，空值被忽略了（所以，卧室总数是20433而不是20640）。std是标准差（揭示数值的分散度）。25%、50%、75%展示了对应的分位数：每个分位数指明小于这个值，且指定分组的百分比。例如，25%的分区的房屋年龄中位数小于18，而50%的小于29，75%的小于37。 另一种快速了解数据类型的方法是画出每个数值属性的柱状图。柱状图（的纵轴）展示了特定范围的实例的个数。你还可以一次给一个属性画图，或对完整数据集调用hist()方法，后者会画出每个数值属性的柱状图。 4.创建测试集 纯随机采样测试集 (1)自己编写代码，设置随机数生成器的种子（比如np.random.seed(42)），以产生总是相同的混合指数（shuffled indices） # to make this notebook&#39;s output identical at every run np.random.seed(42) import numpy as np def split_train_test(data, test_ratio): shuffled_indices = np.random.permutation(len(data)) test_set_size = int(len(data) * test_ratio) test_indices = shuffled_indices[:test_set_size] train_indices = shuffled_indices[test_set_size:] return data.iloc[train_indices], data.iloc[test_indices] train_set, test_set = split_train_test(housing, 0.2) print(len(train_set), &quot;train +&quot;, len(test_set), &quot;test&quot;) &nbsp;(2)使用hash import hashlib def test_set_check(identifier, test_ratio, hash): return hash(np.int64(identifier)).digest()[-1] &lt; 256 * test_ratio def split_train_test_by_id(data, test_ratio, id_column, hash=hashlib.md5): ids = data[id_column] in_test_set = ids.apply(lambda id_: test_set_check(id_, test_ratio, hash)) return data.loc[~in_test_set], data.loc[in_test_set] housing_with_id = housing.reset_index() # adds an `index` column train_set, test_set = split_train_test_by_id(housing_with_id, 0.2, &quot;index&quot;) &nbsp;如果使用行索引作为唯一识别码，你需要保证新数据放到现有数据的尾部，且没有行被深处。如果做不到，则可以用最稳定的特征来创建唯一识别码。例如，一个区的维度和经度在几百万年之内是不变的，所以可以将两者结合成一个ID： housing_with_id[&quot;id&quot;] = housing[&quot;longitude&quot;] * 1000 + housing[&quot;latitude&quot;] train_set, test_set = split_train_test_by_id(housing_with_id, 0.2, &quot;id&quot;) (3)sklearn实现 from sklearn.model_selection import train_test_split train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42) 分层采样的测试集 当你的数据集很大时（尤其是和属性数相比），这通常可行；但如果数据集不大，就会有采样偏差的风险。当一个调查公司想要对1000个人进行调查，它们不是在电话亭里随机选1000个人出来。调查公司要保证这1000个人对人群整体有代表性。例如，美国人口的51.3%是女性，48.7%是男性。所以在美国，严谨的调查需要保证样本也是这个比例：513名女性，487名男性。这称作分层采样（stratified sampling）：将人群分成均匀的子分组，称为分层，从每个分层取出合适数量的实例，以保证测试集对总人数有代表性。 假设专家告诉你，收入中位数是预测房价中位数非常重要的属性。你可能想要保证测试集可以代表整体数据集中的多种收入分类。因为收入中位数是一个连续的数值属性，你首先需要创建一个收入分类属性。大多数的收入中位数的值聚集在2-5（一万美元），但是一些收入中位数会超过6。数据集中的每个分层都要有足够的实例位于你的数据中，这点很重要。否则，对分层重要性的评估就会有偏差。这意味着，你不能有过多的分层，且每个分层都要足够大。后面的代码通过将收入中位数除以1.5（以限制收入分类的数量），创建了一个收入分类属性，用ceil对值舍入（以产生离散的分类），然后将所有大于5的分类归入到分类5： housing[&quot;income_cat&quot;] = np.ceil(housing[&quot;median_income&quot;] / 1.5) housing[&quot;income_cat&quot;].where(housing[&quot;income_cat&quot;] &lt; 5, 5.0, inplace=True) 根据收入分类，使用Scikit-Learn的StratifiedShuffleSplit类进行分层采样: from sklearn.model_selection import StratifiedShuffleSplit split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42) for train_index, test_index in split.split(housing, housing[&quot;income_cat&quot;]): strat_train_set = housing.loc[train_index] strat_test_set = housing.loc[test_index] &nbsp;在测试集和完整的房产数据集中查看收入分类比例： strat_test_set[&quot;income_cat&quot;].value_counts() / len(strat_test_set) housing[&quot;income_cat&quot;].value_counts() / len(housing) &nbsp; 对比了总数据集、分层采样的测试集、纯随机采样测试集的收入分类比例。可以看到，分层采样测试集的收入分类比例与总数据集几乎相同，而随机采样数据集偏差严重。 def income_cat_proportions(data): return data[&quot;income_cat&quot;].value_counts() / len(data) train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42) compare_props = pd.DataFrame({ &quot;Overall&quot;: income_cat_proportions(housing), &quot;Stratified&quot;: income_cat_proportions(strat_test_set), &quot;Random&quot;: income_cat_proportions(test_set), }).sort_index() compare_props[&quot;Rand. %error&quot;] = 100 * compare_props[&quot;Random&quot;] / compare_props[&quot;Overall&quot;] - 100 compare_props[&quot;Strat. %error&quot;] = 100 * compare_props[&quot;Stratified&quot;] / compare_props[&quot;Overall&quot;] - 100 compare_props 删除income_cat属性，使数据回到初始状态： for set_ in (strat_train_set, strat_test_set): set_.drop(&quot;income_cat&quot;, axis=1, inplace=True) &nbsp;我们用了大量时间来生成测试集的原因是：测试集通常被忽略，但实际是机器学习非常重要的一部分。还有，生成测试集过程中的许多思路对于后面的交叉验证讨论是非常有帮助的。 三、发现并可视化数据，发现规律 首先，保证你将测试集放在了一旁，只是研究训练集。另外，如果训练集非常大，你可能需要再采样一个探索集，保证操作方便快速。在我们的案例中，数据集很小，所以可以在全集上直接工作。创建一个副本，以免损伤训练集： housing = strat_train_set.copy() 1.地理数据可视化&nbsp; 因为存在地理信息（纬度和经度），创建一个所有分区的散点图来数据可视化是一个不错的主意。 housing.plot(kind=&quot;scatter&quot;, x=&quot;longitude&quot;, y=&quot;latitude&quot;, alpha=0.1) 可以非常清楚地看到高密度区域，湾区、洛杉矶和圣迭戈，以及中央谷，特别是从萨克拉门托到弗雷斯诺。现在来看房价，每个圈的半径表示分区的人口（选项s），颜色代表价格（选项c）。我们用预先定义的颜色图（选项cmap）jet，它的范围是从蓝色（低价）到红色（高价）：&nbsp; housing.plot(kind=&quot;scatter&quot;, x=&quot;longitude&quot;, y=&quot;latitude&quot;, alpha=0.4, s=housing[&quot;population&quot;]/100, label=&quot;population&quot;, c=&quot;median_house_value&quot;, cmap=plt.get_cmap(&quot;jet&quot;), colorbar=True, ) plt.legend() 这张图说明房价和位置（比如，靠海）和人口密度联系密切，这点你可能早就知道。可以使用聚类算法来检测主要的聚集，用一个新的特征值测量聚集中心的距离。海洋距离属性也可能有用，尽管北加州海岸区域的房价并不高，所以这不是一个简单的规则。&nbsp; 2.查找关联&nbsp; (1)因为数据集并不是非常大，你可以很容易地使用corr()方法计算出每对属性间的标准相关系数（也称作皮尔逊相关系数）： corr_matrix = housing.corr() corr_matrix[&quot;median_house_value&quot;].sort_values(ascending=False) 相关系数的范围是-1到1。当接近1时，意味强正相关；例如，当收入中位数增加时，房价中位数也会增加。当相关系数接近-1时，意味强负相关；你可以看到，纬度和房价中位数有轻微的负相关性（即，越往北，房价越可能降低）。最后，相关系数接近0，意味没有线性相关性。&nbsp; (2)另一种检测属性间相关系数的方法是使用Pandas的scatter_matrix函数，它能画出每个数值属性对每个其它数值属性的图。因为现在共有11个数值属性，你可以得到112=121张图，在一页上画不下，所以只关注几个和房价中位数最有可能相关的属性。 from pandas.tools.plotting import scatter_matrix attributes = [&quot;median_house_value&quot;, &quot;median_income&quot;, &quot;total_rooms&quot;, &quot;housing_median_age&quot;] scatter_matrix(housing[attributes], figsize=(12, 8)) 如果pandas将每个变量对自己作图，主对角线（左上到右下）都会是直线图。所以Pandas展示的是每个属性的柱状图（也可以是其它的，请参考Pandas文档）。 最有希望用来预测房价中位数的属性是收入中位数，因此将这张图放大： housing.plot(kind=&quot;scatter&quot;, x=&quot;median_income&quot;, y=&quot;median_house_value&quot;, alpha=0.1) plt.axis([0, 16, 0, 550000]) save_fig(&quot;income_vs_house_value_scatterplot&quot;) &nbsp; 这张图说明了几点。首先，相关性非常高；可以清晰地看到向上的趋势，并且数据点不是非常分散。第二，我们之前看到的最高价，清晰地呈现为一条位于500000美元的水平线。这张图也呈现了一些不是那么明显的直线：一条位于450000美元的直线，一条位于350000美元的直线，一条在$280000的线，和一些更靠下的线。你可能希望去除对应的分区，以防止算法重复这些巧合。 &nbsp;3.属性组合试验 给算法准备数据之前，你需要做的最后一件事是尝试多种属性组合。例如，如果你不知道某个分区有多少户，该分区的总房间数就没什么用。你真正需要的是每户有几个房间。相似的，总卧室数也不重要：你可能需要将其与房间数进行比较。每户的人口数也是一个有趣的属性组合。让我们来创建这些新的属性： housing[&quot;rooms_per_household&quot;] = housing[&quot;total_rooms&quot;]/housing[&quot;households&quot;] housing[&quot;bedrooms_per_room&quot;] = housing[&quot;total_bedrooms&quot;]/housing[&quot;total_rooms&quot;] housing[&quot;population_per_household&quot;]=housing[&quot;population&quot;]/housing[&quot;households&quot;] corr_matrix = housing.corr() corr_matrix[&quot;median_house_value&quot;].sort_values(ascending=False) &nbsp; 与总房间数或卧室数相比，新的bedrooms_per_room属性与房价中位数的关联更强。显然，卧室数/总房间数的比例越低，房价就越高。每户的房间数也比分区的总房间数的更有信息，很明显，房屋越大，房价就越高。&nbsp; 四、为机器学习算法准备数据 回到清洗训练集（通过再次复制strat_train_set），将预测量和标签分开，因为我们不想对预测量和目标值应用相同的转换（注意copy()创建了一份数据的备份，而不影响strat_train_set）： housing = strat_train_set.drop(&quot;median_house_value&quot;, axis=1) # drop labels for training set housing_labels = strat_train_set[&quot;median_house_value&quot;].copy() 1.数据清洗&nbsp; 大多机器学习算法不能处理特征丢失，因此先创建一些函数来处理特征丢失的问题。前面，你应该注意到了属性total_bedrooms有一些缺失值。有三个解决选项： 去掉对应的分区； 去掉整个属性； 进行赋值（0、平均值、中位数等等）。 用DataFrame的dropna()， drop()，和 fillna()方法，可以方便地实现： housing.dropna(subset=[&quot;total_bedrooms&quot;]) # 选项1 housing.drop(&quot;total_bedrooms&quot;, axis=1) # 选项2 median = housing[&quot;total_bedrooms&quot;].median() housing[&quot;total_bedrooms&quot;].fillna(median) # 选项3 如果选择选项3，你需要计算训练集的中位数，用中位数填充训练集的缺失值，不要忘记保存该中位数。后面用测试集评估系统时，需要替换测试集中的缺失值，也可以用来实时替换新数据中的缺失值。 Scikit-Learn提供了一个方便的类来处理缺失值：Imputer。下面是其使用方法：首先，需要创建一个Imputer实例，指定用该属性的中位数替换它的每个缺失值： from sklearn.preprocessing import Imputer imputer = Imputer(strategy=&quot;median&quot;) 因为只有数值属性才能算出中位数，我们需要创建一份不包括文本属性ocean_proximity的数据副本： housing_num = housing.drop(&quot;ocean_proximity&quot;, axis=1) &nbsp;现在，就可以用fit()方法将imputer实例拟合到训练数据： imputer.fit(housing_num) imputer计算出了每个属性的中位数，并将结果保存在了实例变量statistics_中。只有属性total_bedrooms有缺失值，但是我们要确保一旦系统运行起来，新的数据中没有缺失值，所以安全的做法是将imputer应用到每个数值。使用这个“训练过的”imputer来对训练集进行转换，通过将缺失值替换为中位数： X = imputer.transform(housing_num) &nbsp;结果是一个普通的Numpy数组，包含有转换后的特征。如果你想将其放回到Pandas DataFrame中，也很简单： housing_tr = pd.DataFrame(X, columns=housing_num.columns) 2.处理文本和分类属性&nbsp; 我们丢弃了分类属性ocean_proximity，因为它是一个文本属性，不能计算出中位数。大多数机器学习算法更喜欢和数字打交道，所以让我们把这些文本标签转换为数字。 Scikit-Learn为这个任务提供了一个转换量LabelEncoder： housing_cat = housing[[&#39;ocean_proximity&#39;]] from sklearn.preprocessing import OrdinalEncoder ordinal_encoder = OrdinalEncoder() housing_cat_encoded = ordinal_encoder.fit_transform(housing_cat) 查看映射表，编码器是通过属性classes_来学习的（“&lt;1H OCEAN”被映射为0，“INLAND”被映射为1，等等）： print(encoder.classes_) #[&#39;&lt;1H OCEAN&#39; &#39;INLAND&#39; &#39;ISLAND&#39; &#39;NEAR BAY&#39; &#39;NEAR OCEAN&#39;] 显然这样不对（比如，分类0和4比0和1更相似）。要解决这个问题，一个常见的方法是给每个分类创建一个二元属性：当分类是“&lt;1H OCEAN”，该属性为1（否则为0），当分类是“INLAND”，另一个属性等于1（否则为0），以此类推。这称作独热编码(One-Hot Encoding)，因为只有一个属性会等于1（热），其余会是0（冷）。 使用类LabelBinarizer，我们可以用一步执行这两个转换（从文本分类到整数分类，再从整数分类到独热矢量）： cat_encoder = OneHotEncoder(sparse=False) housing_cat_1hot = cat_encoder.fit_transform(housing_cat) housing_cat_1hot 3.自定义转换量&nbsp; 尽管Scikit-Learn提供了许多有用的转换量，你还是需要自己动手写转换量执行任务，比如自定义的清理操作，或属性组合。你需要让自制的转换量与Scikit-Learn组件（比如pipeline）无缝衔接工作，因为Scikit-Learn是依赖鸭子类型的（而不是继承），你所需要做的是创建一个类并执行三个方法：fit()（返回self），transform()，和fit_transform()。通过添加TransformerMixin作为基类，可以很容易地得到最后一个。另外，如果你添加BaseEstimator作为基类（且构造器中避免使用*args和**kargs），你就能得到两个额外的方法（get_params()和set_params()），二者可以方便地进行超参数自动微调。例如，一个小转换量类添加了上面讨论的属性： from sklearn.base import BaseEstimator, TransformerMixin rooms_ix, bedrooms_ix, population_ix, household_ix = 3, 4, 5, 6 class CombinedAttributesAdder(BaseEstimator, TransformerMixin): def __init__(self, add_bedrooms_per_room = True): # no *args or **kargs self.add_bedrooms_per_room = add_bedrooms_per_room def fit(self, X, y=None): return self # nothing else to do def transform(self, X, y=None): rooms_per_household = X[:, rooms_ix] / X[:, household_ix] population_per_household = X[:, population_ix] / X[:, household_ix] if self.add_bedrooms_per_room: bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix] return np.c_[X, rooms_per_household, population_per_household, bedrooms_per_room] else: return np.c_[X, rooms_per_household, population_per_household] attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=False) housing_extra_attribs = attr_adder.transform(housing.values) 4.特征缩放 数据要做的最重要的转换之一是特征缩放。除了个别情况，当输入的数值属性量度不同时，机器学习算法的性能都不会好。这个规律也适用于房产数据：总房间数分布范围是6到39320，而收入中位数只分布在0到15。不需要对目标值进行缩放。 有两种常见的方法可以让所有的属性有相同的量度：线性函数归一化（Min-Max scaling）和标准化（standardization）。 线性函数归一化（许多人称其为归一化（normalization））很简单：值被转变、重新缩放，直到范围变成0到1。我们通过减去最小值，然后再除以最大值与最小值的差值，来进行归一化。Scikit-Learn提供了一个转换量MinMaxScaler来实现这个功能。它有一个超参数feature_range，可以让你改变范围，如果不希望范围是0到1。 标准化就很不同：首先减去平均值（所以标准化值的平均值总是0），然后除以方差，使得到的分布具有单位方差。与归一化不同，标准化不会限定值到某个特定的范围，这对某些算法可能构成问题（比如，神经网络常需要输入值得范围是0到1）。但是，标准化受到异常值的影响很小。例如，假设一个分区的收入中位数是100。归一化会将其它范围是0到15的值变为0-0.15，但是标准化不会受什么影响。Scikit-Learn提供了一个转换量StandardScaler来进行标准化。 5.转换Pipeline 你已经看到，存在许多数据转换步骤，需要按一定的顺序执行。幸运的是，Scikit-Learn提供了类Pipeline，来进行这一系列的转换。下面是一个数值属性的小pipeline，将替换缺失值、添加属性、替换文本值为数值的操作结合在一起。 from sklearn.pipeline import FeatureUnion num_attribs = list(housing_num) cat_attribs = [&quot;ocean_proximity&quot;] num_pipeline = Pipeline([ (&#39;selector&#39;, DataFrameSelector(num_attribs)), (&#39;imputer&#39;, Imputer(strategy=&quot;median&quot;)), (&#39;attribs_adder&#39;, CombinedAttributesAdder()), (&#39;std_scaler&#39;, StandardScaler()), ]) cat_pipeline = Pipeline([ (&#39;selector&#39;, DataFrameSelector(cat_attribs)), (&#39;label_binarizer&#39;, LabelBinarizer()), ]) full_pipeline = FeatureUnion(transformer_list=[ (&quot;num_pipeline&quot;, num_pipeline), (&quot;cat_pipeline&quot;, cat_pipeline), ]) housing_prepared = full_pipeline.fit_transform(housing) housing_prepared.shape #(16513, 17) 五、选择模型，进行训练 1.在训练集上训练和评估 (1)线性回归模型 from sklearn.linear_model import LinearRegression lin_reg = LinearRegression() lin_reg.fit(housing_prepared, housing_labels) 使用Scikit-Learn的mean_squared_error函数，用全部训练集来计算下这个回归模型的RMSE： from sklearn.metrics import mean_squared_error housing_predictions = lin_reg.predict(housing_prepared) lin_mse = mean_squared_error(housing_labels, housing_predictions) lin_rmse = np.sqrt(lin_mse) lin_rmse #68628.19819848922 大多数分区的median_housing_values位于120000美元到265000美元之间，因此预测误差$68628不能让人满意。这是一个模型欠拟合训练数据的例子。当这种情况发生时，意味着特征没有提供足够多的信息来做出一个好的预测，或者模型并不强大。就像前一章看到的，修复欠拟合的主要方法是选择一个更强大的模型，给训练算法提供更好的特征，或去掉模型上的限制。这个模型还没有正则化，所以排除了最后一个选项。你可以尝试添加更多特征（比如，人口的对数值），但是首先让我们尝试一个更为复杂的模型，看看效果。 (2)决策树 训练一个DecisionTreeRegressor。这是一个强大的模型，可以发现数据中复杂的非线性关系。代码： from sklearn.tree import DecisionTreeRegressor tree_reg = DecisionTreeRegressor(random_state=42) tree_reg.fit(housing_prepared, housing_labels) housing_predictions = tree_reg.predict(housing_prepared) tree_mse = mean_squared_error(housing_labels, housing_predictions) tree_rmse = np.sqrt(tree_mse) tree_rmse #0.0 &nbsp;没有误差？这个模型可能是绝对完美的吗？当然，更大可能性是这个模型严重过拟合数据。 2.使用交叉验证做更佳的评估 评估决策树模型的一种方法是用函数train_test_split来分割训练集，得到一个更小的训练集和一个验证集，然后用更小的训练集来训练模型，用验证集来评估。这需要一定工作量，并不难而且也可行。 另一种更好的方法是使用Scikit-Learn的交叉验证功能。下面的代码采用了K折交叉验证（K-fold cross-validation）：它随机地将训练集分成十个不同的子集，成为“折”，然后训练评估决策树模型10次，每次选一个不用的折来做评估，用其它9个来做训练。结果是一个包含10个评分的数组： from sklearn.model_selection import cross_val_score scores = cross_val_score(tree_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) tree_rmse_scores = np.sqrt(-scores) &nbsp;决策树的结果： def display_scores(scores): print(&quot;Scores:&quot;, scores) print(&quot;Mean:&quot;, scores.mean()) print(&quot;Standard deviation:&quot;, scores.std()) display_scores(tree_rmse_scores) 计算线性回归模型的的相同分数&nbsp;： lin_scores = cross_val_score(lin_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) lin_rmse_scores = np.sqrt(-lin_scores) display_scores(lin_rmse_scores) 判断没错：决策树模型过拟合很严重，它的性能比线性回归模型还差。 3.尝试新方法：随机森林&nbsp; from sklearn.ensemble import RandomForestRegressor forest_reg = RandomForestRegressor(n_estimators=10, random_state=42) forest_reg.fit(housing_prepared, housing_labels) from sklearn.model_selection import cross_val_score forest_scores = cross_val_score(forest_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) forest_rmse_scores = np.sqrt(-forest_scores) display_scores(forest_rmse_scores) &nbsp; 随机森林看起来很有希望。但是，训练集的评分仍然比验证集的评分低很多。解决过拟合可以通过简化模型，给模型加限制（即，规整化），或用更多的训练数据。&nbsp; 六、微调模型 1.网格搜索 微调的一种方法是手工调整超参数，直到找到一个好的超参数组合。这么做的话会非常冗长，你也可能没有时间探索多种组合。 你应该使用Scikit-Learn的GridSearchCV来做这项搜索工作。你所需要做的是告诉GridSearchCV要试验有哪些超参数，要试验什么值，GridSearchCV就能用交叉验证试验所有可能超参数值的组合。例如，下面的代码搜索了RandomForestRegressor超参数值的最佳组合： from sklearn.model_selection import GridSearchCV param_grid = [ {&#39;n_estimators&#39;: [3, 10, 30], &#39;max_features&#39;: [2, 4, 6, 8]}, {&#39;bootstrap&#39;: [False], &#39;n_estimators&#39;: [3, 10], &#39;max_features&#39;: [2, 3, 4]}, ] forest_reg = RandomForestRegressor() grid_search = GridSearchCV(forest_reg, param_grid, cv=5, scoring=&#39;neg_mean_squared_error&#39;) grid_search.fit(housing_prepared, housing_labels) param_grid告诉Scikit-Learn首先评估所有的列在第一个dict中的n_estimators和max_features的3 × 4 = 12种组合（不用担心这些超参数的含义，会在第7章中解释）。然后尝试第二个dict中超参数的2 × 3 = 6种组合，这次会将超参数bootstrap设为False而不是True（后者是该超参数的默认值）。总之，网格搜索会探索12 + 6 = 18种RandomForestRegressor的超参数组合，会训练每个模型五次（因为用的是五折交叉验证）。换句话说，训练总共有18 × 5 = 90轮！折将要花费大量时间，完成后，你就能获得参数的最佳组合。 grid_search.best_params_ 还能直接得到最佳的估计量： grid_search.best_estimator_ &nbsp;也可以得到评估值： cvres = grid_search.cv_results_ for mean_score, params in zip(cvres[&quot;mean_test_score&quot;], cvres[&quot;params&quot;]): print(np.sqrt(-mean_score), params) 2.随机搜索 当探索相对较少的组合时，就像前面的例子，网格搜索还可以。但是当超参数的搜索空间很大时，最好使用RandomizedSearchCV。这个类的使用方法和类GridSearchCV很相似，但它不是尝试所有可能的组合，而是通过选择每个超参数的一个随机值的特定数量的随机组合。这个方法有两个优点： 如果你让随机搜索运行，比如1000次，它会探索每个超参数的1000个不同的值（而不是像网格搜索那样，只搜索每个超参数的几个值）。 你可以方便地通过设定搜索次数，控制超参数搜索的计算量。 3.集成方法 另一种微调系统的方法是将表现最好的模型组合起来。组合（集成）之后的性能通常要比单独的模型要好（就像随机森林要比单独的决策树要好），特别是当单独模型的误差类型不同时。 4.分析最佳模型和它们的误差 通过分析最佳模型，常常可以获得对问题更深的了解。比如，RandomForestRegressor可以指出每个属性对于做出准确预测的相对重要性： feature_importances = grid_search.best_estimator_.feature_importances_ &nbsp;&nbsp; 将重要性分数和属性名放到一起：&nbsp; extra_attribs = [&quot;rooms_per_hhold&quot;, &quot;pop_per_hhold&quot;, &quot;bedrooms_per_room&quot;] #cat_encoder = cat_pipeline.named_steps[&quot;cat_encoder&quot;] # old solution cat_encoder = full_pipeline.named_transformers_[&quot;cat&quot;] cat_one_hot_attribs = list(cat_encoder.categories_[0]) attributes = num_attribs + extra_attribs + cat_one_hot_attribs sorted(zip(feature_importances, attributes), reverse=True) &nbsp;有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类ocean_proximity就够了，所以可以丢弃掉其它的）。 有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类ocean_proximity就够了，所以可以丢弃掉其它的）。&nbsp; 七、给出解决方案 用测试集评估系统： 调节完系统之后，你终于有了一个性能足够好的系统。现在就可以用测试集评估最后的模型了。这个过程没有什么特殊的：从测试集得到预测值和标签，运行full_pipeline转换数据（调用transform()，而不是fit_transform()！），再用测试集评估最终模型： final_model = grid_search.best_estimator_ X_test = strat_test_set.drop(&quot;median_house_value&quot;, axis=1) y_test = strat_test_set[&quot;median_house_value&quot;].copy() X_test_prepared = full_pipeline.transform(X_test) final_predictions = final_model.predict(X_test_prepared) final_mse = mean_squared_error(y_test, final_predictions) final_rmse = np.sqrt(final_mse) #47730.22690385927 八、部署、监控、维护系统 很好，你被允许启动系统了！你需要为实际生产做好准备，特别是接入输入数据源，并编写测试。 你还需要编写监控代码，以固定间隔检测系统的实时表现，当发生下降时触发报警。这对于捕获突然的系统崩溃和性能下降十分重要。做监控很常见，是因为模型会随着数据的演化而性能下降，除非模型用新数据定期训练。 评估系统的表现需要对预测值采样并进行评估。这通常需要人来分析。分析者可能是领域专家，或者是众包平台（比如Amazon Mechanical Turk 或 CrowdFlower）的工人。不管采用哪种方法，你都需要将人工评估的pipeline植入系统。 你还要评估系统输入数据的质量。有时因为低质量的信号（比如失灵的传感器发送随机值，或另一个团队的输出停滞），系统的表现会逐渐变差，但可能需要一段时间，系统的表现才能下降到一定程度，触发警报。如果监测了系统的输入，你就可能尽量早的发现问题。对于线上学习系统，监测输入数据是非常重要的。 最后，你可能想定期用新数据训练模型。你应该尽可能自动化这个过程。如果不这么做，非常有可能你需要每隔至少六个月更新模型，系统的表现就会产生严重波动。如果你的系统是一个线上学习系统，你需要定期保存系统状态快照，好能方便地回滚到之前的工作状态。 &nbsp; 完结！ 参考书籍《Scikit-Learn与TensorFlow机器学习实用指南》的第02、03章。 完整的代码https://github.com/ageron/handson-ml" />
<meta property="og:description" content="本部分，我们会作为被一家地产公司雇佣的数据科学家，完整地学习一个项目。下面是主要步骤： 项目概述。 获取数据。 发现并可视化数据，发现规律。 为机器学习算法准备数据。 选择模型，进行训练。 微调模型。 给出解决方案。 部署、监控、维护系统。 一、项目概述 任务是利用加州普查数据，建立一个加州房价模型。这个数据包含每个分区组的人口、收入中位数、房价中位数等指标。分区组是美国调查局发布样本数据的最小地理单位（一个分区通常有600到3000人）。我们将其简称为“分区”。你的模型要利用这个数据进行学习，然后根据其它指标，预测任何分区的的房价中位数。 1.划定问题 首先，你需要划定问题：监督或非监督，还是强化学习？这是个分类任务、回归任务，还是其它的？要使用批量学习还是线上学习？ 答：这是一个典型的监督学习任务，因为你要使用的是有标签的训练样本（每个实例都有预定的产出，即分区的房价中位数）。并且，这是一个典型的回归任务，因为你要预测一个值。讲的更细些，这是一个多变量回归问题，因为系统要使用多个变量进行预测（要使用分区的人口，收入中位数等等）。最后，没有连续的数据流进入系统，没有特别需求需要对数据变动作出快速适应。数据量不大可以放到内存中，因此批量学习就够了。 2.选择性能指标 下一步是选择性能指标。回归问题的典型指标是均方根误差（RMSE）。均方根误差测量的是系统预测误差的标准差。计算RMSE的计算方法如下： 虽然大多数时候RMSE是回归任务可靠的性能指标，在有些情况下，你可能需要另外的函数。例如，假设存在许多异常的分区。此时，你可能需要使用绝对平均误差（Mean Absolute Error，也称作平均绝对偏差。MAE的计算如下： 二、获取数据 1.创建工作环境 我的工作环境是Jupyter notebook，使用python3.0版本，安装Python模块：Jupyter、NumPy、Pandas、Matplotlib和Scikit-Learn。 2.下载数据 import os import tarfile from six.moves import urllib DOWNLOAD_ROOT = &quot;https://raw.githubusercontent.com/ageron/handson-ml/master/&quot; HOUSING_PATH = &quot;datasets/housing&quot; HOUSING_URL = DOWNLOAD_ROOT + HOUSING_PATH + &quot;/housing.tgz&quot; def fetch_housing_data(housing_url=HOUSING_URL, housing_path=HOUSING_PATH): if not os.path.isdir(housing_path): os.makedirs(housing_path) tgz_path = os.path.join(housing_path, &quot;housing.tgz&quot;) urllib.request.urlretrieve(housing_url, tgz_path) housing_tgz = tarfile.open(tgz_path) housing_tgz.extractall(path=housing_path) housing_tgz.close() fetch_housing_data() 然后使用Pandas加载数据:&nbsp; import pandas as pd def load_housing_data(housing_path=HOUSING_PATH): csv_path = os.path.join(housing_path, &quot;housing.csv&quot;) return pd.read_csv(csv_path) 3.查看数据结构 使用DataFrame的head()方法查看该数据集的顶部5行。 housing = load_housing_data() housing.head() 每一行都表示一个分区。共有10个属性（截图中可以看到6个）：经度、维度、房屋年龄中位数、总房间数、卧室数量、人口数、家庭数、收入中位数、房屋价值中位数、大海距离。 info()方法可以快速查看数据的描述，包括总行数、每个属性的类型和非空值的数量。 housing.info() 所有的属性都是数值的，除了大海距离这项。它的类型是对象，因此可以包含任意Python对象，但是因为是从CSV文件加载的，所以必然是文本。当查看顶部的五行时，你可能注意到那一列的值是重复的，意味着它可能是一个分类属性。可以使用value_counts()方法查看都有什么类型，每个类都有多少分区： housing[&quot;ocean_proximity&quot;].value_counts() &nbsp; describe()方法展示了数值属性的概括: housing.describe() count、mean、min和max几行的意思很明了。注意，空值被忽略了（所以，卧室总数是20433而不是20640）。std是标准差（揭示数值的分散度）。25%、50%、75%展示了对应的分位数：每个分位数指明小于这个值，且指定分组的百分比。例如，25%的分区的房屋年龄中位数小于18，而50%的小于29，75%的小于37。 另一种快速了解数据类型的方法是画出每个数值属性的柱状图。柱状图（的纵轴）展示了特定范围的实例的个数。你还可以一次给一个属性画图，或对完整数据集调用hist()方法，后者会画出每个数值属性的柱状图。 4.创建测试集 纯随机采样测试集 (1)自己编写代码，设置随机数生成器的种子（比如np.random.seed(42)），以产生总是相同的混合指数（shuffled indices） # to make this notebook&#39;s output identical at every run np.random.seed(42) import numpy as np def split_train_test(data, test_ratio): shuffled_indices = np.random.permutation(len(data)) test_set_size = int(len(data) * test_ratio) test_indices = shuffled_indices[:test_set_size] train_indices = shuffled_indices[test_set_size:] return data.iloc[train_indices], data.iloc[test_indices] train_set, test_set = split_train_test(housing, 0.2) print(len(train_set), &quot;train +&quot;, len(test_set), &quot;test&quot;) &nbsp;(2)使用hash import hashlib def test_set_check(identifier, test_ratio, hash): return hash(np.int64(identifier)).digest()[-1] &lt; 256 * test_ratio def split_train_test_by_id(data, test_ratio, id_column, hash=hashlib.md5): ids = data[id_column] in_test_set = ids.apply(lambda id_: test_set_check(id_, test_ratio, hash)) return data.loc[~in_test_set], data.loc[in_test_set] housing_with_id = housing.reset_index() # adds an `index` column train_set, test_set = split_train_test_by_id(housing_with_id, 0.2, &quot;index&quot;) &nbsp;如果使用行索引作为唯一识别码，你需要保证新数据放到现有数据的尾部，且没有行被深处。如果做不到，则可以用最稳定的特征来创建唯一识别码。例如，一个区的维度和经度在几百万年之内是不变的，所以可以将两者结合成一个ID： housing_with_id[&quot;id&quot;] = housing[&quot;longitude&quot;] * 1000 + housing[&quot;latitude&quot;] train_set, test_set = split_train_test_by_id(housing_with_id, 0.2, &quot;id&quot;) (3)sklearn实现 from sklearn.model_selection import train_test_split train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42) 分层采样的测试集 当你的数据集很大时（尤其是和属性数相比），这通常可行；但如果数据集不大，就会有采样偏差的风险。当一个调查公司想要对1000个人进行调查，它们不是在电话亭里随机选1000个人出来。调查公司要保证这1000个人对人群整体有代表性。例如，美国人口的51.3%是女性，48.7%是男性。所以在美国，严谨的调查需要保证样本也是这个比例：513名女性，487名男性。这称作分层采样（stratified sampling）：将人群分成均匀的子分组，称为分层，从每个分层取出合适数量的实例，以保证测试集对总人数有代表性。 假设专家告诉你，收入中位数是预测房价中位数非常重要的属性。你可能想要保证测试集可以代表整体数据集中的多种收入分类。因为收入中位数是一个连续的数值属性，你首先需要创建一个收入分类属性。大多数的收入中位数的值聚集在2-5（一万美元），但是一些收入中位数会超过6。数据集中的每个分层都要有足够的实例位于你的数据中，这点很重要。否则，对分层重要性的评估就会有偏差。这意味着，你不能有过多的分层，且每个分层都要足够大。后面的代码通过将收入中位数除以1.5（以限制收入分类的数量），创建了一个收入分类属性，用ceil对值舍入（以产生离散的分类），然后将所有大于5的分类归入到分类5： housing[&quot;income_cat&quot;] = np.ceil(housing[&quot;median_income&quot;] / 1.5) housing[&quot;income_cat&quot;].where(housing[&quot;income_cat&quot;] &lt; 5, 5.0, inplace=True) 根据收入分类，使用Scikit-Learn的StratifiedShuffleSplit类进行分层采样: from sklearn.model_selection import StratifiedShuffleSplit split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42) for train_index, test_index in split.split(housing, housing[&quot;income_cat&quot;]): strat_train_set = housing.loc[train_index] strat_test_set = housing.loc[test_index] &nbsp;在测试集和完整的房产数据集中查看收入分类比例： strat_test_set[&quot;income_cat&quot;].value_counts() / len(strat_test_set) housing[&quot;income_cat&quot;].value_counts() / len(housing) &nbsp; 对比了总数据集、分层采样的测试集、纯随机采样测试集的收入分类比例。可以看到，分层采样测试集的收入分类比例与总数据集几乎相同，而随机采样数据集偏差严重。 def income_cat_proportions(data): return data[&quot;income_cat&quot;].value_counts() / len(data) train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42) compare_props = pd.DataFrame({ &quot;Overall&quot;: income_cat_proportions(housing), &quot;Stratified&quot;: income_cat_proportions(strat_test_set), &quot;Random&quot;: income_cat_proportions(test_set), }).sort_index() compare_props[&quot;Rand. %error&quot;] = 100 * compare_props[&quot;Random&quot;] / compare_props[&quot;Overall&quot;] - 100 compare_props[&quot;Strat. %error&quot;] = 100 * compare_props[&quot;Stratified&quot;] / compare_props[&quot;Overall&quot;] - 100 compare_props 删除income_cat属性，使数据回到初始状态： for set_ in (strat_train_set, strat_test_set): set_.drop(&quot;income_cat&quot;, axis=1, inplace=True) &nbsp;我们用了大量时间来生成测试集的原因是：测试集通常被忽略，但实际是机器学习非常重要的一部分。还有，生成测试集过程中的许多思路对于后面的交叉验证讨论是非常有帮助的。 三、发现并可视化数据，发现规律 首先，保证你将测试集放在了一旁，只是研究训练集。另外，如果训练集非常大，你可能需要再采样一个探索集，保证操作方便快速。在我们的案例中，数据集很小，所以可以在全集上直接工作。创建一个副本，以免损伤训练集： housing = strat_train_set.copy() 1.地理数据可视化&nbsp; 因为存在地理信息（纬度和经度），创建一个所有分区的散点图来数据可视化是一个不错的主意。 housing.plot(kind=&quot;scatter&quot;, x=&quot;longitude&quot;, y=&quot;latitude&quot;, alpha=0.1) 可以非常清楚地看到高密度区域，湾区、洛杉矶和圣迭戈，以及中央谷，特别是从萨克拉门托到弗雷斯诺。现在来看房价，每个圈的半径表示分区的人口（选项s），颜色代表价格（选项c）。我们用预先定义的颜色图（选项cmap）jet，它的范围是从蓝色（低价）到红色（高价）：&nbsp; housing.plot(kind=&quot;scatter&quot;, x=&quot;longitude&quot;, y=&quot;latitude&quot;, alpha=0.4, s=housing[&quot;population&quot;]/100, label=&quot;population&quot;, c=&quot;median_house_value&quot;, cmap=plt.get_cmap(&quot;jet&quot;), colorbar=True, ) plt.legend() 这张图说明房价和位置（比如，靠海）和人口密度联系密切，这点你可能早就知道。可以使用聚类算法来检测主要的聚集，用一个新的特征值测量聚集中心的距离。海洋距离属性也可能有用，尽管北加州海岸区域的房价并不高，所以这不是一个简单的规则。&nbsp; 2.查找关联&nbsp; (1)因为数据集并不是非常大，你可以很容易地使用corr()方法计算出每对属性间的标准相关系数（也称作皮尔逊相关系数）： corr_matrix = housing.corr() corr_matrix[&quot;median_house_value&quot;].sort_values(ascending=False) 相关系数的范围是-1到1。当接近1时，意味强正相关；例如，当收入中位数增加时，房价中位数也会增加。当相关系数接近-1时，意味强负相关；你可以看到，纬度和房价中位数有轻微的负相关性（即，越往北，房价越可能降低）。最后，相关系数接近0，意味没有线性相关性。&nbsp; (2)另一种检测属性间相关系数的方法是使用Pandas的scatter_matrix函数，它能画出每个数值属性对每个其它数值属性的图。因为现在共有11个数值属性，你可以得到112=121张图，在一页上画不下，所以只关注几个和房价中位数最有可能相关的属性。 from pandas.tools.plotting import scatter_matrix attributes = [&quot;median_house_value&quot;, &quot;median_income&quot;, &quot;total_rooms&quot;, &quot;housing_median_age&quot;] scatter_matrix(housing[attributes], figsize=(12, 8)) 如果pandas将每个变量对自己作图，主对角线（左上到右下）都会是直线图。所以Pandas展示的是每个属性的柱状图（也可以是其它的，请参考Pandas文档）。 最有希望用来预测房价中位数的属性是收入中位数，因此将这张图放大： housing.plot(kind=&quot;scatter&quot;, x=&quot;median_income&quot;, y=&quot;median_house_value&quot;, alpha=0.1) plt.axis([0, 16, 0, 550000]) save_fig(&quot;income_vs_house_value_scatterplot&quot;) &nbsp; 这张图说明了几点。首先，相关性非常高；可以清晰地看到向上的趋势，并且数据点不是非常分散。第二，我们之前看到的最高价，清晰地呈现为一条位于500000美元的水平线。这张图也呈现了一些不是那么明显的直线：一条位于450000美元的直线，一条位于350000美元的直线，一条在$280000的线，和一些更靠下的线。你可能希望去除对应的分区，以防止算法重复这些巧合。 &nbsp;3.属性组合试验 给算法准备数据之前，你需要做的最后一件事是尝试多种属性组合。例如，如果你不知道某个分区有多少户，该分区的总房间数就没什么用。你真正需要的是每户有几个房间。相似的，总卧室数也不重要：你可能需要将其与房间数进行比较。每户的人口数也是一个有趣的属性组合。让我们来创建这些新的属性： housing[&quot;rooms_per_household&quot;] = housing[&quot;total_rooms&quot;]/housing[&quot;households&quot;] housing[&quot;bedrooms_per_room&quot;] = housing[&quot;total_bedrooms&quot;]/housing[&quot;total_rooms&quot;] housing[&quot;population_per_household&quot;]=housing[&quot;population&quot;]/housing[&quot;households&quot;] corr_matrix = housing.corr() corr_matrix[&quot;median_house_value&quot;].sort_values(ascending=False) &nbsp; 与总房间数或卧室数相比，新的bedrooms_per_room属性与房价中位数的关联更强。显然，卧室数/总房间数的比例越低，房价就越高。每户的房间数也比分区的总房间数的更有信息，很明显，房屋越大，房价就越高。&nbsp; 四、为机器学习算法准备数据 回到清洗训练集（通过再次复制strat_train_set），将预测量和标签分开，因为我们不想对预测量和目标值应用相同的转换（注意copy()创建了一份数据的备份，而不影响strat_train_set）： housing = strat_train_set.drop(&quot;median_house_value&quot;, axis=1) # drop labels for training set housing_labels = strat_train_set[&quot;median_house_value&quot;].copy() 1.数据清洗&nbsp; 大多机器学习算法不能处理特征丢失，因此先创建一些函数来处理特征丢失的问题。前面，你应该注意到了属性total_bedrooms有一些缺失值。有三个解决选项： 去掉对应的分区； 去掉整个属性； 进行赋值（0、平均值、中位数等等）。 用DataFrame的dropna()， drop()，和 fillna()方法，可以方便地实现： housing.dropna(subset=[&quot;total_bedrooms&quot;]) # 选项1 housing.drop(&quot;total_bedrooms&quot;, axis=1) # 选项2 median = housing[&quot;total_bedrooms&quot;].median() housing[&quot;total_bedrooms&quot;].fillna(median) # 选项3 如果选择选项3，你需要计算训练集的中位数，用中位数填充训练集的缺失值，不要忘记保存该中位数。后面用测试集评估系统时，需要替换测试集中的缺失值，也可以用来实时替换新数据中的缺失值。 Scikit-Learn提供了一个方便的类来处理缺失值：Imputer。下面是其使用方法：首先，需要创建一个Imputer实例，指定用该属性的中位数替换它的每个缺失值： from sklearn.preprocessing import Imputer imputer = Imputer(strategy=&quot;median&quot;) 因为只有数值属性才能算出中位数，我们需要创建一份不包括文本属性ocean_proximity的数据副本： housing_num = housing.drop(&quot;ocean_proximity&quot;, axis=1) &nbsp;现在，就可以用fit()方法将imputer实例拟合到训练数据： imputer.fit(housing_num) imputer计算出了每个属性的中位数，并将结果保存在了实例变量statistics_中。只有属性total_bedrooms有缺失值，但是我们要确保一旦系统运行起来，新的数据中没有缺失值，所以安全的做法是将imputer应用到每个数值。使用这个“训练过的”imputer来对训练集进行转换，通过将缺失值替换为中位数： X = imputer.transform(housing_num) &nbsp;结果是一个普通的Numpy数组，包含有转换后的特征。如果你想将其放回到Pandas DataFrame中，也很简单： housing_tr = pd.DataFrame(X, columns=housing_num.columns) 2.处理文本和分类属性&nbsp; 我们丢弃了分类属性ocean_proximity，因为它是一个文本属性，不能计算出中位数。大多数机器学习算法更喜欢和数字打交道，所以让我们把这些文本标签转换为数字。 Scikit-Learn为这个任务提供了一个转换量LabelEncoder： housing_cat = housing[[&#39;ocean_proximity&#39;]] from sklearn.preprocessing import OrdinalEncoder ordinal_encoder = OrdinalEncoder() housing_cat_encoded = ordinal_encoder.fit_transform(housing_cat) 查看映射表，编码器是通过属性classes_来学习的（“&lt;1H OCEAN”被映射为0，“INLAND”被映射为1，等等）： print(encoder.classes_) #[&#39;&lt;1H OCEAN&#39; &#39;INLAND&#39; &#39;ISLAND&#39; &#39;NEAR BAY&#39; &#39;NEAR OCEAN&#39;] 显然这样不对（比如，分类0和4比0和1更相似）。要解决这个问题，一个常见的方法是给每个分类创建一个二元属性：当分类是“&lt;1H OCEAN”，该属性为1（否则为0），当分类是“INLAND”，另一个属性等于1（否则为0），以此类推。这称作独热编码(One-Hot Encoding)，因为只有一个属性会等于1（热），其余会是0（冷）。 使用类LabelBinarizer，我们可以用一步执行这两个转换（从文本分类到整数分类，再从整数分类到独热矢量）： cat_encoder = OneHotEncoder(sparse=False) housing_cat_1hot = cat_encoder.fit_transform(housing_cat) housing_cat_1hot 3.自定义转换量&nbsp; 尽管Scikit-Learn提供了许多有用的转换量，你还是需要自己动手写转换量执行任务，比如自定义的清理操作，或属性组合。你需要让自制的转换量与Scikit-Learn组件（比如pipeline）无缝衔接工作，因为Scikit-Learn是依赖鸭子类型的（而不是继承），你所需要做的是创建一个类并执行三个方法：fit()（返回self），transform()，和fit_transform()。通过添加TransformerMixin作为基类，可以很容易地得到最后一个。另外，如果你添加BaseEstimator作为基类（且构造器中避免使用*args和**kargs），你就能得到两个额外的方法（get_params()和set_params()），二者可以方便地进行超参数自动微调。例如，一个小转换量类添加了上面讨论的属性： from sklearn.base import BaseEstimator, TransformerMixin rooms_ix, bedrooms_ix, population_ix, household_ix = 3, 4, 5, 6 class CombinedAttributesAdder(BaseEstimator, TransformerMixin): def __init__(self, add_bedrooms_per_room = True): # no *args or **kargs self.add_bedrooms_per_room = add_bedrooms_per_room def fit(self, X, y=None): return self # nothing else to do def transform(self, X, y=None): rooms_per_household = X[:, rooms_ix] / X[:, household_ix] population_per_household = X[:, population_ix] / X[:, household_ix] if self.add_bedrooms_per_room: bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix] return np.c_[X, rooms_per_household, population_per_household, bedrooms_per_room] else: return np.c_[X, rooms_per_household, population_per_household] attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=False) housing_extra_attribs = attr_adder.transform(housing.values) 4.特征缩放 数据要做的最重要的转换之一是特征缩放。除了个别情况，当输入的数值属性量度不同时，机器学习算法的性能都不会好。这个规律也适用于房产数据：总房间数分布范围是6到39320，而收入中位数只分布在0到15。不需要对目标值进行缩放。 有两种常见的方法可以让所有的属性有相同的量度：线性函数归一化（Min-Max scaling）和标准化（standardization）。 线性函数归一化（许多人称其为归一化（normalization））很简单：值被转变、重新缩放，直到范围变成0到1。我们通过减去最小值，然后再除以最大值与最小值的差值，来进行归一化。Scikit-Learn提供了一个转换量MinMaxScaler来实现这个功能。它有一个超参数feature_range，可以让你改变范围，如果不希望范围是0到1。 标准化就很不同：首先减去平均值（所以标准化值的平均值总是0），然后除以方差，使得到的分布具有单位方差。与归一化不同，标准化不会限定值到某个特定的范围，这对某些算法可能构成问题（比如，神经网络常需要输入值得范围是0到1）。但是，标准化受到异常值的影响很小。例如，假设一个分区的收入中位数是100。归一化会将其它范围是0到15的值变为0-0.15，但是标准化不会受什么影响。Scikit-Learn提供了一个转换量StandardScaler来进行标准化。 5.转换Pipeline 你已经看到，存在许多数据转换步骤，需要按一定的顺序执行。幸运的是，Scikit-Learn提供了类Pipeline，来进行这一系列的转换。下面是一个数值属性的小pipeline，将替换缺失值、添加属性、替换文本值为数值的操作结合在一起。 from sklearn.pipeline import FeatureUnion num_attribs = list(housing_num) cat_attribs = [&quot;ocean_proximity&quot;] num_pipeline = Pipeline([ (&#39;selector&#39;, DataFrameSelector(num_attribs)), (&#39;imputer&#39;, Imputer(strategy=&quot;median&quot;)), (&#39;attribs_adder&#39;, CombinedAttributesAdder()), (&#39;std_scaler&#39;, StandardScaler()), ]) cat_pipeline = Pipeline([ (&#39;selector&#39;, DataFrameSelector(cat_attribs)), (&#39;label_binarizer&#39;, LabelBinarizer()), ]) full_pipeline = FeatureUnion(transformer_list=[ (&quot;num_pipeline&quot;, num_pipeline), (&quot;cat_pipeline&quot;, cat_pipeline), ]) housing_prepared = full_pipeline.fit_transform(housing) housing_prepared.shape #(16513, 17) 五、选择模型，进行训练 1.在训练集上训练和评估 (1)线性回归模型 from sklearn.linear_model import LinearRegression lin_reg = LinearRegression() lin_reg.fit(housing_prepared, housing_labels) 使用Scikit-Learn的mean_squared_error函数，用全部训练集来计算下这个回归模型的RMSE： from sklearn.metrics import mean_squared_error housing_predictions = lin_reg.predict(housing_prepared) lin_mse = mean_squared_error(housing_labels, housing_predictions) lin_rmse = np.sqrt(lin_mse) lin_rmse #68628.19819848922 大多数分区的median_housing_values位于120000美元到265000美元之间，因此预测误差$68628不能让人满意。这是一个模型欠拟合训练数据的例子。当这种情况发生时，意味着特征没有提供足够多的信息来做出一个好的预测，或者模型并不强大。就像前一章看到的，修复欠拟合的主要方法是选择一个更强大的模型，给训练算法提供更好的特征，或去掉模型上的限制。这个模型还没有正则化，所以排除了最后一个选项。你可以尝试添加更多特征（比如，人口的对数值），但是首先让我们尝试一个更为复杂的模型，看看效果。 (2)决策树 训练一个DecisionTreeRegressor。这是一个强大的模型，可以发现数据中复杂的非线性关系。代码： from sklearn.tree import DecisionTreeRegressor tree_reg = DecisionTreeRegressor(random_state=42) tree_reg.fit(housing_prepared, housing_labels) housing_predictions = tree_reg.predict(housing_prepared) tree_mse = mean_squared_error(housing_labels, housing_predictions) tree_rmse = np.sqrt(tree_mse) tree_rmse #0.0 &nbsp;没有误差？这个模型可能是绝对完美的吗？当然，更大可能性是这个模型严重过拟合数据。 2.使用交叉验证做更佳的评估 评估决策树模型的一种方法是用函数train_test_split来分割训练集，得到一个更小的训练集和一个验证集，然后用更小的训练集来训练模型，用验证集来评估。这需要一定工作量，并不难而且也可行。 另一种更好的方法是使用Scikit-Learn的交叉验证功能。下面的代码采用了K折交叉验证（K-fold cross-validation）：它随机地将训练集分成十个不同的子集，成为“折”，然后训练评估决策树模型10次，每次选一个不用的折来做评估，用其它9个来做训练。结果是一个包含10个评分的数组： from sklearn.model_selection import cross_val_score scores = cross_val_score(tree_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) tree_rmse_scores = np.sqrt(-scores) &nbsp;决策树的结果： def display_scores(scores): print(&quot;Scores:&quot;, scores) print(&quot;Mean:&quot;, scores.mean()) print(&quot;Standard deviation:&quot;, scores.std()) display_scores(tree_rmse_scores) 计算线性回归模型的的相同分数&nbsp;： lin_scores = cross_val_score(lin_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) lin_rmse_scores = np.sqrt(-lin_scores) display_scores(lin_rmse_scores) 判断没错：决策树模型过拟合很严重，它的性能比线性回归模型还差。 3.尝试新方法：随机森林&nbsp; from sklearn.ensemble import RandomForestRegressor forest_reg = RandomForestRegressor(n_estimators=10, random_state=42) forest_reg.fit(housing_prepared, housing_labels) from sklearn.model_selection import cross_val_score forest_scores = cross_val_score(forest_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) forest_rmse_scores = np.sqrt(-forest_scores) display_scores(forest_rmse_scores) &nbsp; 随机森林看起来很有希望。但是，训练集的评分仍然比验证集的评分低很多。解决过拟合可以通过简化模型，给模型加限制（即，规整化），或用更多的训练数据。&nbsp; 六、微调模型 1.网格搜索 微调的一种方法是手工调整超参数，直到找到一个好的超参数组合。这么做的话会非常冗长，你也可能没有时间探索多种组合。 你应该使用Scikit-Learn的GridSearchCV来做这项搜索工作。你所需要做的是告诉GridSearchCV要试验有哪些超参数，要试验什么值，GridSearchCV就能用交叉验证试验所有可能超参数值的组合。例如，下面的代码搜索了RandomForestRegressor超参数值的最佳组合： from sklearn.model_selection import GridSearchCV param_grid = [ {&#39;n_estimators&#39;: [3, 10, 30], &#39;max_features&#39;: [2, 4, 6, 8]}, {&#39;bootstrap&#39;: [False], &#39;n_estimators&#39;: [3, 10], &#39;max_features&#39;: [2, 3, 4]}, ] forest_reg = RandomForestRegressor() grid_search = GridSearchCV(forest_reg, param_grid, cv=5, scoring=&#39;neg_mean_squared_error&#39;) grid_search.fit(housing_prepared, housing_labels) param_grid告诉Scikit-Learn首先评估所有的列在第一个dict中的n_estimators和max_features的3 × 4 = 12种组合（不用担心这些超参数的含义，会在第7章中解释）。然后尝试第二个dict中超参数的2 × 3 = 6种组合，这次会将超参数bootstrap设为False而不是True（后者是该超参数的默认值）。总之，网格搜索会探索12 + 6 = 18种RandomForestRegressor的超参数组合，会训练每个模型五次（因为用的是五折交叉验证）。换句话说，训练总共有18 × 5 = 90轮！折将要花费大量时间，完成后，你就能获得参数的最佳组合。 grid_search.best_params_ 还能直接得到最佳的估计量： grid_search.best_estimator_ &nbsp;也可以得到评估值： cvres = grid_search.cv_results_ for mean_score, params in zip(cvres[&quot;mean_test_score&quot;], cvres[&quot;params&quot;]): print(np.sqrt(-mean_score), params) 2.随机搜索 当探索相对较少的组合时，就像前面的例子，网格搜索还可以。但是当超参数的搜索空间很大时，最好使用RandomizedSearchCV。这个类的使用方法和类GridSearchCV很相似，但它不是尝试所有可能的组合，而是通过选择每个超参数的一个随机值的特定数量的随机组合。这个方法有两个优点： 如果你让随机搜索运行，比如1000次，它会探索每个超参数的1000个不同的值（而不是像网格搜索那样，只搜索每个超参数的几个值）。 你可以方便地通过设定搜索次数，控制超参数搜索的计算量。 3.集成方法 另一种微调系统的方法是将表现最好的模型组合起来。组合（集成）之后的性能通常要比单独的模型要好（就像随机森林要比单独的决策树要好），特别是当单独模型的误差类型不同时。 4.分析最佳模型和它们的误差 通过分析最佳模型，常常可以获得对问题更深的了解。比如，RandomForestRegressor可以指出每个属性对于做出准确预测的相对重要性： feature_importances = grid_search.best_estimator_.feature_importances_ &nbsp;&nbsp; 将重要性分数和属性名放到一起：&nbsp; extra_attribs = [&quot;rooms_per_hhold&quot;, &quot;pop_per_hhold&quot;, &quot;bedrooms_per_room&quot;] #cat_encoder = cat_pipeline.named_steps[&quot;cat_encoder&quot;] # old solution cat_encoder = full_pipeline.named_transformers_[&quot;cat&quot;] cat_one_hot_attribs = list(cat_encoder.categories_[0]) attributes = num_attribs + extra_attribs + cat_one_hot_attribs sorted(zip(feature_importances, attributes), reverse=True) &nbsp;有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类ocean_proximity就够了，所以可以丢弃掉其它的）。 有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类ocean_proximity就够了，所以可以丢弃掉其它的）。&nbsp; 七、给出解决方案 用测试集评估系统： 调节完系统之后，你终于有了一个性能足够好的系统。现在就可以用测试集评估最后的模型了。这个过程没有什么特殊的：从测试集得到预测值和标签，运行full_pipeline转换数据（调用transform()，而不是fit_transform()！），再用测试集评估最终模型： final_model = grid_search.best_estimator_ X_test = strat_test_set.drop(&quot;median_house_value&quot;, axis=1) y_test = strat_test_set[&quot;median_house_value&quot;].copy() X_test_prepared = full_pipeline.transform(X_test) final_predictions = final_model.predict(X_test_prepared) final_mse = mean_squared_error(y_test, final_predictions) final_rmse = np.sqrt(final_mse) #47730.22690385927 八、部署、监控、维护系统 很好，你被允许启动系统了！你需要为实际生产做好准备，特别是接入输入数据源，并编写测试。 你还需要编写监控代码，以固定间隔检测系统的实时表现，当发生下降时触发报警。这对于捕获突然的系统崩溃和性能下降十分重要。做监控很常见，是因为模型会随着数据的演化而性能下降，除非模型用新数据定期训练。 评估系统的表现需要对预测值采样并进行评估。这通常需要人来分析。分析者可能是领域专家，或者是众包平台（比如Amazon Mechanical Turk 或 CrowdFlower）的工人。不管采用哪种方法，你都需要将人工评估的pipeline植入系统。 你还要评估系统输入数据的质量。有时因为低质量的信号（比如失灵的传感器发送随机值，或另一个团队的输出停滞），系统的表现会逐渐变差，但可能需要一段时间，系统的表现才能下降到一定程度，触发警报。如果监测了系统的输入，你就可能尽量早的发现问题。对于线上学习系统，监测输入数据是非常重要的。 最后，你可能想定期用新数据训练模型。你应该尽可能自动化这个过程。如果不这么做，非常有可能你需要每隔至少六个月更新模型，系统的表现就会产生严重波动。如果你的系统是一个线上学习系统，你需要定期保存系统状态快照，好能方便地回滚到之前的工作状态。 &nbsp; 完结！ 参考书籍《Scikit-Learn与TensorFlow机器学习实用指南》的第02、03章。 完整的代码https://github.com/ageron/handson-ml" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-16T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"本部分，我们会作为被一家地产公司雇佣的数据科学家，完整地学习一个项目。下面是主要步骤： 项目概述。 获取数据。 发现并可视化数据，发现规律。 为机器学习算法准备数据。 选择模型，进行训练。 微调模型。 给出解决方案。 部署、监控、维护系统。 一、项目概述 任务是利用加州普查数据，建立一个加州房价模型。这个数据包含每个分区组的人口、收入中位数、房价中位数等指标。分区组是美国调查局发布样本数据的最小地理单位（一个分区通常有600到3000人）。我们将其简称为“分区”。你的模型要利用这个数据进行学习，然后根据其它指标，预测任何分区的的房价中位数。 1.划定问题 首先，你需要划定问题：监督或非监督，还是强化学习？这是个分类任务、回归任务，还是其它的？要使用批量学习还是线上学习？ 答：这是一个典型的监督学习任务，因为你要使用的是有标签的训练样本（每个实例都有预定的产出，即分区的房价中位数）。并且，这是一个典型的回归任务，因为你要预测一个值。讲的更细些，这是一个多变量回归问题，因为系统要使用多个变量进行预测（要使用分区的人口，收入中位数等等）。最后，没有连续的数据流进入系统，没有特别需求需要对数据变动作出快速适应。数据量不大可以放到内存中，因此批量学习就够了。 2.选择性能指标 下一步是选择性能指标。回归问题的典型指标是均方根误差（RMSE）。均方根误差测量的是系统预测误差的标准差。计算RMSE的计算方法如下： 虽然大多数时候RMSE是回归任务可靠的性能指标，在有些情况下，你可能需要另外的函数。例如，假设存在许多异常的分区。此时，你可能需要使用绝对平均误差（Mean Absolute Error，也称作平均绝对偏差。MAE的计算如下： 二、获取数据 1.创建工作环境 我的工作环境是Jupyter notebook，使用python3.0版本，安装Python模块：Jupyter、NumPy、Pandas、Matplotlib和Scikit-Learn。 2.下载数据 import os import tarfile from six.moves import urllib DOWNLOAD_ROOT = &quot;https://raw.githubusercontent.com/ageron/handson-ml/master/&quot; HOUSING_PATH = &quot;datasets/housing&quot; HOUSING_URL = DOWNLOAD_ROOT + HOUSING_PATH + &quot;/housing.tgz&quot; def fetch_housing_data(housing_url=HOUSING_URL, housing_path=HOUSING_PATH): if not os.path.isdir(housing_path): os.makedirs(housing_path) tgz_path = os.path.join(housing_path, &quot;housing.tgz&quot;) urllib.request.urlretrieve(housing_url, tgz_path) housing_tgz = tarfile.open(tgz_path) housing_tgz.extractall(path=housing_path) housing_tgz.close() fetch_housing_data() 然后使用Pandas加载数据:&nbsp; import pandas as pd def load_housing_data(housing_path=HOUSING_PATH): csv_path = os.path.join(housing_path, &quot;housing.csv&quot;) return pd.read_csv(csv_path) 3.查看数据结构 使用DataFrame的head()方法查看该数据集的顶部5行。 housing = load_housing_data() housing.head() 每一行都表示一个分区。共有10个属性（截图中可以看到6个）：经度、维度、房屋年龄中位数、总房间数、卧室数量、人口数、家庭数、收入中位数、房屋价值中位数、大海距离。 info()方法可以快速查看数据的描述，包括总行数、每个属性的类型和非空值的数量。 housing.info() 所有的属性都是数值的，除了大海距离这项。它的类型是对象，因此可以包含任意Python对象，但是因为是从CSV文件加载的，所以必然是文本。当查看顶部的五行时，你可能注意到那一列的值是重复的，意味着它可能是一个分类属性。可以使用value_counts()方法查看都有什么类型，每个类都有多少分区： housing[&quot;ocean_proximity&quot;].value_counts() &nbsp; describe()方法展示了数值属性的概括: housing.describe() count、mean、min和max几行的意思很明了。注意，空值被忽略了（所以，卧室总数是20433而不是20640）。std是标准差（揭示数值的分散度）。25%、50%、75%展示了对应的分位数：每个分位数指明小于这个值，且指定分组的百分比。例如，25%的分区的房屋年龄中位数小于18，而50%的小于29，75%的小于37。 另一种快速了解数据类型的方法是画出每个数值属性的柱状图。柱状图（的纵轴）展示了特定范围的实例的个数。你还可以一次给一个属性画图，或对完整数据集调用hist()方法，后者会画出每个数值属性的柱状图。 4.创建测试集 纯随机采样测试集 (1)自己编写代码，设置随机数生成器的种子（比如np.random.seed(42)），以产生总是相同的混合指数（shuffled indices） # to make this notebook&#39;s output identical at every run np.random.seed(42) import numpy as np def split_train_test(data, test_ratio): shuffled_indices = np.random.permutation(len(data)) test_set_size = int(len(data) * test_ratio) test_indices = shuffled_indices[:test_set_size] train_indices = shuffled_indices[test_set_size:] return data.iloc[train_indices], data.iloc[test_indices] train_set, test_set = split_train_test(housing, 0.2) print(len(train_set), &quot;train +&quot;, len(test_set), &quot;test&quot;) &nbsp;(2)使用hash import hashlib def test_set_check(identifier, test_ratio, hash): return hash(np.int64(identifier)).digest()[-1] &lt; 256 * test_ratio def split_train_test_by_id(data, test_ratio, id_column, hash=hashlib.md5): ids = data[id_column] in_test_set = ids.apply(lambda id_: test_set_check(id_, test_ratio, hash)) return data.loc[~in_test_set], data.loc[in_test_set] housing_with_id = housing.reset_index() # adds an `index` column train_set, test_set = split_train_test_by_id(housing_with_id, 0.2, &quot;index&quot;) &nbsp;如果使用行索引作为唯一识别码，你需要保证新数据放到现有数据的尾部，且没有行被深处。如果做不到，则可以用最稳定的特征来创建唯一识别码。例如，一个区的维度和经度在几百万年之内是不变的，所以可以将两者结合成一个ID： housing_with_id[&quot;id&quot;] = housing[&quot;longitude&quot;] * 1000 + housing[&quot;latitude&quot;] train_set, test_set = split_train_test_by_id(housing_with_id, 0.2, &quot;id&quot;) (3)sklearn实现 from sklearn.model_selection import train_test_split train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42) 分层采样的测试集 当你的数据集很大时（尤其是和属性数相比），这通常可行；但如果数据集不大，就会有采样偏差的风险。当一个调查公司想要对1000个人进行调查，它们不是在电话亭里随机选1000个人出来。调查公司要保证这1000个人对人群整体有代表性。例如，美国人口的51.3%是女性，48.7%是男性。所以在美国，严谨的调查需要保证样本也是这个比例：513名女性，487名男性。这称作分层采样（stratified sampling）：将人群分成均匀的子分组，称为分层，从每个分层取出合适数量的实例，以保证测试集对总人数有代表性。 假设专家告诉你，收入中位数是预测房价中位数非常重要的属性。你可能想要保证测试集可以代表整体数据集中的多种收入分类。因为收入中位数是一个连续的数值属性，你首先需要创建一个收入分类属性。大多数的收入中位数的值聚集在2-5（一万美元），但是一些收入中位数会超过6。数据集中的每个分层都要有足够的实例位于你的数据中，这点很重要。否则，对分层重要性的评估就会有偏差。这意味着，你不能有过多的分层，且每个分层都要足够大。后面的代码通过将收入中位数除以1.5（以限制收入分类的数量），创建了一个收入分类属性，用ceil对值舍入（以产生离散的分类），然后将所有大于5的分类归入到分类5： housing[&quot;income_cat&quot;] = np.ceil(housing[&quot;median_income&quot;] / 1.5) housing[&quot;income_cat&quot;].where(housing[&quot;income_cat&quot;] &lt; 5, 5.0, inplace=True) 根据收入分类，使用Scikit-Learn的StratifiedShuffleSplit类进行分层采样: from sklearn.model_selection import StratifiedShuffleSplit split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42) for train_index, test_index in split.split(housing, housing[&quot;income_cat&quot;]): strat_train_set = housing.loc[train_index] strat_test_set = housing.loc[test_index] &nbsp;在测试集和完整的房产数据集中查看收入分类比例： strat_test_set[&quot;income_cat&quot;].value_counts() / len(strat_test_set) housing[&quot;income_cat&quot;].value_counts() / len(housing) &nbsp; 对比了总数据集、分层采样的测试集、纯随机采样测试集的收入分类比例。可以看到，分层采样测试集的收入分类比例与总数据集几乎相同，而随机采样数据集偏差严重。 def income_cat_proportions(data): return data[&quot;income_cat&quot;].value_counts() / len(data) train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42) compare_props = pd.DataFrame({ &quot;Overall&quot;: income_cat_proportions(housing), &quot;Stratified&quot;: income_cat_proportions(strat_test_set), &quot;Random&quot;: income_cat_proportions(test_set), }).sort_index() compare_props[&quot;Rand. %error&quot;] = 100 * compare_props[&quot;Random&quot;] / compare_props[&quot;Overall&quot;] - 100 compare_props[&quot;Strat. %error&quot;] = 100 * compare_props[&quot;Stratified&quot;] / compare_props[&quot;Overall&quot;] - 100 compare_props 删除income_cat属性，使数据回到初始状态： for set_ in (strat_train_set, strat_test_set): set_.drop(&quot;income_cat&quot;, axis=1, inplace=True) &nbsp;我们用了大量时间来生成测试集的原因是：测试集通常被忽略，但实际是机器学习非常重要的一部分。还有，生成测试集过程中的许多思路对于后面的交叉验证讨论是非常有帮助的。 三、发现并可视化数据，发现规律 首先，保证你将测试集放在了一旁，只是研究训练集。另外，如果训练集非常大，你可能需要再采样一个探索集，保证操作方便快速。在我们的案例中，数据集很小，所以可以在全集上直接工作。创建一个副本，以免损伤训练集： housing = strat_train_set.copy() 1.地理数据可视化&nbsp; 因为存在地理信息（纬度和经度），创建一个所有分区的散点图来数据可视化是一个不错的主意。 housing.plot(kind=&quot;scatter&quot;, x=&quot;longitude&quot;, y=&quot;latitude&quot;, alpha=0.1) 可以非常清楚地看到高密度区域，湾区、洛杉矶和圣迭戈，以及中央谷，特别是从萨克拉门托到弗雷斯诺。现在来看房价，每个圈的半径表示分区的人口（选项s），颜色代表价格（选项c）。我们用预先定义的颜色图（选项cmap）jet，它的范围是从蓝色（低价）到红色（高价）：&nbsp; housing.plot(kind=&quot;scatter&quot;, x=&quot;longitude&quot;, y=&quot;latitude&quot;, alpha=0.4, s=housing[&quot;population&quot;]/100, label=&quot;population&quot;, c=&quot;median_house_value&quot;, cmap=plt.get_cmap(&quot;jet&quot;), colorbar=True, ) plt.legend() 这张图说明房价和位置（比如，靠海）和人口密度联系密切，这点你可能早就知道。可以使用聚类算法来检测主要的聚集，用一个新的特征值测量聚集中心的距离。海洋距离属性也可能有用，尽管北加州海岸区域的房价并不高，所以这不是一个简单的规则。&nbsp; 2.查找关联&nbsp; (1)因为数据集并不是非常大，你可以很容易地使用corr()方法计算出每对属性间的标准相关系数（也称作皮尔逊相关系数）： corr_matrix = housing.corr() corr_matrix[&quot;median_house_value&quot;].sort_values(ascending=False) 相关系数的范围是-1到1。当接近1时，意味强正相关；例如，当收入中位数增加时，房价中位数也会增加。当相关系数接近-1时，意味强负相关；你可以看到，纬度和房价中位数有轻微的负相关性（即，越往北，房价越可能降低）。最后，相关系数接近0，意味没有线性相关性。&nbsp; (2)另一种检测属性间相关系数的方法是使用Pandas的scatter_matrix函数，它能画出每个数值属性对每个其它数值属性的图。因为现在共有11个数值属性，你可以得到112=121张图，在一页上画不下，所以只关注几个和房价中位数最有可能相关的属性。 from pandas.tools.plotting import scatter_matrix attributes = [&quot;median_house_value&quot;, &quot;median_income&quot;, &quot;total_rooms&quot;, &quot;housing_median_age&quot;] scatter_matrix(housing[attributes], figsize=(12, 8)) 如果pandas将每个变量对自己作图，主对角线（左上到右下）都会是直线图。所以Pandas展示的是每个属性的柱状图（也可以是其它的，请参考Pandas文档）。 最有希望用来预测房价中位数的属性是收入中位数，因此将这张图放大： housing.plot(kind=&quot;scatter&quot;, x=&quot;median_income&quot;, y=&quot;median_house_value&quot;, alpha=0.1) plt.axis([0, 16, 0, 550000]) save_fig(&quot;income_vs_house_value_scatterplot&quot;) &nbsp; 这张图说明了几点。首先，相关性非常高；可以清晰地看到向上的趋势，并且数据点不是非常分散。第二，我们之前看到的最高价，清晰地呈现为一条位于500000美元的水平线。这张图也呈现了一些不是那么明显的直线：一条位于450000美元的直线，一条位于350000美元的直线，一条在$280000的线，和一些更靠下的线。你可能希望去除对应的分区，以防止算法重复这些巧合。 &nbsp;3.属性组合试验 给算法准备数据之前，你需要做的最后一件事是尝试多种属性组合。例如，如果你不知道某个分区有多少户，该分区的总房间数就没什么用。你真正需要的是每户有几个房间。相似的，总卧室数也不重要：你可能需要将其与房间数进行比较。每户的人口数也是一个有趣的属性组合。让我们来创建这些新的属性： housing[&quot;rooms_per_household&quot;] = housing[&quot;total_rooms&quot;]/housing[&quot;households&quot;] housing[&quot;bedrooms_per_room&quot;] = housing[&quot;total_bedrooms&quot;]/housing[&quot;total_rooms&quot;] housing[&quot;population_per_household&quot;]=housing[&quot;population&quot;]/housing[&quot;households&quot;] corr_matrix = housing.corr() corr_matrix[&quot;median_house_value&quot;].sort_values(ascending=False) &nbsp; 与总房间数或卧室数相比，新的bedrooms_per_room属性与房价中位数的关联更强。显然，卧室数/总房间数的比例越低，房价就越高。每户的房间数也比分区的总房间数的更有信息，很明显，房屋越大，房价就越高。&nbsp; 四、为机器学习算法准备数据 回到清洗训练集（通过再次复制strat_train_set），将预测量和标签分开，因为我们不想对预测量和目标值应用相同的转换（注意copy()创建了一份数据的备份，而不影响strat_train_set）： housing = strat_train_set.drop(&quot;median_house_value&quot;, axis=1) # drop labels for training set housing_labels = strat_train_set[&quot;median_house_value&quot;].copy() 1.数据清洗&nbsp; 大多机器学习算法不能处理特征丢失，因此先创建一些函数来处理特征丢失的问题。前面，你应该注意到了属性total_bedrooms有一些缺失值。有三个解决选项： 去掉对应的分区； 去掉整个属性； 进行赋值（0、平均值、中位数等等）。 用DataFrame的dropna()， drop()，和 fillna()方法，可以方便地实现： housing.dropna(subset=[&quot;total_bedrooms&quot;]) # 选项1 housing.drop(&quot;total_bedrooms&quot;, axis=1) # 选项2 median = housing[&quot;total_bedrooms&quot;].median() housing[&quot;total_bedrooms&quot;].fillna(median) # 选项3 如果选择选项3，你需要计算训练集的中位数，用中位数填充训练集的缺失值，不要忘记保存该中位数。后面用测试集评估系统时，需要替换测试集中的缺失值，也可以用来实时替换新数据中的缺失值。 Scikit-Learn提供了一个方便的类来处理缺失值：Imputer。下面是其使用方法：首先，需要创建一个Imputer实例，指定用该属性的中位数替换它的每个缺失值： from sklearn.preprocessing import Imputer imputer = Imputer(strategy=&quot;median&quot;) 因为只有数值属性才能算出中位数，我们需要创建一份不包括文本属性ocean_proximity的数据副本： housing_num = housing.drop(&quot;ocean_proximity&quot;, axis=1) &nbsp;现在，就可以用fit()方法将imputer实例拟合到训练数据： imputer.fit(housing_num) imputer计算出了每个属性的中位数，并将结果保存在了实例变量statistics_中。只有属性total_bedrooms有缺失值，但是我们要确保一旦系统运行起来，新的数据中没有缺失值，所以安全的做法是将imputer应用到每个数值。使用这个“训练过的”imputer来对训练集进行转换，通过将缺失值替换为中位数： X = imputer.transform(housing_num) &nbsp;结果是一个普通的Numpy数组，包含有转换后的特征。如果你想将其放回到Pandas DataFrame中，也很简单： housing_tr = pd.DataFrame(X, columns=housing_num.columns) 2.处理文本和分类属性&nbsp; 我们丢弃了分类属性ocean_proximity，因为它是一个文本属性，不能计算出中位数。大多数机器学习算法更喜欢和数字打交道，所以让我们把这些文本标签转换为数字。 Scikit-Learn为这个任务提供了一个转换量LabelEncoder： housing_cat = housing[[&#39;ocean_proximity&#39;]] from sklearn.preprocessing import OrdinalEncoder ordinal_encoder = OrdinalEncoder() housing_cat_encoded = ordinal_encoder.fit_transform(housing_cat) 查看映射表，编码器是通过属性classes_来学习的（“&lt;1H OCEAN”被映射为0，“INLAND”被映射为1，等等）： print(encoder.classes_) #[&#39;&lt;1H OCEAN&#39; &#39;INLAND&#39; &#39;ISLAND&#39; &#39;NEAR BAY&#39; &#39;NEAR OCEAN&#39;] 显然这样不对（比如，分类0和4比0和1更相似）。要解决这个问题，一个常见的方法是给每个分类创建一个二元属性：当分类是“&lt;1H OCEAN”，该属性为1（否则为0），当分类是“INLAND”，另一个属性等于1（否则为0），以此类推。这称作独热编码(One-Hot Encoding)，因为只有一个属性会等于1（热），其余会是0（冷）。 使用类LabelBinarizer，我们可以用一步执行这两个转换（从文本分类到整数分类，再从整数分类到独热矢量）： cat_encoder = OneHotEncoder(sparse=False) housing_cat_1hot = cat_encoder.fit_transform(housing_cat) housing_cat_1hot 3.自定义转换量&nbsp; 尽管Scikit-Learn提供了许多有用的转换量，你还是需要自己动手写转换量执行任务，比如自定义的清理操作，或属性组合。你需要让自制的转换量与Scikit-Learn组件（比如pipeline）无缝衔接工作，因为Scikit-Learn是依赖鸭子类型的（而不是继承），你所需要做的是创建一个类并执行三个方法：fit()（返回self），transform()，和fit_transform()。通过添加TransformerMixin作为基类，可以很容易地得到最后一个。另外，如果你添加BaseEstimator作为基类（且构造器中避免使用*args和**kargs），你就能得到两个额外的方法（get_params()和set_params()），二者可以方便地进行超参数自动微调。例如，一个小转换量类添加了上面讨论的属性： from sklearn.base import BaseEstimator, TransformerMixin rooms_ix, bedrooms_ix, population_ix, household_ix = 3, 4, 5, 6 class CombinedAttributesAdder(BaseEstimator, TransformerMixin): def __init__(self, add_bedrooms_per_room = True): # no *args or **kargs self.add_bedrooms_per_room = add_bedrooms_per_room def fit(self, X, y=None): return self # nothing else to do def transform(self, X, y=None): rooms_per_household = X[:, rooms_ix] / X[:, household_ix] population_per_household = X[:, population_ix] / X[:, household_ix] if self.add_bedrooms_per_room: bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix] return np.c_[X, rooms_per_household, population_per_household, bedrooms_per_room] else: return np.c_[X, rooms_per_household, population_per_household] attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=False) housing_extra_attribs = attr_adder.transform(housing.values) 4.特征缩放 数据要做的最重要的转换之一是特征缩放。除了个别情况，当输入的数值属性量度不同时，机器学习算法的性能都不会好。这个规律也适用于房产数据：总房间数分布范围是6到39320，而收入中位数只分布在0到15。不需要对目标值进行缩放。 有两种常见的方法可以让所有的属性有相同的量度：线性函数归一化（Min-Max scaling）和标准化（standardization）。 线性函数归一化（许多人称其为归一化（normalization））很简单：值被转变、重新缩放，直到范围变成0到1。我们通过减去最小值，然后再除以最大值与最小值的差值，来进行归一化。Scikit-Learn提供了一个转换量MinMaxScaler来实现这个功能。它有一个超参数feature_range，可以让你改变范围，如果不希望范围是0到1。 标准化就很不同：首先减去平均值（所以标准化值的平均值总是0），然后除以方差，使得到的分布具有单位方差。与归一化不同，标准化不会限定值到某个特定的范围，这对某些算法可能构成问题（比如，神经网络常需要输入值得范围是0到1）。但是，标准化受到异常值的影响很小。例如，假设一个分区的收入中位数是100。归一化会将其它范围是0到15的值变为0-0.15，但是标准化不会受什么影响。Scikit-Learn提供了一个转换量StandardScaler来进行标准化。 5.转换Pipeline 你已经看到，存在许多数据转换步骤，需要按一定的顺序执行。幸运的是，Scikit-Learn提供了类Pipeline，来进行这一系列的转换。下面是一个数值属性的小pipeline，将替换缺失值、添加属性、替换文本值为数值的操作结合在一起。 from sklearn.pipeline import FeatureUnion num_attribs = list(housing_num) cat_attribs = [&quot;ocean_proximity&quot;] num_pipeline = Pipeline([ (&#39;selector&#39;, DataFrameSelector(num_attribs)), (&#39;imputer&#39;, Imputer(strategy=&quot;median&quot;)), (&#39;attribs_adder&#39;, CombinedAttributesAdder()), (&#39;std_scaler&#39;, StandardScaler()), ]) cat_pipeline = Pipeline([ (&#39;selector&#39;, DataFrameSelector(cat_attribs)), (&#39;label_binarizer&#39;, LabelBinarizer()), ]) full_pipeline = FeatureUnion(transformer_list=[ (&quot;num_pipeline&quot;, num_pipeline), (&quot;cat_pipeline&quot;, cat_pipeline), ]) housing_prepared = full_pipeline.fit_transform(housing) housing_prepared.shape #(16513, 17) 五、选择模型，进行训练 1.在训练集上训练和评估 (1)线性回归模型 from sklearn.linear_model import LinearRegression lin_reg = LinearRegression() lin_reg.fit(housing_prepared, housing_labels) 使用Scikit-Learn的mean_squared_error函数，用全部训练集来计算下这个回归模型的RMSE： from sklearn.metrics import mean_squared_error housing_predictions = lin_reg.predict(housing_prepared) lin_mse = mean_squared_error(housing_labels, housing_predictions) lin_rmse = np.sqrt(lin_mse) lin_rmse #68628.19819848922 大多数分区的median_housing_values位于120000美元到265000美元之间，因此预测误差$68628不能让人满意。这是一个模型欠拟合训练数据的例子。当这种情况发生时，意味着特征没有提供足够多的信息来做出一个好的预测，或者模型并不强大。就像前一章看到的，修复欠拟合的主要方法是选择一个更强大的模型，给训练算法提供更好的特征，或去掉模型上的限制。这个模型还没有正则化，所以排除了最后一个选项。你可以尝试添加更多特征（比如，人口的对数值），但是首先让我们尝试一个更为复杂的模型，看看效果。 (2)决策树 训练一个DecisionTreeRegressor。这是一个强大的模型，可以发现数据中复杂的非线性关系。代码： from sklearn.tree import DecisionTreeRegressor tree_reg = DecisionTreeRegressor(random_state=42) tree_reg.fit(housing_prepared, housing_labels) housing_predictions = tree_reg.predict(housing_prepared) tree_mse = mean_squared_error(housing_labels, housing_predictions) tree_rmse = np.sqrt(tree_mse) tree_rmse #0.0 &nbsp;没有误差？这个模型可能是绝对完美的吗？当然，更大可能性是这个模型严重过拟合数据。 2.使用交叉验证做更佳的评估 评估决策树模型的一种方法是用函数train_test_split来分割训练集，得到一个更小的训练集和一个验证集，然后用更小的训练集来训练模型，用验证集来评估。这需要一定工作量，并不难而且也可行。 另一种更好的方法是使用Scikit-Learn的交叉验证功能。下面的代码采用了K折交叉验证（K-fold cross-validation）：它随机地将训练集分成十个不同的子集，成为“折”，然后训练评估决策树模型10次，每次选一个不用的折来做评估，用其它9个来做训练。结果是一个包含10个评分的数组： from sklearn.model_selection import cross_val_score scores = cross_val_score(tree_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) tree_rmse_scores = np.sqrt(-scores) &nbsp;决策树的结果： def display_scores(scores): print(&quot;Scores:&quot;, scores) print(&quot;Mean:&quot;, scores.mean()) print(&quot;Standard deviation:&quot;, scores.std()) display_scores(tree_rmse_scores) 计算线性回归模型的的相同分数&nbsp;： lin_scores = cross_val_score(lin_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) lin_rmse_scores = np.sqrt(-lin_scores) display_scores(lin_rmse_scores) 判断没错：决策树模型过拟合很严重，它的性能比线性回归模型还差。 3.尝试新方法：随机森林&nbsp; from sklearn.ensemble import RandomForestRegressor forest_reg = RandomForestRegressor(n_estimators=10, random_state=42) forest_reg.fit(housing_prepared, housing_labels) from sklearn.model_selection import cross_val_score forest_scores = cross_val_score(forest_reg, housing_prepared, housing_labels, scoring=&quot;neg_mean_squared_error&quot;, cv=10) forest_rmse_scores = np.sqrt(-forest_scores) display_scores(forest_rmse_scores) &nbsp; 随机森林看起来很有希望。但是，训练集的评分仍然比验证集的评分低很多。解决过拟合可以通过简化模型，给模型加限制（即，规整化），或用更多的训练数据。&nbsp; 六、微调模型 1.网格搜索 微调的一种方法是手工调整超参数，直到找到一个好的超参数组合。这么做的话会非常冗长，你也可能没有时间探索多种组合。 你应该使用Scikit-Learn的GridSearchCV来做这项搜索工作。你所需要做的是告诉GridSearchCV要试验有哪些超参数，要试验什么值，GridSearchCV就能用交叉验证试验所有可能超参数值的组合。例如，下面的代码搜索了RandomForestRegressor超参数值的最佳组合： from sklearn.model_selection import GridSearchCV param_grid = [ {&#39;n_estimators&#39;: [3, 10, 30], &#39;max_features&#39;: [2, 4, 6, 8]}, {&#39;bootstrap&#39;: [False], &#39;n_estimators&#39;: [3, 10], &#39;max_features&#39;: [2, 3, 4]}, ] forest_reg = RandomForestRegressor() grid_search = GridSearchCV(forest_reg, param_grid, cv=5, scoring=&#39;neg_mean_squared_error&#39;) grid_search.fit(housing_prepared, housing_labels) param_grid告诉Scikit-Learn首先评估所有的列在第一个dict中的n_estimators和max_features的3 × 4 = 12种组合（不用担心这些超参数的含义，会在第7章中解释）。然后尝试第二个dict中超参数的2 × 3 = 6种组合，这次会将超参数bootstrap设为False而不是True（后者是该超参数的默认值）。总之，网格搜索会探索12 + 6 = 18种RandomForestRegressor的超参数组合，会训练每个模型五次（因为用的是五折交叉验证）。换句话说，训练总共有18 × 5 = 90轮！折将要花费大量时间，完成后，你就能获得参数的最佳组合。 grid_search.best_params_ 还能直接得到最佳的估计量： grid_search.best_estimator_ &nbsp;也可以得到评估值： cvres = grid_search.cv_results_ for mean_score, params in zip(cvres[&quot;mean_test_score&quot;], cvres[&quot;params&quot;]): print(np.sqrt(-mean_score), params) 2.随机搜索 当探索相对较少的组合时，就像前面的例子，网格搜索还可以。但是当超参数的搜索空间很大时，最好使用RandomizedSearchCV。这个类的使用方法和类GridSearchCV很相似，但它不是尝试所有可能的组合，而是通过选择每个超参数的一个随机值的特定数量的随机组合。这个方法有两个优点： 如果你让随机搜索运行，比如1000次，它会探索每个超参数的1000个不同的值（而不是像网格搜索那样，只搜索每个超参数的几个值）。 你可以方便地通过设定搜索次数，控制超参数搜索的计算量。 3.集成方法 另一种微调系统的方法是将表现最好的模型组合起来。组合（集成）之后的性能通常要比单独的模型要好（就像随机森林要比单独的决策树要好），特别是当单独模型的误差类型不同时。 4.分析最佳模型和它们的误差 通过分析最佳模型，常常可以获得对问题更深的了解。比如，RandomForestRegressor可以指出每个属性对于做出准确预测的相对重要性： feature_importances = grid_search.best_estimator_.feature_importances_ &nbsp;&nbsp; 将重要性分数和属性名放到一起：&nbsp; extra_attribs = [&quot;rooms_per_hhold&quot;, &quot;pop_per_hhold&quot;, &quot;bedrooms_per_room&quot;] #cat_encoder = cat_pipeline.named_steps[&quot;cat_encoder&quot;] # old solution cat_encoder = full_pipeline.named_transformers_[&quot;cat&quot;] cat_one_hot_attribs = list(cat_encoder.categories_[0]) attributes = num_attribs + extra_attribs + cat_one_hot_attribs sorted(zip(feature_importances, attributes), reverse=True) &nbsp;有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类ocean_proximity就够了，所以可以丢弃掉其它的）。 有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类ocean_proximity就够了，所以可以丢弃掉其它的）。&nbsp; 七、给出解决方案 用测试集评估系统： 调节完系统之后，你终于有了一个性能足够好的系统。现在就可以用测试集评估最后的模型了。这个过程没有什么特殊的：从测试集得到预测值和标签，运行full_pipeline转换数据（调用transform()，而不是fit_transform()！），再用测试集评估最终模型： final_model = grid_search.best_estimator_ X_test = strat_test_set.drop(&quot;median_house_value&quot;, axis=1) y_test = strat_test_set[&quot;median_house_value&quot;].copy() X_test_prepared = full_pipeline.transform(X_test) final_predictions = final_model.predict(X_test_prepared) final_mse = mean_squared_error(y_test, final_predictions) final_rmse = np.sqrt(final_mse) #47730.22690385927 八、部署、监控、维护系统 很好，你被允许启动系统了！你需要为实际生产做好准备，特别是接入输入数据源，并编写测试。 你还需要编写监控代码，以固定间隔检测系统的实时表现，当发生下降时触发报警。这对于捕获突然的系统崩溃和性能下降十分重要。做监控很常见，是因为模型会随着数据的演化而性能下降，除非模型用新数据定期训练。 评估系统的表现需要对预测值采样并进行评估。这通常需要人来分析。分析者可能是领域专家，或者是众包平台（比如Amazon Mechanical Turk 或 CrowdFlower）的工人。不管采用哪种方法，你都需要将人工评估的pipeline植入系统。 你还要评估系统输入数据的质量。有时因为低质量的信号（比如失灵的传感器发送随机值，或另一个团队的输出停滞），系统的表现会逐渐变差，但可能需要一段时间，系统的表现才能下降到一定程度，触发警报。如果监测了系统的输入，你就可能尽量早的发现问题。对于线上学习系统，监测输入数据是非常重要的。 最后，你可能想定期用新数据训练模型。你应该尽可能自动化这个过程。如果不这么做，非常有可能你需要每隔至少六个月更新模型，系统的表现就会产生严重波动。如果你的系统是一个线上学习系统，你需要定期保存系统状态快照，好能方便地回滚到之前的工作状态。 &nbsp; 完结！ 参考书籍《Scikit-Learn与TensorFlow机器学习实用指南》的第02、03章。 完整的代码https://github.com/ageron/handson-ml","@type":"BlogPosting","url":"/2019/01/16/c3cf005bfd99902b54caf57451626075.html","headline":"机器学习项目入门篇：一个完整的机器学习项目","dateModified":"2019-01-16T00:00:00+08:00","datePublished":"2019-01-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/01/16/c3cf005bfd99902b54caf57451626075.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>机器学习项目入门篇：一个完整的机器学习项目</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>本部分，我们会作为被一家地产公司雇佣的数据科学家，完整地学习一个项目。下面是主要步骤：</p> 
  <ol>
   <li>项目概述。</li> 
   <li>获取数据。</li> 
   <li>发现并可视化数据，发现规律。</li> 
   <li>为机器学习算法准备数据。</li> 
   <li>选择模型，进行训练。</li> 
   <li>微调模型。</li> 
   <li>给出解决方案。</li> 
   <li>部署、监控、维护系统。</li> 
  </ol>
  <h2>一、项目概述</h2> 
  <p>任务是利用加州普查数据，建立一个加州房价模型。这个数据包含每个分区组的人口、收入中位数、房价中位数等指标。分区组是美国调查局发布样本数据的最小地理单位（一个分区通常有600到3000人）。我们将其简称为“分区”。你的模型要利用这个数据进行学习，然后根据其它指标，预测任何分区的的房价中位数。</p> 
  <p><strong>1.划定问题</strong></p> 
  <p>首先，你需要划定问题：监督或非监督，还是强化学习？这是个分类任务、回归任务，还是其它的？要使用批量学习还是线上学习？</p> 
  <p>答：这是一个典型的监督学习任务，因为你要使用的是有标签的训练样本（每个实例都有预定的产出，即分区的房价中位数）。并且，这是一个典型的回归任务，因为你要预测一个值。讲的更细些，这是一个多变量回归问题，因为系统要使用多个变量进行预测（要使用分区的人口，收入中位数等等）。最后，没有连续的数据流进入系统，没有特别需求需要对数据变动作出快速适应。数据量不大可以放到内存中，因此批量学习就够了。</p> 
  <p><strong>2.选择性能指标</strong></p> 
  <p>下一步是选择性能指标。回归问题的典型指标是均方根误差（RMSE）。均方根误差测量的是系统预测误差的标准差。计算RMSE的计算方法如下：</p> 
  <p><img alt="" class="has" height="74" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190115203007724.png" width="364"></p> 
  <p>虽然大多数时候RMSE是回归任务可靠的性能指标，在有些情况下，你可能需要另外的函数。例如，假设存在许多异常的分区。此时，你可能需要使用绝对平均误差（Mean Absolute Error，也称作平均绝对偏差。MAE的计算如下：</p> 
  <p><img alt="" class="has" height="69" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190115203304870.png" width="365"></p> 
  <h2>二、获取数据</h2> 
  <p><strong>1.创建工作环境</strong></p> 
  <p>我的工作环境是Jupyter notebook，使用python3.0版本，安装Python模块：Jupyter、NumPy、Pandas、Matplotlib和Scikit-Learn。</p> 
  <p><strong>2.下载数据</strong></p> 
  <pre class="has">
<code class="language-python">import os
import tarfile
from six.moves import urllib

DOWNLOAD_ROOT = "https://raw.githubusercontent.com/ageron/handson-ml/master/"
HOUSING_PATH = "datasets/housing"
HOUSING_URL = DOWNLOAD_ROOT + HOUSING_PATH + "/housing.tgz"

def fetch_housing_data(housing_url=HOUSING_URL, housing_path=HOUSING_PATH):
    if not os.path.isdir(housing_path):
        os.makedirs(housing_path)
    tgz_path = os.path.join(housing_path, "housing.tgz")
    urllib.request.urlretrieve(housing_url, tgz_path)
    housing_tgz = tarfile.open(tgz_path)
    housing_tgz.extractall(path=housing_path)
    housing_tgz.close()

fetch_housing_data()
</code></pre> 
  <p>然后使用Pandas加载数据:&nbsp;</p> 
  <pre class="has">
<code class="language-python">import pandas as pd

def load_housing_data(housing_path=HOUSING_PATH):
    csv_path = os.path.join(housing_path, "housing.csv")
    return pd.read_csv(csv_path)</code></pre> 
  <p><strong>3.查看数据结构</strong></p> 
  <p>使用DataFrame的head()方法查看该数据集的顶部5行。</p> 
  <pre class="has">
<code class="language-python">housing = load_housing_data()
housing.head()</code></pre> 
  <p><img alt="" class="has" height="174" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116201234343.png" width="987"></p> 
  <p>每一行都表示一个分区。共有10个属性（截图中可以看到6个）：经度、维度、房屋年龄中位数、总房间数、卧室数量、人口数、家庭数、收入中位数、房屋价值中位数、大海距离。</p> 
  <p>info()方法可以快速查看数据的描述，包括总行数、每个属性的类型和非空值的数量。</p> 
  <pre class="has">
<code class="language-python">housing.info()</code></pre> 
  <h2><img alt="" class="has" height="325" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116084335355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="432"></h2> 
  <p>所有的属性都是数值的，除了大海距离这项。它的类型是对象，因此可以包含任意Python对象，但是因为是从CSV文件加载的，所以必然是文本。当查看顶部的五行时，你可能注意到那一列的值是重复的，意味着它可能是一个分类属性。可以使用value_counts()方法查看都有什么类型，每个类都有多少分区：</p> 
  <pre class="has">
<code class="language-python">housing["ocean_proximity"].value_counts()</code></pre> 
  <p>&nbsp;<img alt="" class="has" height="113" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116201301557.png" width="278"></p> 
  <p>describe()方法展示了数值属性的概括:</p> 
  <pre class="has">
<code class="language-python">housing.describe()</code></pre> 
  <p><img alt="" class="has" height="241" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116201342597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="967"></p> 
  <p>count、mean、min和max几行的意思很明了。注意，空值被忽略了（所以，卧室总数是20433而不是20640）。std是标准差（揭示数值的分散度）。25%、50%、75%展示了对应的分位数：每个分位数指明小于这个值，且指定分组的百分比。例如，25%的分区的房屋年龄中位数小于18，而50%的小于29，75%的小于37。</p> 
  <p>另一种快速了解数据类型的方法是画出每个数值属性的柱状图。柱状图（的纵轴）展示了特定范围的实例的个数。你还可以一次给一个属性画图，或对完整数据集调用hist()方法，后者会画出每个数值属性的柱状图。</p> 
  <p><img alt="" class="has" height="750" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116090835440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="1000"></p> 
  <p><br><strong>4.创建测试集</strong></p> 
  <p>纯随机采样测试集</p> 
  <p>(1)自己编写代码，设置随机数生成器的种子（比如np.random.seed(42)），以产生总是相同的混合指数（shuffled indices）</p> 
  <pre class="has">
<code class="language-python"># to make this notebook's output identical at every run
np.random.seed(42)

import numpy as np

def split_train_test(data, test_ratio):
    shuffled_indices = np.random.permutation(len(data))
    test_set_size = int(len(data) * test_ratio)
    test_indices = shuffled_indices[:test_set_size]
    train_indices = shuffled_indices[test_set_size:]
    return data.iloc[train_indices], data.iloc[test_indices]
</code></pre> 
  <pre class="has">
<code class="language-python">train_set, test_set = split_train_test(housing, 0.2)
print(len(train_set), "train +", len(test_set), "test")</code></pre> 
  <p>&nbsp;(2)使用hash</p> 
  <pre class="has">
<code class="language-python">import hashlib

def test_set_check(identifier, test_ratio, hash):
    return hash(np.int64(identifier)).digest()[-1] &lt; 256 * test_ratio

def split_train_test_by_id(data, test_ratio, id_column, hash=hashlib.md5):
    ids = data[id_column]
    in_test_set = ids.apply(lambda id_: test_set_check(id_, test_ratio, hash))
    return data.loc[~in_test_set], data.loc[in_test_set]
</code></pre> 
  <pre class="has">
<code class="language-python">housing_with_id = housing.reset_index()   # adds an `index` column
train_set, test_set = split_train_test_by_id(housing_with_id, 0.2, "index")</code></pre> 
  <p>&nbsp;如果使用行索引作为唯一识别码，你需要保证新数据放到现有数据的尾部，且没有行被深处。如果做不到，则可以用最稳定的特征来创建唯一识别码。例如，一个区的维度和经度在几百万年之内是不变的，所以可以将两者结合成一个ID：</p> 
  <pre class="has">
<code class="language-python">housing_with_id["id"] = housing["longitude"] * 1000 + housing["latitude"]
train_set, test_set = split_train_test_by_id(housing_with_id, 0.2, "id")</code></pre> 
  <p>(3)sklearn实现</p> 
  <pre class="has">
<code class="language-python">from sklearn.model_selection import train_test_split

train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42)</code></pre> 
  <p>分层采样的测试集</p> 
  <p>当你的数据集很大时（尤其是和属性数相比），这通常可行；但如果数据集不大，就会有采样偏差的风险。当一个调查公司想要对1000个人进行调查，它们不是在电话亭里随机选1000个人出来。调查公司要保证这1000个人对人群整体有代表性。例如，美国人口的51.3%是女性，48.7%是男性。所以在美国，严谨的调查需要保证样本也是这个比例：513名女性，487名男性。这称作分层采样（stratified sampling）：将人群分成均匀的子分组，称为分层，从每个分层取出合适数量的实例，以保证测试集对总人数有代表性。</p> 
  <p>假设专家告诉你，收入中位数是预测房价中位数非常重要的属性。你可能想要保证测试集可以代表整体数据集中的多种收入分类。因为收入中位数是一个连续的数值属性，你首先需要创建一个收入分类属性。大多数的收入中位数的值聚集在2-5（一万美元），但是一些收入中位数会超过6。数据集中的每个分层都要有足够的实例位于你的数据中，这点很重要。否则，对分层重要性的评估就会有偏差。这意味着，你不能有过多的分层，且每个分层都要足够大。后面的代码通过将收入中位数除以1.5（以限制收入分类的数量），创建了一个收入分类属性，用ceil对值舍入（以产生离散的分类），然后将所有大于5的分类归入到分类5：</p> 
  <pre class="has">
<code class="language-python">housing["income_cat"] = np.ceil(housing["median_income"] / 1.5)
housing["income_cat"].where(housing["income_cat"] &lt; 5, 5.0, inplace=True)</code></pre> 
  <p>根据收入分类，使用Scikit-Learn的StratifiedShuffleSplit类进行分层采样:</p> 
  <pre class="has">
<code class="language-python">from sklearn.model_selection import StratifiedShuffleSplit

split = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)
for train_index, test_index in split.split(housing, housing["income_cat"]):
    strat_train_set = housing.loc[train_index]
    strat_test_set = housing.loc[test_index]</code></pre> 
  <p>&nbsp;在测试集和完整的房产数据集中查看收入分类比例：</p> 
  <pre class="has">
<code class="language-python">strat_test_set["income_cat"].value_counts() / len(strat_test_set)
housing["income_cat"].value_counts() / len(housing)</code></pre> 
  <p><img alt="" class="has" height="114" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116101234239.png" width="251">&nbsp;<img alt="" class="has" height="106" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116101252577.png" width="243"></p> 
  <p>对比了总数据集、分层采样的测试集、纯随机采样测试集的收入分类比例。可以看到，分层采样测试集的收入分类比例与总数据集几乎相同，而随机采样数据集偏差严重。</p> 
  <pre class="has">
<code class="language-python">def income_cat_proportions(data):
    return data["income_cat"].value_counts() / len(data)

train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42)

compare_props = pd.DataFrame({
    "Overall": income_cat_proportions(housing),
    "Stratified": income_cat_proportions(strat_test_set),
    "Random": income_cat_proportions(test_set),
}).sort_index()
compare_props["Rand. %error"] = 100 * compare_props["Random"] / compare_props["Overall"] - 100
compare_props["Strat. %error"] = 100 * compare_props["Stratified"] / compare_props["Overall"] - 100

compare_props</code></pre> 
  <h2><img alt="" class="has" height="175" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116102038734.png" width="408"></h2> 
  <p>删除income_cat属性，使数据回到初始状态：</p> 
  <pre class="has">
<code class="language-python">for set_ in (strat_train_set, strat_test_set):
    set_.drop("income_cat", axis=1, inplace=True)</code></pre> 
  <p>&nbsp;我们用了大量时间来生成测试集的原因是：测试集通常被忽略，但实际是机器学习非常重要的一部分。还有，生成测试集过程中的许多思路对于后面的交叉验证讨论是非常有帮助的。</p> 
  <h2>三、发现并可视化数据，发现规律</h2> 
  <p>首先，保证你将测试集放在了一旁，只是研究训练集。另外，如果训练集非常大，你可能需要再采样一个探索集，保证操作方便快速。在我们的案例中，数据集很小，所以可以在全集上直接工作。创建一个副本，以免损伤训练集：</p> 
  <pre class="has">
<code class="language-python">housing = strat_train_set.copy()</code></pre> 
  <p><strong>1.地理数据可视化&nbsp;</strong></p> 
  <p>因为存在地理信息（纬度和经度），创建一个所有分区的散点图来数据可视化是一个不错的主意。</p> 
  <pre class="has">
<code class="language-python">housing.plot(kind="scatter", x="longitude", y="latitude", alpha=0.1)</code></pre> 
  <p><img alt="" class="has" height="291" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/2019011610362018.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="459"></p> 
  <p>可以非常清楚地看到高密度区域，湾区、洛杉矶和圣迭戈，以及中央谷，特别是从萨克拉门托到弗雷斯诺。现在来看房价，每个圈的半径表示分区的人口（选项s），颜色代表价格（选项c）。我们用预先定义的颜色图（选项cmap）jet，它的范围是从蓝色（低价）到红色（高价）：&nbsp;</p> 
  <pre class="has">
<code class="language-python">housing.plot(kind="scatter", x="longitude", y="latitude", alpha=0.4,
    s=housing["population"]/100, label="population",
    c="median_house_value", cmap=plt.get_cmap("jet"), colorbar=True,
)
plt.legend()</code></pre> 
  <p><img alt="" class="has" height="490" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116104105534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="684"></p> 
  <p>这张图说明房价和位置（比如，靠海）和人口密度联系密切，这点你可能早就知道。可以使用聚类算法来检测主要的聚集，用一个新的特征值测量聚集中心的距离。海洋距离属性也可能有用，尽管北加州海岸区域的房价并不高，所以这不是一个简单的规则。&nbsp;</p> 
  <p><strong>2.查找关联&nbsp;</strong></p> 
  <p>(1)因为数据集并不是非常大，你可以很容易地使用corr()方法计算出每对属性间的标准相关系数（也称作皮尔逊相关系数）：</p> 
  <pre class="has">
<code class="language-python">corr_matrix = housing.corr()
corr_matrix["median_house_value"].sort_values(ascending=False)</code></pre> 
  <p><img alt="" class="has" height="175" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116104813231.png" width="303"></p> 
  <p>相关系数的范围是-1到1。当接近1时，意味强正相关；例如，当收入中位数增加时，房价中位数也会增加。当相关系数接近-1时，意味强负相关；你可以看到，纬度和房价中位数有轻微的负相关性（即，越往北，房价越可能降低）。最后，相关系数接近0，意味没有线性相关性。&nbsp;</p> 
  <p>(2)另一种检测属性间相关系数的方法是使用Pandas的scatter_matrix函数，它能画出每个数值属性对每个其它数值属性的图。因为现在共有11个数值属性，你可以得到112=121张图，在一页上画不下，所以只关注几个和房价中位数最有可能相关的属性。</p> 
  <pre class="has">
<code class="language-python">from pandas.tools.plotting import scatter_matrix

attributes = ["median_house_value", "median_income", "total_rooms",
              "housing_median_age"]
scatter_matrix(housing[attributes], figsize=(12, 8))</code></pre> 
  <p><img alt="" class="has" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116105442966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="1000"></p> 
  <p>如果pandas将每个变量对自己作图，主对角线（左上到右下）都会是直线图。所以Pandas展示的是每个属性的柱状图（也可以是其它的，请参考Pandas文档）。</p> 
  <p>最有希望用来预测房价中位数的属性是收入中位数，因此将这张图放大：</p> 
  <pre class="has">
<code class="language-python">housing.plot(kind="scatter", x="median_income", y="median_house_value",
             alpha=0.1)
plt.axis([0, 16, 0, 550000])
save_fig("income_vs_house_value_scatterplot")</code></pre> 
  <p>&nbsp;<img alt="" class="has" height="281" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116105825201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="451"></p> 
  <p>这张图说明了几点。首先，相关性非常高；可以清晰地看到向上的趋势，并且数据点不是非常分散。第二，我们之前看到的最高价，清晰地呈现为一条位于500000美元的水平线。这张图也呈现了一些不是那么明显的直线：一条位于450000美元的直线，一条位于350000美元的直线，一条在$280000的线，和一些更靠下的线。你可能希望去除对应的分区，以防止算法重复这些巧合。</p> 
  <p><strong>&nbsp;3.属性组合试验</strong></p> 
  <p>给算法准备数据之前，你需要做的最后一件事是尝试多种属性组合。例如，如果你不知道某个分区有多少户，该分区的总房间数就没什么用。你真正需要的是每户有几个房间。相似的，总卧室数也不重要：你可能需要将其与房间数进行比较。每户的人口数也是一个有趣的属性组合。让我们来创建这些新的属性：</p> 
  <pre class="has">
<code class="language-python">housing["rooms_per_household"] = housing["total_rooms"]/housing["households"]
housing["bedrooms_per_room"] = housing["total_bedrooms"]/housing["total_rooms"]
housing["population_per_household"]=housing["population"]/housing["households"]</code></pre> 
  <pre class="has">
<code>corr_matrix = housing.corr()
corr_matrix["median_house_value"].sort_values(ascending=False)</code></pre> 
  <p>&nbsp;<img alt="" class="has" height="224" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116110332101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="310"></p> 
  <p>与总房间数或卧室数相比，新的bedrooms_per_room属性与房价中位数的关联更强。显然，卧室数/总房间数的比例越低，房价就越高。每户的房间数也比分区的总房间数的更有信息，很明显，房屋越大，房价就越高。&nbsp;</p> 
  <h2>四、为机器学习算法准备数据</h2> 
  <p>回到清洗训练集（通过再次复制strat_train_set），将预测量和标签分开，因为我们不想对预测量和目标值应用相同的转换（注意copy()创建了一份数据的备份，而不影响strat_train_set）：</p> 
  <pre class="has">
<code class="language-python">housing = strat_train_set.drop("median_house_value", axis=1) # drop labels for training set
housing_labels = strat_train_set["median_house_value"].copy()</code></pre> 
  <p><strong>1.数据清洗&nbsp;</strong></p> 
  <p>大多机器学习算法不能处理特征丢失，因此先创建一些函数来处理特征丢失的问题。前面，你应该注意到了属性total_bedrooms有一些缺失值。有三个解决选项：</p> 
  <ul>
   <li>去掉对应的分区；</li> 
   <li>去掉整个属性；</li> 
   <li>进行赋值（0、平均值、中位数等等）。</li> 
  </ul>
  <p>用DataFrame的<code>dropna()</code>， <code>drop()</code>，和 <code>fillna()</code>方法，可以方便地实现：</p> 
  <pre class="has">
<code class="language-python">housing.dropna(subset=["total_bedrooms"])    # 选项1
housing.drop("total_bedrooms", axis=1)       # 选项2
median = housing["total_bedrooms"].median()
housing["total_bedrooms"].fillna(median)     # 选项3</code></pre> 
  <p>如果选择选项3，你需要计算训练集的中位数，用中位数填充训练集的缺失值，不要忘记保存该中位数。后面用测试集评估系统时，需要替换测试集中的缺失值，也可以用来实时替换新数据中的缺失值。</p> 
  <p>Scikit-Learn提供了一个方便的类来处理缺失值：<code>Imputer</code>。下面是其使用方法：首先，需要创建一个<code>Imputer</code>实例，指定用该属性的中位数替换它的每个缺失值：</p> 
  <pre class="has">
<code class="language-python">from sklearn.preprocessing import Imputer

imputer = Imputer(strategy="median")</code></pre> 
  <p>因为只有数值属性才能算出中位数，我们需要创建一份不包括文本属性ocean_proximity的数据副本：</p> 
  <pre class="has">
<code class="language-python">housing_num = housing.drop("ocean_proximity", axis=1)</code></pre> 
  <p>&nbsp;现在，就可以用<code>fit()</code>方法将<code>imputer</code>实例拟合到训练数据：</p> 
  <pre class="has">
<code class="language-python">imputer.fit(housing_num)</code></pre> 
  <p><code>imputer</code>计算出了每个属性的中位数，并将结果保存在了实例变量<code>statistics_</code>中。只有属性<code>total_bedrooms</code>有缺失值，但是我们要确保一旦系统运行起来，新的数据中没有缺失值，所以安全的做法是将<code>imputer</code>应用到每个数值。使用这个“训练过的”<code>imputer</code>来对训练集进行转换，通过将缺失值替换为中位数：</p> 
  <pre class="has">
<code class="language-python">X = imputer.transform(housing_num)</code></pre> 
  <p>&nbsp;结果是一个普通的Numpy数组，包含有转换后的特征。如果你想将其放回到Pandas DataFrame中，也很简单：</p> 
  <pre class="has">
<code class="language-python">housing_tr = pd.DataFrame(X, columns=housing_num.columns)</code></pre> 
  <p><strong>2.处理文本和分类属性&nbsp;</strong></p> 
  <p>我们丢弃了分类属性<code>ocean_proximity</code>，因为它是一个文本属性，不能计算出中位数。大多数机器学习算法更喜欢和数字打交道，所以让我们把这些文本标签转换为数字。</p> 
  <p>Scikit-Learn为这个任务提供了一个转换量<code>LabelEncoder</code>：</p> 
  <pre class="has">
<code class="language-python">housing_cat = housing[['ocean_proximity']]
from sklearn.preprocessing import OrdinalEncoder
ordinal_encoder = OrdinalEncoder()
housing_cat_encoded = ordinal_encoder.fit_transform(housing_cat)</code></pre> 
  <p>查看映射表，编码器是通过属性<code>classes_</code>来学习的（“&lt;1H OCEAN”被映射为0，“INLAND”被映射为1，等等）：</p> 
  <pre class="has">
<code class="language-python">print(encoder.classes_)
#['&lt;1H OCEAN' 'INLAND' 'ISLAND' 'NEAR BAY' 'NEAR OCEAN']</code></pre> 
  <p>显然这样不对（比如，分类0和4比0和1更相似）。要解决这个问题，一个常见的方法是给每个分类创建一个二元属性：当分类是“&lt;1H OCEAN”，该属性为1（否则为0），当分类是“INLAND”，另一个属性等于1（否则为0），以此类推。这称作独热编码(One-Hot Encoding)，因为只有一个属性会等于1（热），其余会是0（冷）。</p> 
  <p>使用类<code>LabelBinarizer</code>，我们可以用一步执行这两个转换（从文本分类到整数分类，再从整数分类到独热矢量）：</p> 
  <pre class="has">
<code class="language-python">cat_encoder = OneHotEncoder(sparse=False)
housing_cat_1hot = cat_encoder.fit_transform(housing_cat)
housing_cat_1hot</code></pre> 
  <h2><img alt="" class="has" height="136" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116162523587.png" width="242"></h2> 
  <p><strong>3.自定义转换量&nbsp;</strong></p> 
  <p>尽管Scikit-Learn提供了许多有用的转换量，你还是需要自己动手写转换量执行任务，比如自定义的清理操作，或属性组合。你需要让自制的转换量与Scikit-Learn组件（比如pipeline）无缝衔接工作，因为Scikit-Learn是依赖鸭子类型的（而不是继承），你所需要做的是创建一个类并执行三个方法：<code>fit()</code>（返回<code>self</code>），<code>transform()</code>，和<code>fit_transform()</code>。通过添加<code>TransformerMixin</code>作为基类，可以很容易地得到最后一个。另外，如果你添加<code>BaseEstimator</code>作为基类（且构造器中避免使用<code>*args</code>和<code>**kargs</code>），你就能得到两个额外的方法（<code>get_params()</code>和<code>set_params()</code>），二者可以方便地进行超参数自动微调。例如，一个小转换量类添加了上面讨论的属性：</p> 
  <pre class="has">
<code class="language-python">from sklearn.base import BaseEstimator, TransformerMixin
rooms_ix, bedrooms_ix, population_ix, household_ix = 3, 4, 5, 6

class CombinedAttributesAdder(BaseEstimator, TransformerMixin):
    def __init__(self, add_bedrooms_per_room = True): # no *args or **kargs
        self.add_bedrooms_per_room = add_bedrooms_per_room
    def fit(self, X, y=None):
        return self  # nothing else to do
    def transform(self, X, y=None):
        rooms_per_household = X[:, rooms_ix] / X[:, household_ix]
        population_per_household = X[:, population_ix] / X[:, household_ix]
        if self.add_bedrooms_per_room:
            bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix]
            return np.c_[X, rooms_per_household, population_per_household,
                         bedrooms_per_room]
        else:
            return np.c_[X, rooms_per_household, population_per_household]

attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=False)
housing_extra_attribs = attr_adder.transform(housing.values)</code></pre> 
  <p><strong>4.特征缩放</strong></p> 
  <p>数据要做的最重要的转换之一是特征缩放。除了个别情况，当输入的数值属性量度不同时，机器学习算法的性能都不会好。这个规律也适用于房产数据：总房间数分布范围是6到39320，而收入中位数只分布在0到15。不需要对目标值进行缩放。</p> 
  <p>有两种常见的方法可以让所有的属性有相同的量度：线性函数归一化（Min-Max scaling）和标准化（standardization）。</p> 
  <p>线性函数归一化（许多人称其为归一化（normalization））很简单：值被转变、重新缩放，直到范围变成0到1。我们通过减去最小值，然后再除以最大值与最小值的差值，来进行归一化。Scikit-Learn提供了一个转换量<code>MinMaxScaler</code>来实现这个功能。它有一个超参数<code>feature_range</code>，可以让你改变范围，如果不希望范围是0到1。</p> 
  <p>标准化就很不同：首先减去平均值（所以标准化值的平均值总是0），然后除以方差，使得到的分布具有单位方差。与归一化不同，标准化不会限定值到某个特定的范围，这对某些算法可能构成问题（比如，神经网络常需要输入值得范围是0到1）。但是，标准化受到异常值的影响很小。例如，假设一个分区的收入中位数是100。归一化会将其它范围是0到15的值变为0-0.15，但是标准化不会受什么影响。Scikit-Learn提供了一个转换量<code>StandardScaler</code>来进行标准化。</p> 
  <p><strong>5.转换Pipeline</strong></p> 
  <p>你已经看到，存在许多数据转换步骤，需要按一定的顺序执行。幸运的是，Scikit-Learn提供了类<code>Pipeline</code>，来进行这一系列的转换。下面是一个数值属性的小pipeline，将替换缺失值、添加属性、替换文本值为数值的操作结合在一起。</p> 
  <pre class="has">
<code class="language-python">from sklearn.pipeline import FeatureUnion

num_attribs = list(housing_num)
cat_attribs = ["ocean_proximity"]

num_pipeline = Pipeline([
        ('selector', DataFrameSelector(num_attribs)),
        ('imputer', Imputer(strategy="median")),
        ('attribs_adder', CombinedAttributesAdder()),
('std_scaler', StandardScaler()),
    ])

cat_pipeline = Pipeline([
        ('selector', DataFrameSelector(cat_attribs)),
        ('label_binarizer', LabelBinarizer()),
    ])

full_pipeline = FeatureUnion(transformer_list=[
        ("num_pipeline", num_pipeline),
        ("cat_pipeline", cat_pipeline),
    ])</code></pre> 
  <pre class="has">
<code class="language-python">housing_prepared = full_pipeline.fit_transform(housing)
housing_prepared.shape  #(16513, 17)</code></pre> 
  <h2>五、选择模型，进行训练</h2> 
  <p><strong>1.在训练集上训练和评估</strong></p> 
  <p>(1)线性回归模型</p> 
  <pre class="has">
<code class="language-python">from sklearn.linear_model import LinearRegression

lin_reg = LinearRegression()
lin_reg.fit(housing_prepared, housing_labels)</code></pre> 
  <p>使用Scikit-Learn的<code>mean_squared_error</code>函数，用全部训练集来计算下这个回归模型的RMSE：</p> 
  <pre class="has">
<code class="language-python">from sklearn.metrics import mean_squared_error

housing_predictions = lin_reg.predict(housing_prepared)
lin_mse = mean_squared_error(housing_labels, housing_predictions)
lin_rmse = np.sqrt(lin_mse)
lin_rmse  #68628.19819848922</code></pre> 
  <p>大多数分区的<code>median_housing_values</code>位于120000美元到265000美元之间，因此预测误差$68628不能让人满意。这是一个模型欠拟合训练数据的例子。当这种情况发生时，意味着特征没有提供足够多的信息来做出一个好的预测，或者模型并不强大。就像前一章看到的，修复欠拟合的主要方法是选择一个更强大的模型，给训练算法提供更好的特征，或去掉模型上的限制。这个模型还没有正则化，所以排除了最后一个选项。你可以尝试添加更多特征（比如，人口的对数值），但是首先让我们尝试一个更为复杂的模型，看看效果。</p> 
  <p>(2)决策树</p> 
  <p>训练一个<code>DecisionTreeRegressor</code>。这是一个强大的模型，可以发现数据中复杂的非线性关系。代码：</p> 
  <pre class="has">
<code class="language-python">from sklearn.tree import DecisionTreeRegressor

tree_reg = DecisionTreeRegressor(random_state=42)
tree_reg.fit(housing_prepared, housing_labels)</code></pre> 
  <pre class="has">
<code class="language-python">housing_predictions = tree_reg.predict(housing_prepared)
tree_mse = mean_squared_error(housing_labels, housing_predictions)
tree_rmse = np.sqrt(tree_mse)
tree_rmse   #0.0</code></pre> 
  <p>&nbsp;没有误差？这个模型可能是绝对完美的吗？当然，更大可能性是这个模型严重过拟合数据。</p> 
  <p><strong>2.使用交叉验证做更佳的评估</strong></p> 
  <p>评估决策树模型的一种方法是用函数<code>train_test_split</code>来分割训练集，得到一个更小的训练集和一个验证集，然后用更小的训练集来训练模型，用验证集来评估。这需要一定工作量，并不难而且也可行。</p> 
  <p>另一种更好的方法是使用Scikit-Learn的交叉验证功能。下面的代码采用了K折交叉验证（K-fold cross-validation）：它随机地将训练集分成十个不同的子集，成为“折”，然后训练评估决策树模型10次，每次选一个不用的折来做评估，用其它9个来做训练。结果是一个包含10个评分的数组：</p> 
  <pre class="has">
<code class="language-python">from sklearn.model_selection import cross_val_score

scores = cross_val_score(tree_reg, housing_prepared, housing_labels,
                         scoring="neg_mean_squared_error", cv=10)
tree_rmse_scores = np.sqrt(-scores)</code></pre> 
  <p>&nbsp;决策树的结果：</p> 
  <pre class="has">
<code class="language-python">def display_scores(scores):
    print("Scores:", scores)
    print("Mean:", scores.mean())
    print("Standard deviation:", scores.std())

display_scores(tree_rmse_scores)</code></pre> 
  <p><img alt="" class="has" height="91" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116190951215.png" width="513"></p> 
  <p>计算线性回归模型的的相同分数&nbsp;：</p> 
  <pre class="has">
<code class="language-python">lin_scores = cross_val_score(lin_reg, housing_prepared, housing_labels,
                             scoring="neg_mean_squared_error", cv=10)
lin_rmse_scores = np.sqrt(-lin_scores)
display_scores(lin_rmse_scores)</code></pre> 
  <p><img alt="" class="has" height="96" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116191129115.png" width="500"></p> 
  <p>判断没错：决策树模型过拟合很严重，它的性能比线性回归模型还差。</p> 
  <p><strong>3.尝试新方法：随机森林&nbsp;</strong></p> 
  <pre class="has">
<code class="language-python">from sklearn.ensemble import RandomForestRegressor

forest_reg = RandomForestRegressor(n_estimators=10, random_state=42)
forest_reg.fit(housing_prepared, housing_labels)</code></pre> 
  <pre class="has">
<code class="language-python">from sklearn.model_selection import cross_val_score

forest_scores = cross_val_score(forest_reg, housing_prepared, housing_labels,
                                scoring="neg_mean_squared_error", cv=10)
forest_rmse_scores = np.sqrt(-forest_scores)
display_scores(forest_rmse_scores)</code></pre> 
  <p>&nbsp;<img alt="" class="has" height="89" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116191648763.png" width="515"></p> 
  <p>随机森林看起来很有希望。但是，训练集的评分仍然比验证集的评分低很多。解决过拟合可以通过简化模型，给模型加限制（即，规整化），或用更多的训练数据。&nbsp;</p> 
  <h2>六、微调模型</h2> 
  <p><strong>1.网格搜索</strong></p> 
  <p>微调的一种方法是手工调整超参数，直到找到一个好的超参数组合。这么做的话会非常冗长，你也可能没有时间探索多种组合。</p> 
  <p>你应该使用Scikit-Learn的<code>GridSearchCV</code>来做这项搜索工作。你所需要做的是告诉<code>GridSearchCV</code>要试验有哪些超参数，要试验什么值，<code>GridSearchCV</code>就能用交叉验证试验所有可能超参数值的组合。例如，下面的代码搜索了<code>RandomForestRegressor</code>超参数值的最佳组合：</p> 
  <pre class="has">
<code class="language-python">from sklearn.model_selection import GridSearchCV

param_grid = [
    {'n_estimators': [3, 10, 30], 'max_features': [2, 4, 6, 8]},
    {'bootstrap': [False], 'n_estimators': [3, 10], 'max_features': [2, 3, 4]},
  ]

forest_reg = RandomForestRegressor()

grid_search = GridSearchCV(forest_reg, param_grid, cv=5,
                           scoring='neg_mean_squared_error')

grid_search.fit(housing_prepared, housing_labels)</code></pre> 
  <p><code>param_grid</code>告诉Scikit-Learn首先评估所有的列在第一个<code>dict</code>中的<code>n_estimators</code>和<code>max_features</code>的3 × 4 = 12种组合（不用担心这些超参数的含义，会在第7章中解释）。然后尝试第二个<code>dict</code>中超参数的2 × 3 = 6种组合，这次会将超参数<code>bootstrap</code>设为<code>False</code>而不是<code>True</code>（后者是该超参数的默认值）。总之，网格搜索会探索12 + 6 = 18种<code>RandomForestRegressor</code>的超参数组合，会训练每个模型五次（因为用的是五折交叉验证）。换句话说，训练总共有18 × 5 = 90轮！折将要花费大量时间，完成后，你就能获得参数的最佳组合。</p> 
  <pre class="has">
<code class="language-python">grid_search.best_params_</code></pre> 
  <p><img alt="" class="has" height="21" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116193740560.png" width="279"></p> 
  <p>还能直接得到最佳的估计量：</p> 
  <pre class="has">
<code class="language-python">grid_search.best_estimator_</code></pre> 
  <p>&nbsp;也可以得到评估值：</p> 
  <pre class="has">
<code class="language-python">cvres = grid_search.cv_results_
for mean_score, params in zip(cvres["mean_test_score"], cvres["params"]):
    print(np.sqrt(-mean_score), params)</code></pre> 
  <p><img alt="" class="has" height="313" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116194104853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="571"></p> 
  <p><strong>2.随机搜索</strong></p> 
  <p>当探索相对较少的组合时，就像前面的例子，网格搜索还可以。但是当超参数的搜索空间很大时，最好使用<code>RandomizedSearchCV</code>。这个类的使用方法和类<code>GridSearchCV</code>很相似，但它不是尝试所有可能的组合，而是通过选择每个超参数的一个随机值的特定数量的随机组合。这个方法有两个优点：</p> 
  <ul>
   <li>如果你让随机搜索运行，比如1000次，它会探索每个超参数的1000个不同的值（而不是像网格搜索那样，只搜索每个超参数的几个值）。</li> 
   <li>你可以方便地通过设定搜索次数，控制超参数搜索的计算量。</li> 
  </ul>
  <p><strong>3.集成方法</strong></p> 
  <p>另一种微调系统的方法是将表现最好的模型组合起来。组合（集成）之后的性能通常要比单独的模型要好（就像随机森林要比单独的决策树要好），特别是当单独模型的误差类型不同时。</p> 
  <p><strong>4.分析最佳模型和它们的误差</strong></p> 
  <p>通过分析最佳模型，常常可以获得对问题更深的了解。比如，<code>RandomForestRegressor</code>可以指出每个属性对于做出准确预测的相对重要性：</p> 
  <pre class="has">
<code class="language-python">feature_importances = grid_search.best_estimator_.feature_importances_</code></pre> 
  <p><img alt="" class="has" height="73" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116194958646.png" width="503">&nbsp;&nbsp;</p> 
  <p>将重要性分数和属性名放到一起：&nbsp;</p> 
  <pre class="has">
<code class="language-python">extra_attribs = ["rooms_per_hhold", "pop_per_hhold", "bedrooms_per_room"]
#cat_encoder = cat_pipeline.named_steps["cat_encoder"] # old solution
cat_encoder = full_pipeline.named_transformers_["cat"]
cat_one_hot_attribs = list(cat_encoder.categories_[0])
attributes = num_attribs + extra_attribs + cat_one_hot_attribs
sorted(zip(feature_importances, attributes), reverse=True)</code></pre> 
  <p>&nbsp;有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类<code>ocean_proximity</code>就够了，所以可以丢弃掉其它的）。</p> 
  <p><img alt="" class="has" height="278" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190116195348728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDg2ODYx,size_16,color_FFFFFF,t_70" width="324"></p> 
  <p>有了这个信息，你就可以丢弃一些不那么重要的特征（比如，显然只要一个分类<code>ocean_proximity</code>就够了，所以可以丢弃掉其它的）。&nbsp;</p> 
  <h2>七、给出解决方案</h2> 
  <p><strong>用测试集评估系统：</strong></p> 
  <p>调节完系统之后，你终于有了一个性能足够好的系统。现在就可以用测试集评估最后的模型了。这个过程没有什么特殊的：从测试集得到预测值和标签，运行<code>full_pipeline</code>转换数据（调用<code>transform()</code>，而不是<code>fit_transform()</code>！），再用测试集评估最终模型：</p> 
  <pre class="has">
<code class="language-python">final_model = grid_search.best_estimator_

X_test = strat_test_set.drop("median_house_value", axis=1)
y_test = strat_test_set["median_house_value"].copy()

X_test_prepared = full_pipeline.transform(X_test)
final_predictions = final_model.predict(X_test_prepared)

final_mse = mean_squared_error(y_test, final_predictions)
final_rmse = np.sqrt(final_mse)   #47730.22690385927</code></pre> 
  <h2>八、部署、监控、维护系统</h2> 
  <p>很好，你被允许启动系统了！你需要为实际生产做好准备，特别是接入输入数据源，并编写测试。</p> 
  <p>你还需要编写监控代码，以固定间隔检测系统的实时表现，当发生下降时触发报警。这对于捕获突然的系统崩溃和性能下降十分重要。做监控很常见，是因为模型会随着数据的演化而性能下降，除非模型用新数据定期训练。</p> 
  <p>评估系统的表现需要对预测值采样并进行评估。这通常需要人来分析。分析者可能是领域专家，或者是众包平台（比如Amazon Mechanical Turk 或 CrowdFlower）的工人。不管采用哪种方法，你都需要将人工评估的pipeline植入系统。</p> 
  <p>你还要评估系统输入数据的质量。有时因为低质量的信号（比如失灵的传感器发送随机值，或另一个团队的输出停滞），系统的表现会逐渐变差，但可能需要一段时间，系统的表现才能下降到一定程度，触发警报。如果监测了系统的输入，你就可能尽量早的发现问题。对于线上学习系统，监测输入数据是非常重要的。</p> 
  <p>最后，你可能想定期用新数据训练模型。你应该尽可能自动化这个过程。如果不这么做，非常有可能你需要每隔至少六个月更新模型，系统的表现就会产生严重波动。如果你的系统是一个线上学习系统，你需要定期保存系统状态快照，好能方便地回滚到之前的工作状态。</p> 
  <p>&nbsp;</p> 
  <h2>完结！</h2> 
  <p>参考书籍《Scikit-Learn与TensorFlow机器学习实用指南》的第02、03章。</p> 
  <p>完整的代码<a href="https://github.com/ageron/handson-ml" rel="nofollow">https://github.com/ageron/handson-ml</a></p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
