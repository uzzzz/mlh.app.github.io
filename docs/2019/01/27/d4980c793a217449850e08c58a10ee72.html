<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Redis 备份、容灾及高可用实战 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Redis 备份、容灾及高可用实战" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Linux编程 点击右侧关注，免费入门到精通！ 来源丨java思维导图 一、Redis简单介绍 Redis是一个高性能的key-value非关系型数据库，由于其具有高性能的特性，支持高可用、持久化、多种数据结构、集群等，使其脱颖而出，成为常用的非关系型数据库。 此外，Redis的使用场景也比较多。 会话缓存（Session Cache） Redis缓存会话有非常好的优势，因为Redis提供持久化，在需要长时间保持会话的应用场景中，如购物车场景这样的场景中能提供很好的长会话支持，能给用户提供很好的购物体验。 全页缓存 在WordPress中，Pantheon提供了一个不错的插件wp-redis，这个插件能以最快的速度加载你曾经浏览过的页面。 队列 Reids提供list和set操作，这使得Redis能作为一个很好的消息队列平台来使用。 我们常通过Reids的队列功能做购买限制。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。也比较适合适用。 排名 Redis在内存中对数字进行递增或递减的操作实现得非常好。所以我们在很多排名的场景中会应用Redis来进行，比如小说网站对小说进行排名，根据排名，将排名靠前的小说推荐给用户。 发布/订阅 Redis提供发布和订阅功能，发布和订阅的场景很多，比如我们可以基于发布和订阅的脚本触发器，实现用Redis的发布和订阅功能建立起来的聊天系统。 此外还有很多其它场景，Redis都表现的不错。 二、Redis使用中单点故障问题 正是由于Redis具备多种优良特新，且应用场景非常丰富，以至于Redis在各个公司都有它存在的身影。那么随之而来的问题和风险也就来了。Redis虽然应用场景丰富，但部分公司在实践Redis应用的时候还是相对保守使用单节点部署，那为日后的维护带来了安全风险。 在2015年的时候，曾处理过一个因为单点故障原因导致的业务中断问题。当时的Redis都未采用分布式部署，采用单实例部署，并未考虑容灾方面的问题。 当时我们通过Redis服务器做用户购买优惠商品的行为控制，但后来由于未知原因Redis节点的服务器宕机了，导致我们无法对用户购买行为进行控制，造成了用户能够在一段时间内多次购买优惠商品的行为。 这种宕机事故可以说已经对公司造成了不可挽回的损失了，安全风险问题非常严重，作为当时运维这个系统的我来说有必要对这个问题进行修复和在架构上的改进。于是我开始了解决非分布式应用下Redis单点故障方面的研究学习。 三、非分布式场景下Redis应用的备份与容灾 Redis主从复制现在应该是很普遍了。常用的主从复制架构有如下两种架构方案。 常用Redis主从复制 方案一 这是最常见的一种架构，一个Master节点，两个Slave节点。客户端写数据的时候是写Master节点，读的时候，是读取两个Slave，这样实现读的扩展，减轻了Master节点读负载。 方案二 这种架构同样是一个Master和两个Slave。不同的是Master和Slave1使用keepalived进行VIP转移。Client连接Master的时候是通过VIP进行连接的。避免了方案一IP更改的情况。 Redis主从复制优点与不足 优点 实现了对master数据的备份，一旦master出现故障，slave节点可以提升为新的master，顶替旧的master继续提供服务 实现读扩展。使用主从复制架构， 一般都是为了实现读扩展。Master主要实现写功能， &nbsp;Slave实现读的功能 不足 架构方案一 当Master出现故障时，Client就与Master端断开连接，无法实现写功能，同时Slave也无法从Master进行复制。 此时需要经过如下操作(假设提升Slave1为Master): 在Slave1上执slaveof no one命令提升Slave1为新的Master节点。 在Slave1上配置为可写，这是因为大多数情况下，都将slave配置只读。 告诉Client端(也就是连接Redis的程序)新的Master节点的连接地址。 配置Slave2从新的Master进行数据复制。 架构方案二 当master出现故障后，Client可以连接到Slave1上进行数据操作，但是Slave1就成了一个单点，就出现了经常要避免的单点故障(single point of failure)。 之后需要经过如下操作： 在Slave1上执行slaveof no one命令提升Slave1为新的Master节点 在Slave1上配置为可写，这是因为大多数情况下，都将Slave配置只读 配置Slave2从新的Master进行数据复制 可以发现，无论是哪种架构方案都需要人工干预来进行故障转移(failover)。需要人工干预就增加了运维工作量，同时也对业务造成了巨大影响。这时候可以使用Redis的高可用方案-Sentinel 四、Redis Sentinel介绍 Redis Sentinel为Redis提供了高可用方案。从实践方面来说，使用Redis Sentinel可以创建一个无需人为干预就可以预防某些故障的Redis环境。 Redis Sentinel设计为分布式的架构，运行多个Sentinel进程来共同合作的。运行多个Sentinel进程合作，当多个Sentinel同一给定的master无法再继续提供服务，就会执行故障检测，这会降低误报的可能性。 五、Redis Sentinel功能 Redis Sentinel在Redis高可用方案中主要作用有如下功能： 监控 Sentinel会不断的检查master和slave是否像预期那样正常运行 通知 通过API，Sentinel能够通知系统管理员、程序监控的Redis实例出现了故障 自动故障转移 如果master不像预想中那样正常运行，Sentinel可以启动故障转移过程，其中的一个slave会提成为master，其它slave会重新配置来使用新的master，使用Redis服务的应用程序，当连接时，也会被通知使用新的地址。 配置提供者 Sentinel可以做为客户端服务发现的认证源：客户端连接Sentinel来获取目前负责给定服务的Redis master地址。如果发生故障转移，Sentinel会报告新的地址。 六、Redis Sentinel架构 七、Redis Sentinel实现原理 Sentinel集群对自身和Redis主从复制进行监控。当发现Master节点出现故障时，会经过如下步骤： 1）Sentinel之间进行选举，选举出一个leader，由选举出的leader进行failover 2）Sentinel leader选取slave节点中的一个slave作为新的Master节点。对slave选举需要对slave进行选举的方法如下： a)&nbsp;与master断开时间 &nbsp;如果与master断开的时间超过down-after-milliseconds(sentinel配置） * 10秒加上从sentinel判定master不可用到sentinel开始执行故障转移之间的时间，就认为该slave不适合提升为master。 b)&nbsp;slave优先级 每个slave都有优先级，保存在redis.conf配置文件里。如果优先级相同，则继续进行。c) 复制偏移位置 复制偏移纪录着从master复制数据复制到哪里，复制偏移越大表明从master接受的数据越多，如果复制偏移量也一样，继续进行选举d)&nbsp;Run ID 选举具有最小Run ID的Slave作为新的Master 流程图如下： 3) &nbsp;Sentinel leader会在上一步选举的新master上执行slaveof no one操作，将其提升为master节点 4）Sentinel leader向其它slave发送命令，让剩余的slave成为新的master节点的slave 5）Sentinel leader会让原来的master降级为slave，当恢复正常工作，Sentinel leader会发送命令让其从新的master进行复制 以上failover操作均有sentinel自己独自完成，完全无需人工干预。 总结 使用sentinel实现了Redis的高可用，当master出现故障时，完全无需人工干预即可实现故障转移。避免了对业务的影响，提高了运维工作效率。 在部署sentinel的时候，建议使用奇数个sentinel节点，最少三个sentinel节点。 写在最后 由于sentinel知识点比较多，这里仅给大家进行介绍，让大家有个了解，想了解更多可与我联系。谢谢。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行" />
<meta property="og:description" content="Linux编程 点击右侧关注，免费入门到精通！ 来源丨java思维导图 一、Redis简单介绍 Redis是一个高性能的key-value非关系型数据库，由于其具有高性能的特性，支持高可用、持久化、多种数据结构、集群等，使其脱颖而出，成为常用的非关系型数据库。 此外，Redis的使用场景也比较多。 会话缓存（Session Cache） Redis缓存会话有非常好的优势，因为Redis提供持久化，在需要长时间保持会话的应用场景中，如购物车场景这样的场景中能提供很好的长会话支持，能给用户提供很好的购物体验。 全页缓存 在WordPress中，Pantheon提供了一个不错的插件wp-redis，这个插件能以最快的速度加载你曾经浏览过的页面。 队列 Reids提供list和set操作，这使得Redis能作为一个很好的消息队列平台来使用。 我们常通过Reids的队列功能做购买限制。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。也比较适合适用。 排名 Redis在内存中对数字进行递增或递减的操作实现得非常好。所以我们在很多排名的场景中会应用Redis来进行，比如小说网站对小说进行排名，根据排名，将排名靠前的小说推荐给用户。 发布/订阅 Redis提供发布和订阅功能，发布和订阅的场景很多，比如我们可以基于发布和订阅的脚本触发器，实现用Redis的发布和订阅功能建立起来的聊天系统。 此外还有很多其它场景，Redis都表现的不错。 二、Redis使用中单点故障问题 正是由于Redis具备多种优良特新，且应用场景非常丰富，以至于Redis在各个公司都有它存在的身影。那么随之而来的问题和风险也就来了。Redis虽然应用场景丰富，但部分公司在实践Redis应用的时候还是相对保守使用单节点部署，那为日后的维护带来了安全风险。 在2015年的时候，曾处理过一个因为单点故障原因导致的业务中断问题。当时的Redis都未采用分布式部署，采用单实例部署，并未考虑容灾方面的问题。 当时我们通过Redis服务器做用户购买优惠商品的行为控制，但后来由于未知原因Redis节点的服务器宕机了，导致我们无法对用户购买行为进行控制，造成了用户能够在一段时间内多次购买优惠商品的行为。 这种宕机事故可以说已经对公司造成了不可挽回的损失了，安全风险问题非常严重，作为当时运维这个系统的我来说有必要对这个问题进行修复和在架构上的改进。于是我开始了解决非分布式应用下Redis单点故障方面的研究学习。 三、非分布式场景下Redis应用的备份与容灾 Redis主从复制现在应该是很普遍了。常用的主从复制架构有如下两种架构方案。 常用Redis主从复制 方案一 这是最常见的一种架构，一个Master节点，两个Slave节点。客户端写数据的时候是写Master节点，读的时候，是读取两个Slave，这样实现读的扩展，减轻了Master节点读负载。 方案二 这种架构同样是一个Master和两个Slave。不同的是Master和Slave1使用keepalived进行VIP转移。Client连接Master的时候是通过VIP进行连接的。避免了方案一IP更改的情况。 Redis主从复制优点与不足 优点 实现了对master数据的备份，一旦master出现故障，slave节点可以提升为新的master，顶替旧的master继续提供服务 实现读扩展。使用主从复制架构， 一般都是为了实现读扩展。Master主要实现写功能， &nbsp;Slave实现读的功能 不足 架构方案一 当Master出现故障时，Client就与Master端断开连接，无法实现写功能，同时Slave也无法从Master进行复制。 此时需要经过如下操作(假设提升Slave1为Master): 在Slave1上执slaveof no one命令提升Slave1为新的Master节点。 在Slave1上配置为可写，这是因为大多数情况下，都将slave配置只读。 告诉Client端(也就是连接Redis的程序)新的Master节点的连接地址。 配置Slave2从新的Master进行数据复制。 架构方案二 当master出现故障后，Client可以连接到Slave1上进行数据操作，但是Slave1就成了一个单点，就出现了经常要避免的单点故障(single point of failure)。 之后需要经过如下操作： 在Slave1上执行slaveof no one命令提升Slave1为新的Master节点 在Slave1上配置为可写，这是因为大多数情况下，都将Slave配置只读 配置Slave2从新的Master进行数据复制 可以发现，无论是哪种架构方案都需要人工干预来进行故障转移(failover)。需要人工干预就增加了运维工作量，同时也对业务造成了巨大影响。这时候可以使用Redis的高可用方案-Sentinel 四、Redis Sentinel介绍 Redis Sentinel为Redis提供了高可用方案。从实践方面来说，使用Redis Sentinel可以创建一个无需人为干预就可以预防某些故障的Redis环境。 Redis Sentinel设计为分布式的架构，运行多个Sentinel进程来共同合作的。运行多个Sentinel进程合作，当多个Sentinel同一给定的master无法再继续提供服务，就会执行故障检测，这会降低误报的可能性。 五、Redis Sentinel功能 Redis Sentinel在Redis高可用方案中主要作用有如下功能： 监控 Sentinel会不断的检查master和slave是否像预期那样正常运行 通知 通过API，Sentinel能够通知系统管理员、程序监控的Redis实例出现了故障 自动故障转移 如果master不像预想中那样正常运行，Sentinel可以启动故障转移过程，其中的一个slave会提成为master，其它slave会重新配置来使用新的master，使用Redis服务的应用程序，当连接时，也会被通知使用新的地址。 配置提供者 Sentinel可以做为客户端服务发现的认证源：客户端连接Sentinel来获取目前负责给定服务的Redis master地址。如果发生故障转移，Sentinel会报告新的地址。 六、Redis Sentinel架构 七、Redis Sentinel实现原理 Sentinel集群对自身和Redis主从复制进行监控。当发现Master节点出现故障时，会经过如下步骤： 1）Sentinel之间进行选举，选举出一个leader，由选举出的leader进行failover 2）Sentinel leader选取slave节点中的一个slave作为新的Master节点。对slave选举需要对slave进行选举的方法如下： a)&nbsp;与master断开时间 &nbsp;如果与master断开的时间超过down-after-milliseconds(sentinel配置） * 10秒加上从sentinel判定master不可用到sentinel开始执行故障转移之间的时间，就认为该slave不适合提升为master。 b)&nbsp;slave优先级 每个slave都有优先级，保存在redis.conf配置文件里。如果优先级相同，则继续进行。c) 复制偏移位置 复制偏移纪录着从master复制数据复制到哪里，复制偏移越大表明从master接受的数据越多，如果复制偏移量也一样，继续进行选举d)&nbsp;Run ID 选举具有最小Run ID的Slave作为新的Master 流程图如下： 3) &nbsp;Sentinel leader会在上一步选举的新master上执行slaveof no one操作，将其提升为master节点 4）Sentinel leader向其它slave发送命令，让剩余的slave成为新的master节点的slave 5）Sentinel leader会让原来的master降级为slave，当恢复正常工作，Sentinel leader会发送命令让其从新的master进行复制 以上failover操作均有sentinel自己独自完成，完全无需人工干预。 总结 使用sentinel实现了Redis的高可用，当master出现故障时，完全无需人工干预即可实现故障转移。避免了对业务的影响，提高了运维工作效率。 在部署sentinel的时候，建议使用奇数个sentinel节点，最少三个sentinel节点。 写在最后 由于sentinel知识点比较多，这里仅给大家进行介绍，让大家有个了解，想了解更多可与我联系。谢谢。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-27T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Linux编程 点击右侧关注，免费入门到精通！ 来源丨java思维导图 一、Redis简单介绍 Redis是一个高性能的key-value非关系型数据库，由于其具有高性能的特性，支持高可用、持久化、多种数据结构、集群等，使其脱颖而出，成为常用的非关系型数据库。 此外，Redis的使用场景也比较多。 会话缓存（Session Cache） Redis缓存会话有非常好的优势，因为Redis提供持久化，在需要长时间保持会话的应用场景中，如购物车场景这样的场景中能提供很好的长会话支持，能给用户提供很好的购物体验。 全页缓存 在WordPress中，Pantheon提供了一个不错的插件wp-redis，这个插件能以最快的速度加载你曾经浏览过的页面。 队列 Reids提供list和set操作，这使得Redis能作为一个很好的消息队列平台来使用。 我们常通过Reids的队列功能做购买限制。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。也比较适合适用。 排名 Redis在内存中对数字进行递增或递减的操作实现得非常好。所以我们在很多排名的场景中会应用Redis来进行，比如小说网站对小说进行排名，根据排名，将排名靠前的小说推荐给用户。 发布/订阅 Redis提供发布和订阅功能，发布和订阅的场景很多，比如我们可以基于发布和订阅的脚本触发器，实现用Redis的发布和订阅功能建立起来的聊天系统。 此外还有很多其它场景，Redis都表现的不错。 二、Redis使用中单点故障问题 正是由于Redis具备多种优良特新，且应用场景非常丰富，以至于Redis在各个公司都有它存在的身影。那么随之而来的问题和风险也就来了。Redis虽然应用场景丰富，但部分公司在实践Redis应用的时候还是相对保守使用单节点部署，那为日后的维护带来了安全风险。 在2015年的时候，曾处理过一个因为单点故障原因导致的业务中断问题。当时的Redis都未采用分布式部署，采用单实例部署，并未考虑容灾方面的问题。 当时我们通过Redis服务器做用户购买优惠商品的行为控制，但后来由于未知原因Redis节点的服务器宕机了，导致我们无法对用户购买行为进行控制，造成了用户能够在一段时间内多次购买优惠商品的行为。 这种宕机事故可以说已经对公司造成了不可挽回的损失了，安全风险问题非常严重，作为当时运维这个系统的我来说有必要对这个问题进行修复和在架构上的改进。于是我开始了解决非分布式应用下Redis单点故障方面的研究学习。 三、非分布式场景下Redis应用的备份与容灾 Redis主从复制现在应该是很普遍了。常用的主从复制架构有如下两种架构方案。 常用Redis主从复制 方案一 这是最常见的一种架构，一个Master节点，两个Slave节点。客户端写数据的时候是写Master节点，读的时候，是读取两个Slave，这样实现读的扩展，减轻了Master节点读负载。 方案二 这种架构同样是一个Master和两个Slave。不同的是Master和Slave1使用keepalived进行VIP转移。Client连接Master的时候是通过VIP进行连接的。避免了方案一IP更改的情况。 Redis主从复制优点与不足 优点 实现了对master数据的备份，一旦master出现故障，slave节点可以提升为新的master，顶替旧的master继续提供服务 实现读扩展。使用主从复制架构， 一般都是为了实现读扩展。Master主要实现写功能， &nbsp;Slave实现读的功能 不足 架构方案一 当Master出现故障时，Client就与Master端断开连接，无法实现写功能，同时Slave也无法从Master进行复制。 此时需要经过如下操作(假设提升Slave1为Master): 在Slave1上执slaveof no one命令提升Slave1为新的Master节点。 在Slave1上配置为可写，这是因为大多数情况下，都将slave配置只读。 告诉Client端(也就是连接Redis的程序)新的Master节点的连接地址。 配置Slave2从新的Master进行数据复制。 架构方案二 当master出现故障后，Client可以连接到Slave1上进行数据操作，但是Slave1就成了一个单点，就出现了经常要避免的单点故障(single point of failure)。 之后需要经过如下操作： 在Slave1上执行slaveof no one命令提升Slave1为新的Master节点 在Slave1上配置为可写，这是因为大多数情况下，都将Slave配置只读 配置Slave2从新的Master进行数据复制 可以发现，无论是哪种架构方案都需要人工干预来进行故障转移(failover)。需要人工干预就增加了运维工作量，同时也对业务造成了巨大影响。这时候可以使用Redis的高可用方案-Sentinel 四、Redis Sentinel介绍 Redis Sentinel为Redis提供了高可用方案。从实践方面来说，使用Redis Sentinel可以创建一个无需人为干预就可以预防某些故障的Redis环境。 Redis Sentinel设计为分布式的架构，运行多个Sentinel进程来共同合作的。运行多个Sentinel进程合作，当多个Sentinel同一给定的master无法再继续提供服务，就会执行故障检测，这会降低误报的可能性。 五、Redis Sentinel功能 Redis Sentinel在Redis高可用方案中主要作用有如下功能： 监控 Sentinel会不断的检查master和slave是否像预期那样正常运行 通知 通过API，Sentinel能够通知系统管理员、程序监控的Redis实例出现了故障 自动故障转移 如果master不像预想中那样正常运行，Sentinel可以启动故障转移过程，其中的一个slave会提成为master，其它slave会重新配置来使用新的master，使用Redis服务的应用程序，当连接时，也会被通知使用新的地址。 配置提供者 Sentinel可以做为客户端服务发现的认证源：客户端连接Sentinel来获取目前负责给定服务的Redis master地址。如果发生故障转移，Sentinel会报告新的地址。 六、Redis Sentinel架构 七、Redis Sentinel实现原理 Sentinel集群对自身和Redis主从复制进行监控。当发现Master节点出现故障时，会经过如下步骤： 1）Sentinel之间进行选举，选举出一个leader，由选举出的leader进行failover 2）Sentinel leader选取slave节点中的一个slave作为新的Master节点。对slave选举需要对slave进行选举的方法如下： a)&nbsp;与master断开时间 &nbsp;如果与master断开的时间超过down-after-milliseconds(sentinel配置） * 10秒加上从sentinel判定master不可用到sentinel开始执行故障转移之间的时间，就认为该slave不适合提升为master。 b)&nbsp;slave优先级 每个slave都有优先级，保存在redis.conf配置文件里。如果优先级相同，则继续进行。c) 复制偏移位置 复制偏移纪录着从master复制数据复制到哪里，复制偏移越大表明从master接受的数据越多，如果复制偏移量也一样，继续进行选举d)&nbsp;Run ID 选举具有最小Run ID的Slave作为新的Master 流程图如下： 3) &nbsp;Sentinel leader会在上一步选举的新master上执行slaveof no one操作，将其提升为master节点 4）Sentinel leader向其它slave发送命令，让剩余的slave成为新的master节点的slave 5）Sentinel leader会让原来的master降级为slave，当恢复正常工作，Sentinel leader会发送命令让其从新的master进行复制 以上failover操作均有sentinel自己独自完成，完全无需人工干预。 总结 使用sentinel实现了Redis的高可用，当master出现故障时，完全无需人工干预即可实现故障转移。避免了对业务的影响，提高了运维工作效率。 在部署sentinel的时候，建议使用奇数个sentinel节点，最少三个sentinel节点。 写在最后 由于sentinel知识点比较多，这里仅给大家进行介绍，让大家有个了解，想了解更多可与我联系。谢谢。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行","@type":"BlogPosting","url":"/2019/01/27/d4980c793a217449850e08c58a10ee72.html","headline":"Redis 备份、容灾及高可用实战","dateModified":"2019-01-27T00:00:00+08:00","datePublished":"2019-01-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/01/27/d4980c793a217449850e08c58a10ee72.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Redis 备份、容灾及高可用实战</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/XUfq62QbuNhyG8Y9IxZUNMLyjv7k7dsq3bia9CRMmdkOM1WyLYEHlib4MFfrqRE97iaUqJ7NwhZEoHu0U8NCXWzsA/640?wx_fmt=gif" alt="640?wx_fmt=gif"></p>
   <p style="min-height:1em;text-align:center;"><a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span class="js_jump_icon h5_image_link"><img style="letter-spacing:.544px;text-align:justify;color:rgb(62,62,62);width:76px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/XUfq62QbuNiaFZIbV1icByYIGKRlUcFt6IBMGhWJcyxibORgs6MEmSnJlA3ibibR7ibpudwZAbFZdqISttPaQTBkPPtQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></span></a></p>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span style="font-family:'宋体', SimSun;"><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"><strong>Linux编程</strong></span></strong></span></a>
   <span style="font-family:'黑体', SimHei;"><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong></span>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span style="letter-spacing:.544px;color:rgb(165,165,165);font-family:'黑体', SimHei;"><span>点击右侧关注，免费入门到精通！</span></span></a>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span class="js_jump_icon h5_image_link"><img style="width:56px;" title="1081255447.jpg" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/XUfq62QbuNiaFZIbV1icByYIGKRlUcFt6IldAicZsKdD8KXBZkWQz1eHWULt7Sy2XUdKWbFt8oY6f6nL5deCuF9yg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></span></a>
   <p><br></p>
   <h3 style="letter-spacing:1px;"><span style="font-size:14px;color:rgb(136,136,136);">来源丨java思维导图</span></h3>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></h3>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">一、Redis简单介绍</span></h3>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Redis是一个高性能的key-value非关系型数据库，由于其具有高性能的特性，支持高可用、持久化、多种数据结构、集群等，使其脱颖而出，成为常用的非关系型数据库。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">此外，Redis的使用场景也比较多。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">会话缓存（Session Cache）</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>Redis缓存会话有非常好的优势，因为Redis提供持久化，在需要长时间保持会话的应用场景中，如购物车场景这样的场景中能提供很好的长会话支持，能给用户提供很好的购物体验。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">全页缓存</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>在WordPress中，Pantheon提供了一个不错的插件wp-redis，这个插件能以最快的速度加载你曾经浏览过的页面。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">队列</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>Reids提供list和set操作，这使得Redis能作为一个很好的消息队列平台来使用。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">我们常通过Reids的队列功能做购买限制。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。也比较适合适用。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">排名</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>Redis在内存中对数字进行递增或递减的操作实现得非常好。所以我们在很多排名的场景中会应用Redis来进行，比如小说网站对小说进行排名，根据排名，将排名靠前的小说推荐给用户。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">发布/订阅</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>Redis提供发布和订阅功能，发布和订阅的场景很多，比如我们可以基于发布和订阅的脚本触发器，实现用Redis的发布和订阅功能建立起来的聊天系统。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">此外还有很多其它场景，Redis都表现的不错。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">二、Redis使用中单点故障问题</span></h3>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">正是由于Redis具备多种优良特新，且应用场景非常丰富，以至于Redis在各个公司都有它存在的身影。那么随之而来的问题和风险也就来了。Redis虽然应用场景丰富，但部分公司在实践Redis应用的时候还是相对保守使用单节点部署，那为日后的维护带来了安全风险。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">在2015年的时候，曾处理过一个因为单点故障原因导致的业务中断问题。当时的Redis都未采用分布式部署，采用单实例部署，并未考虑容灾方面的问题。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">当时我们通过Redis服务器做用户购买优惠商品的行为控制，但后来由于未知原因Redis节点的服务器宕机了，导致我们无法对用户购买行为进行控制，造成了用户能够在一段时间内多次购买优惠商品的行为。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">这种宕机事故可以说已经对公司造成了不可挽回的损失了，安全风险问题非常严重，作为当时运维这个系统的我来说有必要对这个问题进行修复和在架构上的改进。于是我开始了解决非分布式应用下Redis单点故障方面的研究学习。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">三、非分布式场景下Redis应用的备份与容灾</span></h3>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Redis主从复制现在应该是很普遍了。常用的主从复制架构有如下两种架构方案。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <h4 style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">常用Redis主从复制</span></strong></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">方案一</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img style="width:297px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/2LJz3aY3IViaGMQABLuKXlTqgKVOy9TuTxEhJDFkYkPdkdI6jjbNdh5Bl1Es7ykrcgicBKYraiae8CvgsYXnM00NQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">这是最常见的一种架构，一个Master节点，两个Slave节点。客户端写数据的时候是写Master节点，读的时候，是读取两个Slave，这样实现读的扩展，减轻了Master节点读负载。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">方案二<br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img style="width:388px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/2LJz3aY3IViaGMQABLuKXlTqgKVOy9TuT46tR3mAbFwLA69aNeycQibMyQOqttmhDtO4Gd9Ac7YTnYIfjjD29GgQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">这种架构同样是一个Master和两个Slave。不同的是Master和Slave1使用keepalived进行VIP转移。Client连接Master的时候是通过VIP进行连接的。避免了方案一IP更改的情况。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <h4 style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">Redis主从复制优点与不足</span></strong></h4>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">优点</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">实现了对master数据的备份，一旦master出现故障，slave节点可以提升为新的master，顶替旧的master继续提供服务</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">实现读扩展。使用主从复制架构， 一般都是为了实现读扩展。Master主要实现写功能， &nbsp;Slave实现读的功能</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">不足</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>架构方案一</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>当Master出现故障时，Client就与Master端断开连接，无法实现写功能，同时Slave也无法从Master进行复制。<br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img style="width:347px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/2LJz3aY3IViaGMQABLuKXlTqgKVOy9TuTPNVB4TWuVzuZrRI1zMib8IUvfURPeicFgfAICU9ndP092AziaznagNWgA/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">此时需要经过如下操作(假设提升Slave1为Master):</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">在Slave1上执slaveof no one命令提升Slave1为新的Master节点。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">在Slave1上配置为可写，这是因为大多数情况下，都将slave配置只读。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">告诉Client端(也就是连接Redis的程序)新的Master节点的连接地址。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">配置Slave2从新的Master进行数据复制。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">架构方案二</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>当master出现故障后，Client可以连接到Slave1上进行数据操作，但是Slave1就成了一个单点，就出现了经常要避免的单点故障(single point of failure)。<br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/tzia4bcY5HEKmv17xjefYaPnNDepTHAu2yBfRO8xDf7hM6TgVpjkYgBAAhAPKiabFMONqFgl1NSPJG8fvWBHM2Vg/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="letter-spacing:1px;"><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">之后需要经过如下操作：</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">在Slave1上执行slaveof no one命令提升Slave1为新的Master节点</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">在Slave1上配置为可写，这是因为大多数情况下，都将Slave配置只读</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">配置Slave2从新的Master进行数据复制</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">可以发现，无论是哪种架构方案都需要人工干预来进行故障转移(failover)。需要人工干预就增加了运维工作量，同时也对业务造成了巨大影响。这时候可以使用Redis的高可用方案-Sentinel</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">四、Redis Sentinel介绍</span></h3>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Redis Sentinel为Redis提供了高可用方案。从实践方面来说，使用Redis Sentinel可以创建一个无需人为干预就可以预防某些故障的Redis环境。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>Redis Sentinel设计为分布式的架构，运行多个Sentinel进程来共同合作的。运行多个Sentinel进程合作，当多个Sentinel同一给定的master无法再继续提供服务，就会执行故障检测，这会降低误报的可能性。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">五、Redis Sentinel功能</span></h3>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Redis Sentinel在Redis高可用方案中主要作用有如下功能：</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">监控</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>Sentinel会不断的检查master和slave是否像预期那样正常运行</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">通知</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>通过API，Sentinel能够通知系统管理员、程序监控的Redis实例出现了故障</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">自动故障转移</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>如果master不像预想中那样正常运行，Sentinel可以启动故障转移过程，其中的一个slave会提成为master，其它slave会重新配置来使用新的master，使用Redis服务的应用程序，当连接时，也会被通知使用新的地址。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">配置提供者</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>Sentinel可以做为客户端服务发现的认证源：客户端连接Sentinel来获取目前负责给定服务的Redis master地址。如果发生故障转移，Sentinel会报告新的地址。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">六、Redis Sentinel架构</span></h3>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/tzia4bcY5HEKmv17xjefYaPnNDepTHAu2x3Rfy6CpKOKXwiam1pAEBsicCTE14pD6eRu79UeF1Cu9551shvibFzSTA/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="letter-spacing:1px;"><br></p>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">七、Redis Sentinel实现原理</span></h3>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Sentinel集群对自身和Redis主从复制进行监控。当发现Master节点出现故障时，会经过如下步骤：</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">1）Sentinel之间进行选举，选举出一个leader，由选举出的leader进行failover</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">2）Sentinel leader选取slave节点中的一个slave作为新的Master节点。对slave选举需要对slave进行选举的方法如下：</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">a)&nbsp;与master断开时间</span></strong></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>&nbsp;如果与master断开的时间超过down-after-milliseconds(sentinel配置） * 10秒加上从sentinel判定master不可用到sentinel开始执行故障转移之间的时间，就认为该slave不适合提升为master。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br><strong>b)&nbsp;slave优先级</strong></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>每个slave都有优先级，保存在redis.conf配置文件里。如果优先级相同，则继续进行。<br><br><strong>c) 复制偏移位置</strong></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>复制偏移纪录着从master复制数据复制到哪里，复制偏移越大表明从master接受的数据越多，如果复制偏移量也一样，继续进行选举<br><br><strong>d)&nbsp;Run ID</strong></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>选举具有最小Run ID的Slave作为新的Master</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>流程图如下：<br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/tzia4bcY5HEKmv17xjefYaPnNDepTHAu2vY3nodBZ5ezDbGVsljyuLze8diaU2yqzLEnTf7Pdakic1bqvyJGJibRFg/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">3) &nbsp;Sentinel leader会在上一步选举的新master上执行slaveof no one操作，将其提升为master节点</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">4）Sentinel leader向其它slave发送命令，让剩余的slave成为新的master节点的slave</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">5）Sentinel leader会让原来的master降级为slave，当恢复正常工作，Sentinel leader会发送命令让其从新的master进行复制</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>以上failover操作均有sentinel自己独自完成，完全无需人工干预。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">总结</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">使用sentinel实现了Redis的高可用，当master出现故障时，完全无需人工干预即可实现故障转移。避免了对业务的影响，提高了运维工作效率。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br>在部署sentinel的时候，建议使用奇数个sentinel节点，最少三个sentinel节点。</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <h3 style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">写在最后</span></h3>
   <p><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">由于sentinel知识点比较多，这里仅给大家进行介绍，让大家有个了解，想了解更多可与我联系。谢谢。</span></p>
   <p><br></p>
   <p style="text-align:center;letter-spacing:1.5px;"><span style="color:rgb(255,255,255);"><strong><span style="font-size:20px;">&nbsp;推荐↓↓↓&nbsp;</span></strong></span></p>
   <img style="vertical-align:middle;width:313px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/IwiaNBuWUDUzX3vMCt57DzWD1FUkicYK3C3VObzhyt4YU3rXujLwMXHoHqpB6B72h44DNib9J9jbQHk3giaxAeABWg/640?wx_fmt=png" alt="640?wx_fmt=png">
   <p><strong>长</strong></p>
   <p><strong>按</strong></p>
   <p><strong>关</strong></p>
   <p><strong>注</strong></p>
   <p style="letter-spacing:0px;"><strong><span style="font-size:18px;">👉</span></strong><span style="font-size:17px;"><strong>【</strong></span><a href="https://mp.weixin.qq.com/s?__biz=MzUzMDc0NzU4Nw==&amp;mid=2247483768&amp;idx=1&amp;sn=4ef4f1510616baa395c507e32bb439d7&amp;scene=21#wechat_redirect" rel="nofollow" style="text-decoration:underline;color:rgb(255,79,121);font-size:17px;"><span style="color:rgb(255,79,121);font-size:17px;"><strong>16个技术公众号</strong></span></a><span style="font-size:17px;"><strong>】都在这里！</strong></span></p>
   <p><span style="color:rgb(136,136,136);font-size:15px;">涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。</span></p>
   <img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/ol72Wnba7fLkfGhCjKwHfZOmHMkVTIomtmHARHGo86u52ZIGicxfPPFBQ85dBUWf3trqDHPUuN7E2e26DpvfJdQ/640?wx_fmt=png" alt="640?wx_fmt=png">万水千山总是情，点个 “
   <strong><span style="color:rgb(0,112,192);">好看</span></strong>” 行不行
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
