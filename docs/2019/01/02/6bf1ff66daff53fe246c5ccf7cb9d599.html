<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>在IDEA中运用fabric-sdk-java与fabric-samples中的fabcar项目进行交互 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="在IDEA中运用fabric-sdk-java与fabric-samples中的fabcar项目进行交互" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37459945/article/details/85633133 一、准备 1、在项目中引入maven依赖 &lt;!-- https://mvnrepository.com/artifact/org.hyperledger.fabric-sdk-java/fabric-sdk-java --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hyperledger.fabric-sdk-java&lt;/groupId&gt; &lt;artifactId&gt;fabric-sdk-java&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 2、编写测试代码（包含Fabcar.java、CertUtils.java两个类） Fabcar.java import org.hyperledger.fabric.sdk.ChaincodeID; import org.hyperledger.fabric.sdk.Channel; import org.hyperledger.fabric.sdk.Enrollment; import org.hyperledger.fabric.sdk.HFClient; import org.hyperledger.fabric.sdk.ProposalResponse; import org.hyperledger.fabric.sdk.QueryByChaincodeRequest; import org.hyperledger.fabric.sdk.TransactionProposalRequest; import org.hyperledger.fabric.sdk.User; import org.hyperledger.fabric.sdk.security.CryptoSuite; import org.hyperledger.fabric_ca.sdk.HFCAClient; import java.util.Collection; import java.util.Collections; import java.util.Properties; import java.util.Set; public class Fabcar{ public static void main(String[] args) throws Exception { enroll(&quot;admin&quot;, &quot;adminpw&quot;, &quot;cert&quot;); queryCar(); updateCar(); Thread.sleep(5000); queryCar(); } /** * 更新账本 * @throws Exception */ private static void updateCar() throws Exception { HFClient client = HFClient.createNewInstance(); Channel channel = initChannel(client); // 构建proposal TransactionProposalRequest req = client.newTransactionProposalRequest(); // 指定要调用的chaincode ChaincodeID cid = ChaincodeID.newBuilder().setName(&quot;fabcar&quot;).build(); req.setChaincodeID(cid); req.setFcn(&quot;changeCarOwner&quot;); req.setArgs(new String[]{&quot;CAR1&quot;, &quot;Marry&quot;}); System.out.println(&quot;Executing for &quot; + &quot;CAR1&quot;); // 发送proprosal Collection&lt;ProposalResponse&gt; resps = channel.sendTransactionProposal(req); // 提交给orderer节点 channel.sendTransaction(resps); } /** * 查询账本 * @throws Exception */ private static void queryCar() throws Exception { HFClient client = HFClient.createNewInstance(); Channel channel = initChannel(client); String key = &quot;CAR1&quot;; // 构建proposal QueryByChaincodeRequest req = client.newQueryProposalRequest(); // 指定要调用的chaincode ChaincodeID cid = ChaincodeID.newBuilder().setName(&quot;fabcar&quot;).build(); req.setChaincodeID(cid); req.setFcn(&quot;queryCar&quot;); req.setArgs(new String[] { key }); System.out.println(&quot;Querying for &quot; + key); Collection&lt;ProposalResponse&gt; resps = channel.queryByChaincode(req); for (ProposalResponse resp : resps) { String payload = new String(resp.getChaincodeActionResponsePayload()); System.out.println(&quot;response: &quot; + payload); } } /** * 用户注册, 保存证书和私钥 * * @param username Fabric CA Admin用户的用户名 * @param password Fabric CA Admin用户的密码 * @param certDir 目录名, 用来保存证书和私钥 * @throws Exception */ private static void enroll(String username, String password, String certDir) throws Exception { HFClient client = HFClient.createNewInstance(); CryptoSuite cs = CryptoSuite.Factory.getCryptoSuite(); client.setCryptoSuite(cs); Properties prop = new Properties(); prop.put(&quot;verify&quot;, false); HFCAClient caClient = HFCAClient.createNewInstance(&quot;http://192.168.80.134:7054&quot;, prop); caClient.setCryptoSuite(cs); // enrollment保存了证书和私钥 Enrollment enrollment = caClient.enroll(username, password); System.out.println(enrollment.getCert()); // 保存到本地文件 CertUtils.saveEnrollment(enrollment, certDir, username); } private static Channel initChannel(HFClient client) throws Exception { CryptoSuite cs = CryptoSuite.Factory.getCryptoSuite(); client.setCryptoSuite(cs); client.setUserContext( new CarUser( &quot;admin&quot;, CertUtils.loadEnrollment(&quot;cert&quot;, &quot;admin&quot;) ) ); // 初始化channel Channel channel = client.newChannel(&quot;mychannel&quot;); channel.addPeer(client.newPeer(&quot;peer&quot;, &quot;grpc://192.168.80.134:7051&quot;)); // 指定排序节点地址, 无论是后面执行查询还是更新都必须指定排序节点 channel.addOrderer(client.newOrderer(&quot;orderer&quot;, &quot;grpc://192.168.80.134:7050&quot;)); channel.initialize(); return channel; } } /** * User接口实现类 */ class CarUser implements User { private String name; private Enrollment enrollment; public CarUser(String name, Enrollment enrollment) { this.name = name; this.enrollment = enrollment; } @Override public String getName() { return this.name; } @Override public Set&lt;String&gt; getRoles() { return Collections.emptySet(); } @Override public String getAccount() { return &quot;&quot;; } @Override public String getAffiliation() { return &quot;&quot;; } @Override public Enrollment getEnrollment() { return this.enrollment; } @Override public String getMspId() { return &quot;Org1MSP&quot;; } } CertUtils.java import org.hyperledger.fabric.sdk.Enrollment; import javax.xml.bind.DatatypeConverter; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStreamReader; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.security.GeneralSecurityException; import java.security.KeyFactory; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.spec.InvalidKeySpecException; import java.security.spec.PKCS8EncodedKeySpec; public class CertUtils { private CertUtils() {} /** * 保存cert, key到文件 * @param enrollment Client返回的Enrollment对象 * @param dir 要保存的目录 * @param name 用户名 * @throws IOException */ public static void saveEnrollment(Enrollment enrollment, String dir, String name) throws IOException { if (null == enrollment) { throw new IllegalStateException(&quot;enrollment cannot be null&quot;); } // 保存cert String certFileName = String.join(&quot;&quot;, dir, File.separator, name, &quot;.cert&quot;); try (FileOutputStream certOut = new FileOutputStream(certFileName)) { certOut.write(enrollment.getCert().getBytes()); } catch (IOException ex) { throw ex; } // 保存private key String keyFileName = String.join(&quot;&quot;, dir, File.separator, name, &quot;.priv&quot;); try (FileOutputStream keyOut = new FileOutputStream(keyFileName)) { StringBuilder sb = new StringBuilder(300); sb.append(&quot;-----BEGIN PRIVATE KEY-----\n&quot;); String priKey = DatatypeConverter.printBase64Binary(enrollment.getKey().getEncoded()); // 每64个字符输出一个换行 int LEN = priKey.length(); for (int ix = 0; ix &lt; LEN; ++ix) { sb.append(priKey.charAt(ix)); if ((ix + 1) % 64 == 0) { sb.append(&#39;\n&#39;); } } sb.append(&quot;\n-----END PRIVATE KEY-----\n&quot;); keyOut.write(sb.toString().getBytes()); } catch (Exception e) { throw e; } } /** * 从文件中读取身份信息 * @param dir * @param name * @return * @throws IOException * @throws NoSuchAlgorithmException * @throws InvalidKeySpecException */ public static Enrollment loadEnrollment(String dir, String name) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, GeneralSecurityException { byte[] certBuf = Files.readAllBytes(Paths.get(dir, name + &quot;.cert&quot;)); String cert = new String(certBuf); // 读取文件, 构造PrivateKey对象 PrivateKey key = loadPrivateKey(Paths.get(dir, name + &quot;.priv&quot;)); return new MyEnrollment(key, cert); } /*** * loading private key from .pem-formatted file, ECDSA algorithm * (from some example on StackOverflow, slightly changed) * @param fileName - file with the key * @return Private Key usable * @throws IOException * @throws GeneralSecurityException */ private static PrivateKey loadPrivateKey(Path fileName) throws IOException, GeneralSecurityException { PrivateKey key = null; try (FileInputStream is = new FileInputStream(fileName.toString())) { BufferedReader br = new BufferedReader(new InputStreamReader(is)); StringBuilder builder = new StringBuilder(); boolean inKey = false; for (String line = br.readLine(); line != null; line = br.readLine()) { if (!inKey) { if (line.startsWith(&quot;-----BEGIN &quot;) &amp;&amp; line.endsWith(&quot; PRIVATE KEY-----&quot;)) { inKey = true; } continue; } else { if (line.startsWith(&quot;-----END &quot;) &amp;&amp; line.endsWith(&quot; PRIVATE KEY-----&quot;)) { inKey = false; break; } builder.append(line); } } byte[] encoded = DatatypeConverter.parseBase64Binary(builder.toString()); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded); // KeyFactory kf = KeyFactory.getInstance(&quot;ECDSA&quot;); KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;); key = kf.generatePrivate(keySpec); } catch (Exception e) { throw e; } return key; } } class MyEnrollment implements Enrollment { private PrivateKey privateKey; private String cert; public MyEnrollment(PrivateKey privateKey, String cert) { this.privateKey = privateKey; this.cert = cert; } @Override public PrivateKey getKey() { return this.privateKey; } @Override public String getCert() { return this.cert; } } 3、新建一个cert文件夹，用于保存cert和key 二、执行步骤 1、启动fabcar网络。参考之前的笔记（不需要用node）： http://note.youdao.com/noteshare?id=08cba7c7957649ad31049483b42f3067&amp;sub=F7517602136F4A2F9785CBB21110D1B2 root@ubuntu:~/demo# cd fabric-samples/fabcar #进入项目目录 root@ubuntu:~/demo/fabric-samples/fabcar# ./startFabric.sh #启动fabcar 2、执行Fabcar.java中的main()方法，先执行enroll()注册用户，然后可进行查询和更新操作（由于延迟原因，更新之后立马查询的话值可能还没来得及更新）。查询更新后的值如下： 三、上传自己编写的chaincode，并进行交互 1、上传chaincode 分析fabcar的源码发现此项目中fabric调用链码的路径为 github.com/fabcar/go， 其实前面省略了$GOPATH/src/,完整路径应该为 $GOPATH/src/github.com/fabcar/go，将自己编写的链码放到此目录下（可以利用docker的volume映射，此项目中映射为路径fabric-samples1/chaincode/fabcar/go），注意最好只放一个链码，将原来的链码删除，这里为了区分是不同的链码，将fabcar.go改为test01.go，除了下面的初始化数据改了之外（将Ford0改为了Ford），其它内容均一样。 2、修改脚本文件（ startFabric.sh）关于链码操作的命令（主要是将原来的fabcar改为test01，这里的名称不一定要跟链码文件名称一样，也可以改为test02等其他名称。若需要修改其他参数则根据具体链码的情况而定） 3、关闭之前的网络 docker rm -f $(docker ps -aq) #关闭所有正在运行的容器 docker network prune #移除网络 docker volume prune #移除映射 4、启动网络并查询（参考步骤二，但注意在程序中将查询的链码名称改为test01），结果如下 四、问题 1、若将fabcar关闭，修改链码文件初始化数据，将脚本命令中的链码名称改为test02，然后再启动网络查询数据会更新（这是正常的）。但是若将脚本中的链码名称改回test01，启动网络查询，发现查询到的数据是原来test01中的数据（此时链码中的初始化数据已经改为了test02的数据，应该为test02的数据）。也就是说如果一个链码名称查询到的数据只是第一次安装此链码的内容数据，后面尽管链码内容更改了，但只要名称不变，查询结果还是不变。 个人猜想是网络关闭时数据并没有完全清空。请知道的同学给个意见。。。 已经找到答案。原因是产生了镜像没有删除，如下图所示： 将类似这样的镜像删除即可： docker rmi [IMAGE _ID] 参考： 1、https://github.com/wanghongfei/hyperledger-fabric-java-SDK-demo 2、https://www.jianshu.com/p/3d61e8c46f43" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37459945/article/details/85633133 一、准备 1、在项目中引入maven依赖 &lt;!-- https://mvnrepository.com/artifact/org.hyperledger.fabric-sdk-java/fabric-sdk-java --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hyperledger.fabric-sdk-java&lt;/groupId&gt; &lt;artifactId&gt;fabric-sdk-java&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 2、编写测试代码（包含Fabcar.java、CertUtils.java两个类） Fabcar.java import org.hyperledger.fabric.sdk.ChaincodeID; import org.hyperledger.fabric.sdk.Channel; import org.hyperledger.fabric.sdk.Enrollment; import org.hyperledger.fabric.sdk.HFClient; import org.hyperledger.fabric.sdk.ProposalResponse; import org.hyperledger.fabric.sdk.QueryByChaincodeRequest; import org.hyperledger.fabric.sdk.TransactionProposalRequest; import org.hyperledger.fabric.sdk.User; import org.hyperledger.fabric.sdk.security.CryptoSuite; import org.hyperledger.fabric_ca.sdk.HFCAClient; import java.util.Collection; import java.util.Collections; import java.util.Properties; import java.util.Set; public class Fabcar{ public static void main(String[] args) throws Exception { enroll(&quot;admin&quot;, &quot;adminpw&quot;, &quot;cert&quot;); queryCar(); updateCar(); Thread.sleep(5000); queryCar(); } /** * 更新账本 * @throws Exception */ private static void updateCar() throws Exception { HFClient client = HFClient.createNewInstance(); Channel channel = initChannel(client); // 构建proposal TransactionProposalRequest req = client.newTransactionProposalRequest(); // 指定要调用的chaincode ChaincodeID cid = ChaincodeID.newBuilder().setName(&quot;fabcar&quot;).build(); req.setChaincodeID(cid); req.setFcn(&quot;changeCarOwner&quot;); req.setArgs(new String[]{&quot;CAR1&quot;, &quot;Marry&quot;}); System.out.println(&quot;Executing for &quot; + &quot;CAR1&quot;); // 发送proprosal Collection&lt;ProposalResponse&gt; resps = channel.sendTransactionProposal(req); // 提交给orderer节点 channel.sendTransaction(resps); } /** * 查询账本 * @throws Exception */ private static void queryCar() throws Exception { HFClient client = HFClient.createNewInstance(); Channel channel = initChannel(client); String key = &quot;CAR1&quot;; // 构建proposal QueryByChaincodeRequest req = client.newQueryProposalRequest(); // 指定要调用的chaincode ChaincodeID cid = ChaincodeID.newBuilder().setName(&quot;fabcar&quot;).build(); req.setChaincodeID(cid); req.setFcn(&quot;queryCar&quot;); req.setArgs(new String[] { key }); System.out.println(&quot;Querying for &quot; + key); Collection&lt;ProposalResponse&gt; resps = channel.queryByChaincode(req); for (ProposalResponse resp : resps) { String payload = new String(resp.getChaincodeActionResponsePayload()); System.out.println(&quot;response: &quot; + payload); } } /** * 用户注册, 保存证书和私钥 * * @param username Fabric CA Admin用户的用户名 * @param password Fabric CA Admin用户的密码 * @param certDir 目录名, 用来保存证书和私钥 * @throws Exception */ private static void enroll(String username, String password, String certDir) throws Exception { HFClient client = HFClient.createNewInstance(); CryptoSuite cs = CryptoSuite.Factory.getCryptoSuite(); client.setCryptoSuite(cs); Properties prop = new Properties(); prop.put(&quot;verify&quot;, false); HFCAClient caClient = HFCAClient.createNewInstance(&quot;http://192.168.80.134:7054&quot;, prop); caClient.setCryptoSuite(cs); // enrollment保存了证书和私钥 Enrollment enrollment = caClient.enroll(username, password); System.out.println(enrollment.getCert()); // 保存到本地文件 CertUtils.saveEnrollment(enrollment, certDir, username); } private static Channel initChannel(HFClient client) throws Exception { CryptoSuite cs = CryptoSuite.Factory.getCryptoSuite(); client.setCryptoSuite(cs); client.setUserContext( new CarUser( &quot;admin&quot;, CertUtils.loadEnrollment(&quot;cert&quot;, &quot;admin&quot;) ) ); // 初始化channel Channel channel = client.newChannel(&quot;mychannel&quot;); channel.addPeer(client.newPeer(&quot;peer&quot;, &quot;grpc://192.168.80.134:7051&quot;)); // 指定排序节点地址, 无论是后面执行查询还是更新都必须指定排序节点 channel.addOrderer(client.newOrderer(&quot;orderer&quot;, &quot;grpc://192.168.80.134:7050&quot;)); channel.initialize(); return channel; } } /** * User接口实现类 */ class CarUser implements User { private String name; private Enrollment enrollment; public CarUser(String name, Enrollment enrollment) { this.name = name; this.enrollment = enrollment; } @Override public String getName() { return this.name; } @Override public Set&lt;String&gt; getRoles() { return Collections.emptySet(); } @Override public String getAccount() { return &quot;&quot;; } @Override public String getAffiliation() { return &quot;&quot;; } @Override public Enrollment getEnrollment() { return this.enrollment; } @Override public String getMspId() { return &quot;Org1MSP&quot;; } } CertUtils.java import org.hyperledger.fabric.sdk.Enrollment; import javax.xml.bind.DatatypeConverter; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStreamReader; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.security.GeneralSecurityException; import java.security.KeyFactory; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.spec.InvalidKeySpecException; import java.security.spec.PKCS8EncodedKeySpec; public class CertUtils { private CertUtils() {} /** * 保存cert, key到文件 * @param enrollment Client返回的Enrollment对象 * @param dir 要保存的目录 * @param name 用户名 * @throws IOException */ public static void saveEnrollment(Enrollment enrollment, String dir, String name) throws IOException { if (null == enrollment) { throw new IllegalStateException(&quot;enrollment cannot be null&quot;); } // 保存cert String certFileName = String.join(&quot;&quot;, dir, File.separator, name, &quot;.cert&quot;); try (FileOutputStream certOut = new FileOutputStream(certFileName)) { certOut.write(enrollment.getCert().getBytes()); } catch (IOException ex) { throw ex; } // 保存private key String keyFileName = String.join(&quot;&quot;, dir, File.separator, name, &quot;.priv&quot;); try (FileOutputStream keyOut = new FileOutputStream(keyFileName)) { StringBuilder sb = new StringBuilder(300); sb.append(&quot;-----BEGIN PRIVATE KEY-----\n&quot;); String priKey = DatatypeConverter.printBase64Binary(enrollment.getKey().getEncoded()); // 每64个字符输出一个换行 int LEN = priKey.length(); for (int ix = 0; ix &lt; LEN; ++ix) { sb.append(priKey.charAt(ix)); if ((ix + 1) % 64 == 0) { sb.append(&#39;\n&#39;); } } sb.append(&quot;\n-----END PRIVATE KEY-----\n&quot;); keyOut.write(sb.toString().getBytes()); } catch (Exception e) { throw e; } } /** * 从文件中读取身份信息 * @param dir * @param name * @return * @throws IOException * @throws NoSuchAlgorithmException * @throws InvalidKeySpecException */ public static Enrollment loadEnrollment(String dir, String name) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, GeneralSecurityException { byte[] certBuf = Files.readAllBytes(Paths.get(dir, name + &quot;.cert&quot;)); String cert = new String(certBuf); // 读取文件, 构造PrivateKey对象 PrivateKey key = loadPrivateKey(Paths.get(dir, name + &quot;.priv&quot;)); return new MyEnrollment(key, cert); } /*** * loading private key from .pem-formatted file, ECDSA algorithm * (from some example on StackOverflow, slightly changed) * @param fileName - file with the key * @return Private Key usable * @throws IOException * @throws GeneralSecurityException */ private static PrivateKey loadPrivateKey(Path fileName) throws IOException, GeneralSecurityException { PrivateKey key = null; try (FileInputStream is = new FileInputStream(fileName.toString())) { BufferedReader br = new BufferedReader(new InputStreamReader(is)); StringBuilder builder = new StringBuilder(); boolean inKey = false; for (String line = br.readLine(); line != null; line = br.readLine()) { if (!inKey) { if (line.startsWith(&quot;-----BEGIN &quot;) &amp;&amp; line.endsWith(&quot; PRIVATE KEY-----&quot;)) { inKey = true; } continue; } else { if (line.startsWith(&quot;-----END &quot;) &amp;&amp; line.endsWith(&quot; PRIVATE KEY-----&quot;)) { inKey = false; break; } builder.append(line); } } byte[] encoded = DatatypeConverter.parseBase64Binary(builder.toString()); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded); // KeyFactory kf = KeyFactory.getInstance(&quot;ECDSA&quot;); KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;); key = kf.generatePrivate(keySpec); } catch (Exception e) { throw e; } return key; } } class MyEnrollment implements Enrollment { private PrivateKey privateKey; private String cert; public MyEnrollment(PrivateKey privateKey, String cert) { this.privateKey = privateKey; this.cert = cert; } @Override public PrivateKey getKey() { return this.privateKey; } @Override public String getCert() { return this.cert; } } 3、新建一个cert文件夹，用于保存cert和key 二、执行步骤 1、启动fabcar网络。参考之前的笔记（不需要用node）： http://note.youdao.com/noteshare?id=08cba7c7957649ad31049483b42f3067&amp;sub=F7517602136F4A2F9785CBB21110D1B2 root@ubuntu:~/demo# cd fabric-samples/fabcar #进入项目目录 root@ubuntu:~/demo/fabric-samples/fabcar# ./startFabric.sh #启动fabcar 2、执行Fabcar.java中的main()方法，先执行enroll()注册用户，然后可进行查询和更新操作（由于延迟原因，更新之后立马查询的话值可能还没来得及更新）。查询更新后的值如下： 三、上传自己编写的chaincode，并进行交互 1、上传chaincode 分析fabcar的源码发现此项目中fabric调用链码的路径为 github.com/fabcar/go， 其实前面省略了$GOPATH/src/,完整路径应该为 $GOPATH/src/github.com/fabcar/go，将自己编写的链码放到此目录下（可以利用docker的volume映射，此项目中映射为路径fabric-samples1/chaincode/fabcar/go），注意最好只放一个链码，将原来的链码删除，这里为了区分是不同的链码，将fabcar.go改为test01.go，除了下面的初始化数据改了之外（将Ford0改为了Ford），其它内容均一样。 2、修改脚本文件（ startFabric.sh）关于链码操作的命令（主要是将原来的fabcar改为test01，这里的名称不一定要跟链码文件名称一样，也可以改为test02等其他名称。若需要修改其他参数则根据具体链码的情况而定） 3、关闭之前的网络 docker rm -f $(docker ps -aq) #关闭所有正在运行的容器 docker network prune #移除网络 docker volume prune #移除映射 4、启动网络并查询（参考步骤二，但注意在程序中将查询的链码名称改为test01），结果如下 四、问题 1、若将fabcar关闭，修改链码文件初始化数据，将脚本命令中的链码名称改为test02，然后再启动网络查询数据会更新（这是正常的）。但是若将脚本中的链码名称改回test01，启动网络查询，发现查询到的数据是原来test01中的数据（此时链码中的初始化数据已经改为了test02的数据，应该为test02的数据）。也就是说如果一个链码名称查询到的数据只是第一次安装此链码的内容数据，后面尽管链码内容更改了，但只要名称不变，查询结果还是不变。 个人猜想是网络关闭时数据并没有完全清空。请知道的同学给个意见。。。 已经找到答案。原因是产生了镜像没有删除，如下图所示： 将类似这样的镜像删除即可： docker rmi [IMAGE _ID] 参考： 1、https://github.com/wanghongfei/hyperledger-fabric-java-SDK-demo 2、https://www.jianshu.com/p/3d61e8c46f43" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-02T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37459945/article/details/85633133 一、准备 1、在项目中引入maven依赖 &lt;!-- https://mvnrepository.com/artifact/org.hyperledger.fabric-sdk-java/fabric-sdk-java --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hyperledger.fabric-sdk-java&lt;/groupId&gt; &lt;artifactId&gt;fabric-sdk-java&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 2、编写测试代码（包含Fabcar.java、CertUtils.java两个类） Fabcar.java import org.hyperledger.fabric.sdk.ChaincodeID; import org.hyperledger.fabric.sdk.Channel; import org.hyperledger.fabric.sdk.Enrollment; import org.hyperledger.fabric.sdk.HFClient; import org.hyperledger.fabric.sdk.ProposalResponse; import org.hyperledger.fabric.sdk.QueryByChaincodeRequest; import org.hyperledger.fabric.sdk.TransactionProposalRequest; import org.hyperledger.fabric.sdk.User; import org.hyperledger.fabric.sdk.security.CryptoSuite; import org.hyperledger.fabric_ca.sdk.HFCAClient; import java.util.Collection; import java.util.Collections; import java.util.Properties; import java.util.Set; public class Fabcar{ public static void main(String[] args) throws Exception { enroll(&quot;admin&quot;, &quot;adminpw&quot;, &quot;cert&quot;); queryCar(); updateCar(); Thread.sleep(5000); queryCar(); } /** * 更新账本 * @throws Exception */ private static void updateCar() throws Exception { HFClient client = HFClient.createNewInstance(); Channel channel = initChannel(client); // 构建proposal TransactionProposalRequest req = client.newTransactionProposalRequest(); // 指定要调用的chaincode ChaincodeID cid = ChaincodeID.newBuilder().setName(&quot;fabcar&quot;).build(); req.setChaincodeID(cid); req.setFcn(&quot;changeCarOwner&quot;); req.setArgs(new String[]{&quot;CAR1&quot;, &quot;Marry&quot;}); System.out.println(&quot;Executing for &quot; + &quot;CAR1&quot;); // 发送proprosal Collection&lt;ProposalResponse&gt; resps = channel.sendTransactionProposal(req); // 提交给orderer节点 channel.sendTransaction(resps); } /** * 查询账本 * @throws Exception */ private static void queryCar() throws Exception { HFClient client = HFClient.createNewInstance(); Channel channel = initChannel(client); String key = &quot;CAR1&quot;; // 构建proposal QueryByChaincodeRequest req = client.newQueryProposalRequest(); // 指定要调用的chaincode ChaincodeID cid = ChaincodeID.newBuilder().setName(&quot;fabcar&quot;).build(); req.setChaincodeID(cid); req.setFcn(&quot;queryCar&quot;); req.setArgs(new String[] { key }); System.out.println(&quot;Querying for &quot; + key); Collection&lt;ProposalResponse&gt; resps = channel.queryByChaincode(req); for (ProposalResponse resp : resps) { String payload = new String(resp.getChaincodeActionResponsePayload()); System.out.println(&quot;response: &quot; + payload); } } /** * 用户注册, 保存证书和私钥 * * @param username Fabric CA Admin用户的用户名 * @param password Fabric CA Admin用户的密码 * @param certDir 目录名, 用来保存证书和私钥 * @throws Exception */ private static void enroll(String username, String password, String certDir) throws Exception { HFClient client = HFClient.createNewInstance(); CryptoSuite cs = CryptoSuite.Factory.getCryptoSuite(); client.setCryptoSuite(cs); Properties prop = new Properties(); prop.put(&quot;verify&quot;, false); HFCAClient caClient = HFCAClient.createNewInstance(&quot;http://192.168.80.134:7054&quot;, prop); caClient.setCryptoSuite(cs); // enrollment保存了证书和私钥 Enrollment enrollment = caClient.enroll(username, password); System.out.println(enrollment.getCert()); // 保存到本地文件 CertUtils.saveEnrollment(enrollment, certDir, username); } private static Channel initChannel(HFClient client) throws Exception { CryptoSuite cs = CryptoSuite.Factory.getCryptoSuite(); client.setCryptoSuite(cs); client.setUserContext( new CarUser( &quot;admin&quot;, CertUtils.loadEnrollment(&quot;cert&quot;, &quot;admin&quot;) ) ); // 初始化channel Channel channel = client.newChannel(&quot;mychannel&quot;); channel.addPeer(client.newPeer(&quot;peer&quot;, &quot;grpc://192.168.80.134:7051&quot;)); // 指定排序节点地址, 无论是后面执行查询还是更新都必须指定排序节点 channel.addOrderer(client.newOrderer(&quot;orderer&quot;, &quot;grpc://192.168.80.134:7050&quot;)); channel.initialize(); return channel; } } /** * User接口实现类 */ class CarUser implements User { private String name; private Enrollment enrollment; public CarUser(String name, Enrollment enrollment) { this.name = name; this.enrollment = enrollment; } @Override public String getName() { return this.name; } @Override public Set&lt;String&gt; getRoles() { return Collections.emptySet(); } @Override public String getAccount() { return &quot;&quot;; } @Override public String getAffiliation() { return &quot;&quot;; } @Override public Enrollment getEnrollment() { return this.enrollment; } @Override public String getMspId() { return &quot;Org1MSP&quot;; } } CertUtils.java import org.hyperledger.fabric.sdk.Enrollment; import javax.xml.bind.DatatypeConverter; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStreamReader; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.security.GeneralSecurityException; import java.security.KeyFactory; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.spec.InvalidKeySpecException; import java.security.spec.PKCS8EncodedKeySpec; public class CertUtils { private CertUtils() {} /** * 保存cert, key到文件 * @param enrollment Client返回的Enrollment对象 * @param dir 要保存的目录 * @param name 用户名 * @throws IOException */ public static void saveEnrollment(Enrollment enrollment, String dir, String name) throws IOException { if (null == enrollment) { throw new IllegalStateException(&quot;enrollment cannot be null&quot;); } // 保存cert String certFileName = String.join(&quot;&quot;, dir, File.separator, name, &quot;.cert&quot;); try (FileOutputStream certOut = new FileOutputStream(certFileName)) { certOut.write(enrollment.getCert().getBytes()); } catch (IOException ex) { throw ex; } // 保存private key String keyFileName = String.join(&quot;&quot;, dir, File.separator, name, &quot;.priv&quot;); try (FileOutputStream keyOut = new FileOutputStream(keyFileName)) { StringBuilder sb = new StringBuilder(300); sb.append(&quot;-----BEGIN PRIVATE KEY-----\\n&quot;); String priKey = DatatypeConverter.printBase64Binary(enrollment.getKey().getEncoded()); // 每64个字符输出一个换行 int LEN = priKey.length(); for (int ix = 0; ix &lt; LEN; ++ix) { sb.append(priKey.charAt(ix)); if ((ix + 1) % 64 == 0) { sb.append(&#39;\\n&#39;); } } sb.append(&quot;\\n-----END PRIVATE KEY-----\\n&quot;); keyOut.write(sb.toString().getBytes()); } catch (Exception e) { throw e; } } /** * 从文件中读取身份信息 * @param dir * @param name * @return * @throws IOException * @throws NoSuchAlgorithmException * @throws InvalidKeySpecException */ public static Enrollment loadEnrollment(String dir, String name) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, GeneralSecurityException { byte[] certBuf = Files.readAllBytes(Paths.get(dir, name + &quot;.cert&quot;)); String cert = new String(certBuf); // 读取文件, 构造PrivateKey对象 PrivateKey key = loadPrivateKey(Paths.get(dir, name + &quot;.priv&quot;)); return new MyEnrollment(key, cert); } /*** * loading private key from .pem-formatted file, ECDSA algorithm * (from some example on StackOverflow, slightly changed) * @param fileName - file with the key * @return Private Key usable * @throws IOException * @throws GeneralSecurityException */ private static PrivateKey loadPrivateKey(Path fileName) throws IOException, GeneralSecurityException { PrivateKey key = null; try (FileInputStream is = new FileInputStream(fileName.toString())) { BufferedReader br = new BufferedReader(new InputStreamReader(is)); StringBuilder builder = new StringBuilder(); boolean inKey = false; for (String line = br.readLine(); line != null; line = br.readLine()) { if (!inKey) { if (line.startsWith(&quot;-----BEGIN &quot;) &amp;&amp; line.endsWith(&quot; PRIVATE KEY-----&quot;)) { inKey = true; } continue; } else { if (line.startsWith(&quot;-----END &quot;) &amp;&amp; line.endsWith(&quot; PRIVATE KEY-----&quot;)) { inKey = false; break; } builder.append(line); } } byte[] encoded = DatatypeConverter.parseBase64Binary(builder.toString()); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded); // KeyFactory kf = KeyFactory.getInstance(&quot;ECDSA&quot;); KeyFactory kf = KeyFactory.getInstance(&quot;EC&quot;); key = kf.generatePrivate(keySpec); } catch (Exception e) { throw e; } return key; } } class MyEnrollment implements Enrollment { private PrivateKey privateKey; private String cert; public MyEnrollment(PrivateKey privateKey, String cert) { this.privateKey = privateKey; this.cert = cert; } @Override public PrivateKey getKey() { return this.privateKey; } @Override public String getCert() { return this.cert; } } 3、新建一个cert文件夹，用于保存cert和key 二、执行步骤 1、启动fabcar网络。参考之前的笔记（不需要用node）： http://note.youdao.com/noteshare?id=08cba7c7957649ad31049483b42f3067&amp;sub=F7517602136F4A2F9785CBB21110D1B2 root@ubuntu:~/demo# cd fabric-samples/fabcar #进入项目目录 root@ubuntu:~/demo/fabric-samples/fabcar# ./startFabric.sh #启动fabcar 2、执行Fabcar.java中的main()方法，先执行enroll()注册用户，然后可进行查询和更新操作（由于延迟原因，更新之后立马查询的话值可能还没来得及更新）。查询更新后的值如下： 三、上传自己编写的chaincode，并进行交互 1、上传chaincode 分析fabcar的源码发现此项目中fabric调用链码的路径为 github.com/fabcar/go， 其实前面省略了$GOPATH/src/,完整路径应该为 $GOPATH/src/github.com/fabcar/go，将自己编写的链码放到此目录下（可以利用docker的volume映射，此项目中映射为路径fabric-samples1/chaincode/fabcar/go），注意最好只放一个链码，将原来的链码删除，这里为了区分是不同的链码，将fabcar.go改为test01.go，除了下面的初始化数据改了之外（将Ford0改为了Ford），其它内容均一样。 2、修改脚本文件（ startFabric.sh）关于链码操作的命令（主要是将原来的fabcar改为test01，这里的名称不一定要跟链码文件名称一样，也可以改为test02等其他名称。若需要修改其他参数则根据具体链码的情况而定） 3、关闭之前的网络 docker rm -f $(docker ps -aq) #关闭所有正在运行的容器 docker network prune #移除网络 docker volume prune #移除映射 4、启动网络并查询（参考步骤二，但注意在程序中将查询的链码名称改为test01），结果如下 四、问题 1、若将fabcar关闭，修改链码文件初始化数据，将脚本命令中的链码名称改为test02，然后再启动网络查询数据会更新（这是正常的）。但是若将脚本中的链码名称改回test01，启动网络查询，发现查询到的数据是原来test01中的数据（此时链码中的初始化数据已经改为了test02的数据，应该为test02的数据）。也就是说如果一个链码名称查询到的数据只是第一次安装此链码的内容数据，后面尽管链码内容更改了，但只要名称不变，查询结果还是不变。 个人猜想是网络关闭时数据并没有完全清空。请知道的同学给个意见。。。 已经找到答案。原因是产生了镜像没有删除，如下图所示： 将类似这样的镜像删除即可： docker rmi [IMAGE _ID] 参考： 1、https://github.com/wanghongfei/hyperledger-fabric-java-SDK-demo 2、https://www.jianshu.com/p/3d61e8c46f43","@type":"BlogPosting","url":"/2019/01/02/6bf1ff66daff53fe246c5ccf7cb9d599.html","headline":"在IDEA中运用fabric-sdk-java与fabric-samples中的fabcar项目进行交互","dateModified":"2019-01-02T00:00:00+08:00","datePublished":"2019-01-02T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/01/02/6bf1ff66daff53fe246c5ccf7cb9d599.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>在IDEA中运用fabric-sdk-java与fabric-samples中的fabcar项目进行交互</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/m0_37459945/article/details/85633133 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>一、准备<br> 1、在项目中引入maven依赖</p> 
  <pre><code>&lt;!-- https://mvnrepository.com/artifact/org.hyperledger.fabric-sdk-java/fabric-sdk-java --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hyperledger.fabric-sdk-java&lt;/groupId&gt;
    &lt;artifactId&gt;fabric-sdk-java&lt;/artifactId&gt;
    &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
  <p>2、编写测试代码（包含Fabcar.java、CertUtils.java两个类）<br> Fabcar.java</p> 
  <pre><code>import org.hyperledger.fabric.sdk.ChaincodeID;
import org.hyperledger.fabric.sdk.Channel;
import org.hyperledger.fabric.sdk.Enrollment;
import org.hyperledger.fabric.sdk.HFClient;
import org.hyperledger.fabric.sdk.ProposalResponse;
import org.hyperledger.fabric.sdk.QueryByChaincodeRequest;
import org.hyperledger.fabric.sdk.TransactionProposalRequest;
import org.hyperledger.fabric.sdk.User;
import org.hyperledger.fabric.sdk.security.CryptoSuite;
import org.hyperledger.fabric_ca.sdk.HFCAClient;

import java.util.Collection;
import java.util.Collections;
import java.util.Properties;
import java.util.Set;

public class Fabcar{
    public static void main(String[] args) throws Exception {
        enroll("admin", "adminpw", "cert");
        queryCar();
        updateCar();
        Thread.sleep(5000);
        queryCar();
    }

    /**
     * 更新账本
     * @throws Exception
     */
    private static void updateCar() throws Exception {
        HFClient client = HFClient.createNewInstance();
        Channel channel = initChannel(client);

        // 构建proposal
        TransactionProposalRequest req = client.newTransactionProposalRequest();
        // 指定要调用的chaincode
        ChaincodeID cid = ChaincodeID.newBuilder().setName("fabcar").build();
        req.setChaincodeID(cid);
        req.setFcn("changeCarOwner");
        req.setArgs(new String[]{"CAR1", "Marry"});
        System.out.println("Executing for " + "CAR1");
        // 发送proprosal
        Collection&lt;ProposalResponse&gt; resps = channel.sendTransactionProposal(req);

        // 提交给orderer节点
        channel.sendTransaction(resps);
    }

    /**
     * 查询账本
     * @throws Exception
     */
    private static void queryCar() throws Exception {
        HFClient client = HFClient.createNewInstance();
        Channel channel = initChannel(client);

        String key = "CAR1";

        // 构建proposal
        QueryByChaincodeRequest req = client.newQueryProposalRequest();
        // 指定要调用的chaincode
        ChaincodeID cid = ChaincodeID.newBuilder().setName("fabcar").build();
        req.setChaincodeID(cid);
        req.setFcn("queryCar");
        req.setArgs(new String[] { key });
        System.out.println("Querying for " + key);
        Collection&lt;ProposalResponse&gt; resps = channel.queryByChaincode(req);

        for (ProposalResponse resp : resps) {
            String payload = new String(resp.getChaincodeActionResponsePayload());
            System.out.println("response: " + payload);
        }
    }

    /**
     * 用户注册, 保存证书和私钥
     *
     * @param username Fabric CA Admin用户的用户名
     * @param password Fabric CA Admin用户的密码
     * @param certDir 目录名, 用来保存证书和私钥
     * @throws Exception
     */
    private static void enroll(String username, String password, String certDir) throws Exception {
        HFClient client = HFClient.createNewInstance();
        CryptoSuite cs = CryptoSuite.Factory.getCryptoSuite();
        client.setCryptoSuite(cs);

        Properties prop = new Properties();
        prop.put("verify", false);
        HFCAClient caClient = HFCAClient.createNewInstance("http://192.168.80.134:7054", prop);
        caClient.setCryptoSuite(cs);


        // enrollment保存了证书和私钥
        Enrollment enrollment = caClient.enroll(username, password);
        System.out.println(enrollment.getCert());

        // 保存到本地文件
        CertUtils.saveEnrollment(enrollment, certDir, username);
    }

    private static Channel initChannel(HFClient client) throws Exception {
        CryptoSuite cs = CryptoSuite.Factory.getCryptoSuite();
        client.setCryptoSuite(cs);

        client.setUserContext(
                new CarUser(
                        "admin",
                        CertUtils.loadEnrollment("cert", "admin")
                )
        );

        // 初始化channel
        Channel channel = client.newChannel("mychannel");
        channel.addPeer(client.newPeer("peer", "grpc://192.168.80.134:7051"));
        // 指定排序节点地址, 无论是后面执行查询还是更新都必须指定排序节点
        channel.addOrderer(client.newOrderer("orderer", "grpc://192.168.80.134:7050"));
        channel.initialize();

        return channel;
    }
}

/**
 * User接口实现类
 */
class CarUser implements User {
    private String name;
    private Enrollment enrollment;

    public CarUser(String name, Enrollment enrollment) {
        this.name = name;
        this.enrollment = enrollment;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public Set&lt;String&gt; getRoles() {
        return Collections.emptySet();
    }

    @Override
    public String getAccount() {
        return "";
    }

    @Override
    public String getAffiliation() {
        return "";
    }

    @Override
    public Enrollment getEnrollment() {
        return this.enrollment;
    }

    @Override
    public String getMspId() {
        return "Org1MSP";
    }
}

</code></pre> 
  <p>CertUtils.java</p> 
  <pre><code>import org.hyperledger.fabric.sdk.Enrollment;
import javax.xml.bind.DatatypeConverter;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;

public class CertUtils {
    private CertUtils() {}

    /**
     * 保存cert, key到文件
     * @param enrollment Client返回的Enrollment对象
     * @param dir 要保存的目录
     * @param name 用户名
     * @throws IOException
     */
    public static void saveEnrollment(Enrollment enrollment, String dir, String name) throws IOException {
        if (null == enrollment) {
            throw new IllegalStateException("enrollment cannot be null");
        }

        // 保存cert
        String certFileName = String.join("", dir, File.separator, name, ".cert");
        try (FileOutputStream certOut = new FileOutputStream(certFileName)) {
            certOut.write(enrollment.getCert().getBytes());

        } catch (IOException ex) {
            throw ex;
        }

        // 保存private key
        String keyFileName = String.join("", dir, File.separator, name, ".priv");
        try (FileOutputStream keyOut = new FileOutputStream(keyFileName)) {
            StringBuilder sb = new StringBuilder(300);
            sb.append("-----BEGIN PRIVATE KEY-----\n");

            String priKey = DatatypeConverter.printBase64Binary(enrollment.getKey().getEncoded());
            // 每64个字符输出一个换行
            int LEN = priKey.length();
            for (int ix = 0; ix &lt; LEN; ++ix) {
                sb.append(priKey.charAt(ix));

                if ((ix + 1) % 64 == 0) {
                    sb.append('\n');
                }
            }

            sb.append("\n-----END PRIVATE KEY-----\n");
            keyOut.write(sb.toString().getBytes());

        } catch (Exception e) {
            throw e;
        }
    }

    /**
     * 从文件中读取身份信息
     * @param dir
     * @param name
     * @return
     * @throws IOException
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     */
    public static Enrollment loadEnrollment(String dir, String name)
            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, GeneralSecurityException {

        byte[] certBuf = Files.readAllBytes(Paths.get(dir, name + ".cert"));
        String cert = new String(certBuf);

        // 读取文件, 构造PrivateKey对象
        PrivateKey key = loadPrivateKey(Paths.get(dir, name + ".priv"));

        return new MyEnrollment(key, cert);
    }

    /***
     * loading private key from .pem-formatted file, ECDSA algorithm
     * (from some example on StackOverflow, slightly changed)
     * @param fileName - file with the key
     * @return Private Key usable
     * @throws IOException
     * @throws GeneralSecurityException
     */
    private static PrivateKey loadPrivateKey(Path fileName) throws IOException, GeneralSecurityException {
        PrivateKey key = null;

        try (FileInputStream is = new FileInputStream(fileName.toString())) {
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            StringBuilder builder = new StringBuilder();
            boolean inKey = false;
            for (String line = br.readLine(); line != null; line = br.readLine()) {
                if (!inKey) {
                    if (line.startsWith("-----BEGIN ") &amp;&amp; line.endsWith(" PRIVATE KEY-----")) {
                        inKey = true;
                    }
                    continue;
                } else {
                    if (line.startsWith("-----END ") &amp;&amp; line.endsWith(" PRIVATE KEY-----")) {
                        inKey = false;
                        break;
                    }
                    builder.append(line);
                }
            }

            byte[] encoded = DatatypeConverter.parseBase64Binary(builder.toString());
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
            // KeyFactory kf = KeyFactory.getInstance("ECDSA");
            KeyFactory kf = KeyFactory.getInstance("EC");
            key = kf.generatePrivate(keySpec);

        } catch (Exception e) {
            throw e;
        }

        return key;
    }

}

class MyEnrollment implements Enrollment {
    private PrivateKey privateKey;
    private String cert;

    public MyEnrollment(PrivateKey privateKey, String cert) {
        this.privateKey = privateKey;
        this.cert = cert;
    }

    @Override
    public PrivateKey getKey() {
        return this.privateKey;
    }

    @Override
    public String getCert() {
        return this.cert;
    }
}

</code></pre> 
  <p>3、新建一个cert文件夹，用于保存cert和key<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190102185820548.jpg" alt="在这里插入图片描述"><br> 二、执行步骤<br> 1、启动fabcar网络。参考之前的笔记（不需要用node）： <a href="http://note.youdao.com/noteshare?id=08cba7c7957649ad31049483b42f3067&amp;sub=F7517602136F4A2F9785CBB21110D1B2" rel="nofollow">http://note.youdao.com/noteshare?id=08cba7c7957649ad31049483b42f3067&amp;sub=F7517602136F4A2F9785CBB21110D1B2</a></p> 
  <pre><code>root@ubuntu:~/demo# cd fabric-samples/fabcar   #进入项目目录
root@ubuntu:~/demo/fabric-samples/fabcar# ./startFabric.sh  #启动fabcar
</code></pre> 
  <p>2、执行Fabcar.java中的main()方法，先执行enroll()注册用户，然后可进行查询和更新操作（由于延迟原因，更新之后立马查询的话值可能还没来得及更新）。查询更新后的值如下：<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190102190745257.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NDU5OTQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p>三、上传自己编写的chaincode，并进行交互<br> 1、上传chaincode<br> 分析fabcar的源码发现此项目中fabric调用链码的路径为 <a href="http://github.com/fabcar/go%EF%BC%8C" rel="nofollow">github.com/fabcar/go，</a> 其实前面省略了$GOPATH/src/,完整路径应该为 $GOPATH/src/github.com/fabcar/go，将自己编写的链码放到此目录下（可以利用docker的volume映射，此项目中映射为路径fabric-samples1/chaincode/fabcar/go），注意最好只放一个链码，将原来的链码删除，这里为了区分是不同的链码，将fabcar.go改为test01.go，除了下面的初始化数据改了之外（将Ford0改为了Ford），其它内容均一样。<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190104170211478.png" alt="在这里插入图片描述"><br> 2、修改脚本文件（ <a href="http://startFabric.sh" rel="nofollow">startFabric.sh</a>）关于链码操作的命令（主要是将原来的fabcar改为test01，这里的名称不一定要跟链码文件名称一样，也可以改为test02等其他名称。若需要修改其他参数则根据具体链码的情况而定）<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190104193130202.png" alt="在这里插入图片描述"><br> 3、关闭之前的网络</p> 
  <pre><code>docker rm -f $(docker ps -aq)   #关闭所有正在运行的容器
docker network prune  #移除网络
docker volume prune  #移除映射
</code></pre> 
  <p>4、启动网络并查询（参考步骤二，但注意在程序中将查询的链码名称改为test01），结果如下<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190104192238571.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/20190104192142596.png"><br> 四、问题<br> 1、若将fabcar关闭，修改链码文件初始化数据，将脚本命令中的链码名称改为test02，然后再启动网络查询数据会更新（这是正常的）。但是若将脚本中的链码名称改回test01，启动网络查询，发现查询到的数据是原来test01中的数据（此时链码中的初始化数据已经改为了test02的数据，应该为test02的数据）。也就是说如果一个链码名称查询到的数据只是第一次安装此链码的内容数据，后面尽管链码内容更改了，但只要名称不变，查询结果还是不变。<br> 个人猜想是网络关闭时数据并没有完全清空。请知道的同学给个意见。。。<br> 已经找到答案。原因是产生了镜像没有删除，如下图所示：<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190107171133647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NDU5OTQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 将类似这样的镜像删除即可：</p> 
  <pre><code>docker rmi [IMAGE _ID]
</code></pre> 
  <p>参考：<br> 1、<a href="https://github.com/wanghongfei/hyperledger-fabric-java-SDK-demo" rel="nofollow">https://github.com/wanghongfei/hyperledger-fabric-java-SDK-demo</a><br> 2、<a href="https://www.jianshu.com/p/3d61e8c46f43" rel="nofollow">https://www.jianshu.com/p/3d61e8c46f43</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
