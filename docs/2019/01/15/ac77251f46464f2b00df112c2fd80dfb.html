<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Deeplearning.ai 结构化机器学习项目 Week2 6-10 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Deeplearning.ai 结构化机器学习项目 Week2 6-10" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Deeplearning.ai 结构化机器学习项目 Week2 6-10 目录 如何解决数据不匹配 迁移学习 多任务学习 端对端的深度学习 如何解决数据不匹配 1.复习内容 在第四节中我们已经学习了一些偏差分析的策略。 如果人类水平(Human error)和训练水平(Training error)的相差很大，我们认为可能是训练不到位或者是神经网络规模不够大。我们可以通过给神经网络&quot;喂&quot;更多的数据或者用一个更大的神经网络来改善这一状况 如果训练水平(Training error)和Training-dev error 相差较大，可以认为这个神经网络训练出来的结果不具有很好的泛化能力、方差较大，造成了过拟合。处理过拟合的问题我们也学过一些正则化方式，比如L2正则化方法、dropout正则化方法、早停法(early stop)等等 如果Training-dev error 和Dev error相差过大可以认为出现了数据不匹配的问题，什么是数据不匹配的问题呢？举个例子，我们训练了一个猫的分类器，训练集来源是一些网络爬虫得到的猫的图片，这些图片比较专业、清晰、易于分辨，而开发集中的猫来源于手机，手机图片的像素较低、不清晰、有时候会出现抖动。我们的分类器没有见过这样的猫自然分辨能力比较差，这就是数据不匹配的问题，不是说我们的分类器训练的不够好，而是它&quot;孤陋寡闻&quot;了。那么我们应该如何解决这个问题这就是这节课的重点。 2. 解决数据不匹配的基本思路 数据不匹配就是说训练集和开发集的数据有偏差，就是你的神经网络不满足客户的开发需要。那很容易想到的就是针对客户的需要定制一个神经网络。所以我们第一步就是找到&quot;用户需要什么&quot;——也就是造成偏差的来源是什么。 举个例子：我们现在要设计一个安装在汽车内部的语音识别的导航系统，比如在开车的时候你打开系统，对系统说我要去某某街道，导航系统就会给你指明一条道路。现在这个系统因数据不匹配而导致识别率较低。我们通过分析训练集数据和实际错误的案例发现偏差的来源可能是：(1)在用户说话的时候，噪声干扰了系统的识别能力。(2)系统对于街道的门牌号识别率比较低(可能是训练集中缺少对于数字识别的训练，当然我们知道识别对门牌号对于导航正确性至关重要的)。(3)可能是因为用户的方言与口音导致的识别率较低。 找到了偏差来源，下一步就是有的放矢的去给神经网络喂一些相关数据来提高他这方面的识别能力(不会啥咱就学啥呗)。 当然很对情况收集一些方面的数据并没有想象中那么简单，所以这时候除了简单的收集数据外，人工合成一些方面的数据也能达到很好的效果。 沿着上面的例子说，对于导航系统无法准确识别街道门牌号和方言的问题，我们可以收集一些有关于数字和方言的音频文件，用神经网络训练(毕竟数字和方言音频还是相对容易获取的)。 而对于具有噪声环境下有效语境的音频收集起来可能是相对困难的，这时候我们就可以采用人工合成的方法来收集数据。我们首先可以找到一些噪声的音频和一些有效预料的音频，将两者随机结合成我们需要的音频并加入训练。 3.人工合成数据的主要事项 合成的几种元素一定要保持相对均等，就是不要一种要素比另一种要素多好多倍，否则会造成过拟合问题。 还是以汽车导航系统为例：如果你在合成过程中用1h的汽车噪声和10000h的无噪音音频合成，那么对于你这1h的噪音需要使用1万次，那么神经网络肯定会认定这噪音是很重要的因素从而造成对于这1h噪声的过拟合。虽然对于人来书1h的噪声和10000h噪声没什么区别，但是对于机器来说却不是，如下图所示：我们把所有噪声的集合看成一个整体，而我们收集的1h数据只是整体中很小的一部分，如果我们只对这1h的数据训练那势必系统的迁移能力不会太好。 迁移学习 1.什么是迁移学习？ 我们思考一个人，人学习是具有一定的迁移能力的，比如小时候别人教你1+1=2，你可能就会举一反三的说出来2+2=4。人可以基于已有经验来推断未知且相似的问题，这就是人的迁移能力。同样机器也是具有一定的迁移能力的，比如一个训练图像识别的神经网络可以通过一定的改变，变成一个用于识别x光诊断的神经网络；一个经过训练的语音识别系统可以经过一系列的改变变成一个唤醒系统(唤醒系统：我们手机与PC经常用到的，用某几句关键语句唤醒语音助手的功能) 2.如何实现迁移学习 在这里我想举几个例子来说明，如下图所示： 上图中，第一个神经网络是一个图像识别系统，现在要把它改成一个x光诊断系统。首先把原神经网络的输出层和其对应权重删除，然后为输出层重新赋上随机权重并把这个神经网络放在x光诊断的数据上重新训练，训练结束后看看效果如何。具体的训练策略有两种，如果你有足够多的x光诊断数据，可以选择训练整个神经网络；如果你的训练数据不是很多，可以选择只训练输出层。 第二个神经网络是一个语音识别系统，我们要把它改成一个激活系统。语音识别系统的输入是一些音频输出是一些听写文本。同样我们选择删除原神经网络的输出层和输出层参数并加入新的输出节点或许这个例子里面你需要再向神经网络中加入几层，然后把新的标签输入神经网络进行训练。同样取决于数据多少，你可以训练新加入的几层或者所有层 3.为什么迁移学习是有效果的？ 简单来说，神经网络每一层用于提取来自输入的不同特征，对于功能相似的神经网络，在前几层或者是某基层的特征是相似的，所以应该具有相似的参数，这就像人学过一类知识会把它迁移到相关领域一样。所以，使用迁移学习在很多的时候能够大大节约了训练的时间成本。 在我们举的关于图像识别的例子中有很多低层次的特征，比如边缘检测、曲线检测、阳性对象探测(positive object detecting),这些特征可以从基于大规模数据的图像神经网络中习得，并应用于放射性诊断中。算法从图像神经网络中学到了很多结构信息、图像形状信息并利用这些信息帮助你的放射性诊断网络。 4.迁移学习什么时候可用？ 迁移对象和被迁移对象有相似的输入 被迁移对象的数据规模远大于迁移神经网络的数据规模。比如在第一个例子中，我们用100000组图像数据搭建了一个图像识别的神经网络，那么这个神经网络就可以迁移出一个只有1000组数据的x光诊断神经网络。相反如果现在用1000组数据训练出来的一个图像识别神经网络就不能用迁移学习的方法设计一个相应的x射线诊断神经网络。 迁移学习常被用于训练那些无法找到足够数据的神经网络当中，比如在现实中我们很难找到上万组关于x射线诊断的图像(毕竟很多时候病人信息需要保密，医院不会透漏)，这时候如果我们有一个成熟的图像识别神经网络以供迁移，那我们可能就会使用较少数据设计出一个功能良好的神经网络了。 如果你觉得被迁移对象的底层特征有助于迁移对象那么通过迁移学习构建的神经网络可能会比较理想，我们前一节也介绍了迁移学习的作用机理，那就是有些底层的特征是相似的，是可以迁移的，这也是为什么可以用较少的数据训练出一个理想神经网络的原因。所有如果觉得两者的底层特征是相似的，不妨尝试一下迁移学习。 多任务学习 1.什么是多任务学习？ 我们之前介绍的神经网络都是串行处理的，即一个神经网络只特定判断某一个特征是否存在，比如图像上是否有猫、是否有人。多任务学习是指用一个神经网络同时输出多个特征的情况。 比如：设计一个无人驾驶汽车，我们需要同时识别路上很多情况。例如路上是否有人、前方是否有车、前方标识牌是什么、是否有红灯等等。一个策略是设计多个神经网络依次判断每一个特征，另一种方法是用一个神经网络，这个神经网络有n个输出，每一个输出代表一个特征。后者的策略就是典型的多任务学习。 2.多任务学习的损失和成本函数 定义变量：假设现在有m个数据，每个数据输出n个特征，上角标i代表是第i组数据，下角标j代表第j个特征。 y j i y_{j}^{i} yji​代表这个元素的样本值， y ^ j i \hat{y}_{j}^{i} y^​ji​代表估计值来源于神经网络。 损失函数： L = 1 m ∑ i = 1 m ∑ j = 1 n J ( y j i , y ^ n m ) L=\frac{1}{m}\sum_{i=1}^{m} \sum _{j=1}^{n}J(y_{j}^{i},\hat{y}_{n}^{m}) L=m1​∑i=1m​∑j=1n​J(yji​,y^​nm​) 成本函数： J ( y j i , y ^ j i ) = − y j i l o g y ^ j i − ( 1 − y j i ) l o g ( 1 − y ^ j i ) J(y_{j}^{i},\hat{y}_{j}^{i})=-y_{j}^{i}log\hat{y}_{j}^{i}-(1-y_{j}^{i})log(1-\hat{y}_{j}^{i}) J(yji​,y^​ji​)=−yji​logy^​ji​−(1−yji​)log(1−y^​ji​) 以上这几个公式是老朋友了，就不再赘述了。 3.多任务学习与Softmax的区别是什么？ 两者区别是很明显的，多任务学习的输出是一个含有0、1的向量，它解决的问题是每一个特征是否存在在输入中。Softmax是用来解决多分类问题的，它输出的是每一种特征在输入之中的概率，经过归一化操作后向量中各元素的和等于1。此外Softmax最终得到的结果是唯一的，即到底出现在图片中的是哪一个特征？而多任务中存在多个特征出现在同一图片中的情况 Softmax传送门：https://blog.csdn.net/scanf_yourname/article/details/85501170 4. 多任务学习是如何做到提高效率的 和迁移学习中提到的一样，不同的输出之间可能有一些底层特征是相似的，如果使用每一个特征单独训练的方法，这些特征可能会被重复训练从而导致效率低下，多任务学习在前几层神经网络被训练的特征是可以共享的，这样可以提高效率。 此外，在迁移学习中，我们提到过迁移学习的另一个优势就是在迁移对象数据不够多的时候，可以依靠被迁移对象的数量来构建一个较为理想的神经网络。在多任务学习中，对于某一特定的特征，可能都面临着数据不够的困扰，但是对于特定的特征，其他特征的数据都可以当成是被迁移对象的数据，从而实现一个互相加强的功能。 比如：在一个无人驾驶领域的识别问题中，可能有100样东西需要去识别，但是处于某种原因，我们只能收集到1000组实际驾驶过程中交通状况的图样。如果对某一个特征单独训练，那么只有1000组数据可能是不足以训练出一个良好的神经网络的。但是如果采用多任务的方法，某一个特征以外的99个特征都可以作为这个特征的被迁移对象数据，这样我们就可以获得99000组数据来训练这一特征，这就是多任务学习的优势所在了。 5.多任务学习什么时候适用？ 基于上一节的第一个特点，当不同输出具有相似的底层特征的时候(即可以迁移的时候)，多任务学习适用。 基于上一节的第二个特点，不同的输出的数据规模需要相当。 此外，多任务学习还需要能够设计一个足够大神经网络以满足所有测试数据。因为研究员Rich Carona 发现在多任务学习中如果你的神经网络不够大，效果会比对于每一个输出单独一个神经网络的效果要差。 题外话：在实际应用中迁移学习的使用率远大于多任务学习，在视觉领域的应用是多任务学习最主要的一个应用了 端对端的深度学习 1.什么是端对端的深度学习？ 简而言之，之前的深度学习会将学习过程分为几个阶段进行，端对端的深度学习忽略中间过程用一个神经网络来替代。 举个例子：早期的语音识别模型是经历几个阶段的：首先输入为音频,j经过一些处理提取出一些基本特征，利用机器学习的方法获得音位，然后将音位串在一起构成一个独立的词，最后将词串起来构成音频片段的听写文本。而端对端的深度学习模型则忽略中间过程用一个神经网络代替，直接由输入到输出。 2.端对端深度学习的特点 端对端的深度学习的胃口很大，需要很多数据才能取得比较好的效果。，在较少量数据的情况下，端对端的深度学习并不能表现出比传统方法更好的效果，至少不明显。但是当数据达到一定规模后，端对端的深度学习就表现得比较优异了。 端对端的深度学习的一大优点是它可以让数据自己&quot;做主&quot;,因为以往的分阶段的方法实际上限制了机器分析问题的方法，即机器需要按照人类的方法去进行运算、提取特征以及估计。但是谁也不能保证按照人的方法进行一定是一个最优的方法，有时候将主动权交给机器不失为一种比较好的方法。 端对端的深度学习可以简化你设计的工作流程，不需要手工设计中间的表达方式。 **看似矛盾的，完全由计算机自己做主成为了端对端深度学习的一个缺点。**因为很多时候我们能够给神经网络提供的数据是有限的，如果完全任由神经网络自己做主而不考虑成本是不可能的。所以，在数据有限的情况下，我们需要一些中间过程，对神经网络加以引导，从而降低其对于数据的要求。如果你看到这里有点迷惑，请不要着急，往下看我会用一些例子来证明这一观点。 3.什么时候采用端对端的深度学习 我的结论是：看你由输入到输出的映射是否是明确的，看你的数据能否允许你构建一个由输入直接指向输出的神经网络。对于那些无法端对端实现的问题，我们可以通过拆分成几个明确的映射关系。并且对每个关系实现端对端。 比如运用在语言识别领域，你需要的输入是音频，输出是一句话，这中间实现的实际是一个音频到文本的映射关系，这种映射在生活中实际是很常见的，我们可以不断的收集数据，来实现这一功能。 再比如一个机器翻译模型，输入时英语，输出时汉语，这种映射关系是明确的，是可以端对端实现的。 然而不幸的是有的问题的直接映射关系是不明确的。生活中很常见的了，人脸识别系统，小名&quot;刷脸&quot;。输入是来自摄像头的一张图片，输出是是否与系统里的人匹配。为什么说这种关系是不明确的呢？因为实际拍摄过程中可能有各种情况发生：人离得远还是近？可能同时有几个人入镜到底谁是主角？要实现端对端，那么就需要各种情况下的人像数据，这不现实！所以采用第二种方法，将输入A映射成中间量B再映射到输出C。如下图所示： Andrew延续了他灵魂画手一贯的画风2333! 这里面的输入A是来自摄像头的第一张图片，中间量B是第二张图片，这里设计一个神经网络负责锁定人脸，并用圈定下来放大，这就是一个由A映射到B的过程。第二步相信是一个再熟悉不过的过程了，两张人脸进行匹配，如果匹配成功则输出1，失败则输出0。 现在你看有没有觉得海阔天空呢？相比端对端的方法，此方法将其分解成两个子问题，需要的代价大大减小了。这也就是我想说的，是否采用端对端取决于由输入到输出的关系是否明显，如果不明显那么想要实现端对端要求数据规模就会变大，如果有足够的数据做保障，完全ok，但是要是没有那么多数据，可以考虑绕个弯、想个办法。" />
<meta property="og:description" content="Deeplearning.ai 结构化机器学习项目 Week2 6-10 目录 如何解决数据不匹配 迁移学习 多任务学习 端对端的深度学习 如何解决数据不匹配 1.复习内容 在第四节中我们已经学习了一些偏差分析的策略。 如果人类水平(Human error)和训练水平(Training error)的相差很大，我们认为可能是训练不到位或者是神经网络规模不够大。我们可以通过给神经网络&quot;喂&quot;更多的数据或者用一个更大的神经网络来改善这一状况 如果训练水平(Training error)和Training-dev error 相差较大，可以认为这个神经网络训练出来的结果不具有很好的泛化能力、方差较大，造成了过拟合。处理过拟合的问题我们也学过一些正则化方式，比如L2正则化方法、dropout正则化方法、早停法(early stop)等等 如果Training-dev error 和Dev error相差过大可以认为出现了数据不匹配的问题，什么是数据不匹配的问题呢？举个例子，我们训练了一个猫的分类器，训练集来源是一些网络爬虫得到的猫的图片，这些图片比较专业、清晰、易于分辨，而开发集中的猫来源于手机，手机图片的像素较低、不清晰、有时候会出现抖动。我们的分类器没有见过这样的猫自然分辨能力比较差，这就是数据不匹配的问题，不是说我们的分类器训练的不够好，而是它&quot;孤陋寡闻&quot;了。那么我们应该如何解决这个问题这就是这节课的重点。 2. 解决数据不匹配的基本思路 数据不匹配就是说训练集和开发集的数据有偏差，就是你的神经网络不满足客户的开发需要。那很容易想到的就是针对客户的需要定制一个神经网络。所以我们第一步就是找到&quot;用户需要什么&quot;——也就是造成偏差的来源是什么。 举个例子：我们现在要设计一个安装在汽车内部的语音识别的导航系统，比如在开车的时候你打开系统，对系统说我要去某某街道，导航系统就会给你指明一条道路。现在这个系统因数据不匹配而导致识别率较低。我们通过分析训练集数据和实际错误的案例发现偏差的来源可能是：(1)在用户说话的时候，噪声干扰了系统的识别能力。(2)系统对于街道的门牌号识别率比较低(可能是训练集中缺少对于数字识别的训练，当然我们知道识别对门牌号对于导航正确性至关重要的)。(3)可能是因为用户的方言与口音导致的识别率较低。 找到了偏差来源，下一步就是有的放矢的去给神经网络喂一些相关数据来提高他这方面的识别能力(不会啥咱就学啥呗)。 当然很对情况收集一些方面的数据并没有想象中那么简单，所以这时候除了简单的收集数据外，人工合成一些方面的数据也能达到很好的效果。 沿着上面的例子说，对于导航系统无法准确识别街道门牌号和方言的问题，我们可以收集一些有关于数字和方言的音频文件，用神经网络训练(毕竟数字和方言音频还是相对容易获取的)。 而对于具有噪声环境下有效语境的音频收集起来可能是相对困难的，这时候我们就可以采用人工合成的方法来收集数据。我们首先可以找到一些噪声的音频和一些有效预料的音频，将两者随机结合成我们需要的音频并加入训练。 3.人工合成数据的主要事项 合成的几种元素一定要保持相对均等，就是不要一种要素比另一种要素多好多倍，否则会造成过拟合问题。 还是以汽车导航系统为例：如果你在合成过程中用1h的汽车噪声和10000h的无噪音音频合成，那么对于你这1h的噪音需要使用1万次，那么神经网络肯定会认定这噪音是很重要的因素从而造成对于这1h噪声的过拟合。虽然对于人来书1h的噪声和10000h噪声没什么区别，但是对于机器来说却不是，如下图所示：我们把所有噪声的集合看成一个整体，而我们收集的1h数据只是整体中很小的一部分，如果我们只对这1h的数据训练那势必系统的迁移能力不会太好。 迁移学习 1.什么是迁移学习？ 我们思考一个人，人学习是具有一定的迁移能力的，比如小时候别人教你1+1=2，你可能就会举一反三的说出来2+2=4。人可以基于已有经验来推断未知且相似的问题，这就是人的迁移能力。同样机器也是具有一定的迁移能力的，比如一个训练图像识别的神经网络可以通过一定的改变，变成一个用于识别x光诊断的神经网络；一个经过训练的语音识别系统可以经过一系列的改变变成一个唤醒系统(唤醒系统：我们手机与PC经常用到的，用某几句关键语句唤醒语音助手的功能) 2.如何实现迁移学习 在这里我想举几个例子来说明，如下图所示： 上图中，第一个神经网络是一个图像识别系统，现在要把它改成一个x光诊断系统。首先把原神经网络的输出层和其对应权重删除，然后为输出层重新赋上随机权重并把这个神经网络放在x光诊断的数据上重新训练，训练结束后看看效果如何。具体的训练策略有两种，如果你有足够多的x光诊断数据，可以选择训练整个神经网络；如果你的训练数据不是很多，可以选择只训练输出层。 第二个神经网络是一个语音识别系统，我们要把它改成一个激活系统。语音识别系统的输入是一些音频输出是一些听写文本。同样我们选择删除原神经网络的输出层和输出层参数并加入新的输出节点或许这个例子里面你需要再向神经网络中加入几层，然后把新的标签输入神经网络进行训练。同样取决于数据多少，你可以训练新加入的几层或者所有层 3.为什么迁移学习是有效果的？ 简单来说，神经网络每一层用于提取来自输入的不同特征，对于功能相似的神经网络，在前几层或者是某基层的特征是相似的，所以应该具有相似的参数，这就像人学过一类知识会把它迁移到相关领域一样。所以，使用迁移学习在很多的时候能够大大节约了训练的时间成本。 在我们举的关于图像识别的例子中有很多低层次的特征，比如边缘检测、曲线检测、阳性对象探测(positive object detecting),这些特征可以从基于大规模数据的图像神经网络中习得，并应用于放射性诊断中。算法从图像神经网络中学到了很多结构信息、图像形状信息并利用这些信息帮助你的放射性诊断网络。 4.迁移学习什么时候可用？ 迁移对象和被迁移对象有相似的输入 被迁移对象的数据规模远大于迁移神经网络的数据规模。比如在第一个例子中，我们用100000组图像数据搭建了一个图像识别的神经网络，那么这个神经网络就可以迁移出一个只有1000组数据的x光诊断神经网络。相反如果现在用1000组数据训练出来的一个图像识别神经网络就不能用迁移学习的方法设计一个相应的x射线诊断神经网络。 迁移学习常被用于训练那些无法找到足够数据的神经网络当中，比如在现实中我们很难找到上万组关于x射线诊断的图像(毕竟很多时候病人信息需要保密，医院不会透漏)，这时候如果我们有一个成熟的图像识别神经网络以供迁移，那我们可能就会使用较少数据设计出一个功能良好的神经网络了。 如果你觉得被迁移对象的底层特征有助于迁移对象那么通过迁移学习构建的神经网络可能会比较理想，我们前一节也介绍了迁移学习的作用机理，那就是有些底层的特征是相似的，是可以迁移的，这也是为什么可以用较少的数据训练出一个理想神经网络的原因。所有如果觉得两者的底层特征是相似的，不妨尝试一下迁移学习。 多任务学习 1.什么是多任务学习？ 我们之前介绍的神经网络都是串行处理的，即一个神经网络只特定判断某一个特征是否存在，比如图像上是否有猫、是否有人。多任务学习是指用一个神经网络同时输出多个特征的情况。 比如：设计一个无人驾驶汽车，我们需要同时识别路上很多情况。例如路上是否有人、前方是否有车、前方标识牌是什么、是否有红灯等等。一个策略是设计多个神经网络依次判断每一个特征，另一种方法是用一个神经网络，这个神经网络有n个输出，每一个输出代表一个特征。后者的策略就是典型的多任务学习。 2.多任务学习的损失和成本函数 定义变量：假设现在有m个数据，每个数据输出n个特征，上角标i代表是第i组数据，下角标j代表第j个特征。 y j i y_{j}^{i} yji​代表这个元素的样本值， y ^ j i \hat{y}_{j}^{i} y^​ji​代表估计值来源于神经网络。 损失函数： L = 1 m ∑ i = 1 m ∑ j = 1 n J ( y j i , y ^ n m ) L=\frac{1}{m}\sum_{i=1}^{m} \sum _{j=1}^{n}J(y_{j}^{i},\hat{y}_{n}^{m}) L=m1​∑i=1m​∑j=1n​J(yji​,y^​nm​) 成本函数： J ( y j i , y ^ j i ) = − y j i l o g y ^ j i − ( 1 − y j i ) l o g ( 1 − y ^ j i ) J(y_{j}^{i},\hat{y}_{j}^{i})=-y_{j}^{i}log\hat{y}_{j}^{i}-(1-y_{j}^{i})log(1-\hat{y}_{j}^{i}) J(yji​,y^​ji​)=−yji​logy^​ji​−(1−yji​)log(1−y^​ji​) 以上这几个公式是老朋友了，就不再赘述了。 3.多任务学习与Softmax的区别是什么？ 两者区别是很明显的，多任务学习的输出是一个含有0、1的向量，它解决的问题是每一个特征是否存在在输入中。Softmax是用来解决多分类问题的，它输出的是每一种特征在输入之中的概率，经过归一化操作后向量中各元素的和等于1。此外Softmax最终得到的结果是唯一的，即到底出现在图片中的是哪一个特征？而多任务中存在多个特征出现在同一图片中的情况 Softmax传送门：https://blog.csdn.net/scanf_yourname/article/details/85501170 4. 多任务学习是如何做到提高效率的 和迁移学习中提到的一样，不同的输出之间可能有一些底层特征是相似的，如果使用每一个特征单独训练的方法，这些特征可能会被重复训练从而导致效率低下，多任务学习在前几层神经网络被训练的特征是可以共享的，这样可以提高效率。 此外，在迁移学习中，我们提到过迁移学习的另一个优势就是在迁移对象数据不够多的时候，可以依靠被迁移对象的数量来构建一个较为理想的神经网络。在多任务学习中，对于某一特定的特征，可能都面临着数据不够的困扰，但是对于特定的特征，其他特征的数据都可以当成是被迁移对象的数据，从而实现一个互相加强的功能。 比如：在一个无人驾驶领域的识别问题中，可能有100样东西需要去识别，但是处于某种原因，我们只能收集到1000组实际驾驶过程中交通状况的图样。如果对某一个特征单独训练，那么只有1000组数据可能是不足以训练出一个良好的神经网络的。但是如果采用多任务的方法，某一个特征以外的99个特征都可以作为这个特征的被迁移对象数据，这样我们就可以获得99000组数据来训练这一特征，这就是多任务学习的优势所在了。 5.多任务学习什么时候适用？ 基于上一节的第一个特点，当不同输出具有相似的底层特征的时候(即可以迁移的时候)，多任务学习适用。 基于上一节的第二个特点，不同的输出的数据规模需要相当。 此外，多任务学习还需要能够设计一个足够大神经网络以满足所有测试数据。因为研究员Rich Carona 发现在多任务学习中如果你的神经网络不够大，效果会比对于每一个输出单独一个神经网络的效果要差。 题外话：在实际应用中迁移学习的使用率远大于多任务学习，在视觉领域的应用是多任务学习最主要的一个应用了 端对端的深度学习 1.什么是端对端的深度学习？ 简而言之，之前的深度学习会将学习过程分为几个阶段进行，端对端的深度学习忽略中间过程用一个神经网络来替代。 举个例子：早期的语音识别模型是经历几个阶段的：首先输入为音频,j经过一些处理提取出一些基本特征，利用机器学习的方法获得音位，然后将音位串在一起构成一个独立的词，最后将词串起来构成音频片段的听写文本。而端对端的深度学习模型则忽略中间过程用一个神经网络代替，直接由输入到输出。 2.端对端深度学习的特点 端对端的深度学习的胃口很大，需要很多数据才能取得比较好的效果。，在较少量数据的情况下，端对端的深度学习并不能表现出比传统方法更好的效果，至少不明显。但是当数据达到一定规模后，端对端的深度学习就表现得比较优异了。 端对端的深度学习的一大优点是它可以让数据自己&quot;做主&quot;,因为以往的分阶段的方法实际上限制了机器分析问题的方法，即机器需要按照人类的方法去进行运算、提取特征以及估计。但是谁也不能保证按照人的方法进行一定是一个最优的方法，有时候将主动权交给机器不失为一种比较好的方法。 端对端的深度学习可以简化你设计的工作流程，不需要手工设计中间的表达方式。 **看似矛盾的，完全由计算机自己做主成为了端对端深度学习的一个缺点。**因为很多时候我们能够给神经网络提供的数据是有限的，如果完全任由神经网络自己做主而不考虑成本是不可能的。所以，在数据有限的情况下，我们需要一些中间过程，对神经网络加以引导，从而降低其对于数据的要求。如果你看到这里有点迷惑，请不要着急，往下看我会用一些例子来证明这一观点。 3.什么时候采用端对端的深度学习 我的结论是：看你由输入到输出的映射是否是明确的，看你的数据能否允许你构建一个由输入直接指向输出的神经网络。对于那些无法端对端实现的问题，我们可以通过拆分成几个明确的映射关系。并且对每个关系实现端对端。 比如运用在语言识别领域，你需要的输入是音频，输出是一句话，这中间实现的实际是一个音频到文本的映射关系，这种映射在生活中实际是很常见的，我们可以不断的收集数据，来实现这一功能。 再比如一个机器翻译模型，输入时英语，输出时汉语，这种映射关系是明确的，是可以端对端实现的。 然而不幸的是有的问题的直接映射关系是不明确的。生活中很常见的了，人脸识别系统，小名&quot;刷脸&quot;。输入是来自摄像头的一张图片，输出是是否与系统里的人匹配。为什么说这种关系是不明确的呢？因为实际拍摄过程中可能有各种情况发生：人离得远还是近？可能同时有几个人入镜到底谁是主角？要实现端对端，那么就需要各种情况下的人像数据，这不现实！所以采用第二种方法，将输入A映射成中间量B再映射到输出C。如下图所示： Andrew延续了他灵魂画手一贯的画风2333! 这里面的输入A是来自摄像头的第一张图片，中间量B是第二张图片，这里设计一个神经网络负责锁定人脸，并用圈定下来放大，这就是一个由A映射到B的过程。第二步相信是一个再熟悉不过的过程了，两张人脸进行匹配，如果匹配成功则输出1，失败则输出0。 现在你看有没有觉得海阔天空呢？相比端对端的方法，此方法将其分解成两个子问题，需要的代价大大减小了。这也就是我想说的，是否采用端对端取决于由输入到输出的关系是否明显，如果不明显那么想要实现端对端要求数据规模就会变大，如果有足够的数据做保障，完全ok，但是要是没有那么多数据，可以考虑绕个弯、想个办法。" />
<link rel="canonical" href="https://mlh.app/2019/01/15/ac77251f46464f2b00df112c2fd80dfb.html" />
<meta property="og:url" content="https://mlh.app/2019/01/15/ac77251f46464f2b00df112c2fd80dfb.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Deeplearning.ai 结构化机器学习项目 Week2 6-10 目录 如何解决数据不匹配 迁移学习 多任务学习 端对端的深度学习 如何解决数据不匹配 1.复习内容 在第四节中我们已经学习了一些偏差分析的策略。 如果人类水平(Human error)和训练水平(Training error)的相差很大，我们认为可能是训练不到位或者是神经网络规模不够大。我们可以通过给神经网络&quot;喂&quot;更多的数据或者用一个更大的神经网络来改善这一状况 如果训练水平(Training error)和Training-dev error 相差较大，可以认为这个神经网络训练出来的结果不具有很好的泛化能力、方差较大，造成了过拟合。处理过拟合的问题我们也学过一些正则化方式，比如L2正则化方法、dropout正则化方法、早停法(early stop)等等 如果Training-dev error 和Dev error相差过大可以认为出现了数据不匹配的问题，什么是数据不匹配的问题呢？举个例子，我们训练了一个猫的分类器，训练集来源是一些网络爬虫得到的猫的图片，这些图片比较专业、清晰、易于分辨，而开发集中的猫来源于手机，手机图片的像素较低、不清晰、有时候会出现抖动。我们的分类器没有见过这样的猫自然分辨能力比较差，这就是数据不匹配的问题，不是说我们的分类器训练的不够好，而是它&quot;孤陋寡闻&quot;了。那么我们应该如何解决这个问题这就是这节课的重点。 2. 解决数据不匹配的基本思路 数据不匹配就是说训练集和开发集的数据有偏差，就是你的神经网络不满足客户的开发需要。那很容易想到的就是针对客户的需要定制一个神经网络。所以我们第一步就是找到&quot;用户需要什么&quot;——也就是造成偏差的来源是什么。 举个例子：我们现在要设计一个安装在汽车内部的语音识别的导航系统，比如在开车的时候你打开系统，对系统说我要去某某街道，导航系统就会给你指明一条道路。现在这个系统因数据不匹配而导致识别率较低。我们通过分析训练集数据和实际错误的案例发现偏差的来源可能是：(1)在用户说话的时候，噪声干扰了系统的识别能力。(2)系统对于街道的门牌号识别率比较低(可能是训练集中缺少对于数字识别的训练，当然我们知道识别对门牌号对于导航正确性至关重要的)。(3)可能是因为用户的方言与口音导致的识别率较低。 找到了偏差来源，下一步就是有的放矢的去给神经网络喂一些相关数据来提高他这方面的识别能力(不会啥咱就学啥呗)。 当然很对情况收集一些方面的数据并没有想象中那么简单，所以这时候除了简单的收集数据外，人工合成一些方面的数据也能达到很好的效果。 沿着上面的例子说，对于导航系统无法准确识别街道门牌号和方言的问题，我们可以收集一些有关于数字和方言的音频文件，用神经网络训练(毕竟数字和方言音频还是相对容易获取的)。 而对于具有噪声环境下有效语境的音频收集起来可能是相对困难的，这时候我们就可以采用人工合成的方法来收集数据。我们首先可以找到一些噪声的音频和一些有效预料的音频，将两者随机结合成我们需要的音频并加入训练。 3.人工合成数据的主要事项 合成的几种元素一定要保持相对均等，就是不要一种要素比另一种要素多好多倍，否则会造成过拟合问题。 还是以汽车导航系统为例：如果你在合成过程中用1h的汽车噪声和10000h的无噪音音频合成，那么对于你这1h的噪音需要使用1万次，那么神经网络肯定会认定这噪音是很重要的因素从而造成对于这1h噪声的过拟合。虽然对于人来书1h的噪声和10000h噪声没什么区别，但是对于机器来说却不是，如下图所示：我们把所有噪声的集合看成一个整体，而我们收集的1h数据只是整体中很小的一部分，如果我们只对这1h的数据训练那势必系统的迁移能力不会太好。 迁移学习 1.什么是迁移学习？ 我们思考一个人，人学习是具有一定的迁移能力的，比如小时候别人教你1+1=2，你可能就会举一反三的说出来2+2=4。人可以基于已有经验来推断未知且相似的问题，这就是人的迁移能力。同样机器也是具有一定的迁移能力的，比如一个训练图像识别的神经网络可以通过一定的改变，变成一个用于识别x光诊断的神经网络；一个经过训练的语音识别系统可以经过一系列的改变变成一个唤醒系统(唤醒系统：我们手机与PC经常用到的，用某几句关键语句唤醒语音助手的功能) 2.如何实现迁移学习 在这里我想举几个例子来说明，如下图所示： 上图中，第一个神经网络是一个图像识别系统，现在要把它改成一个x光诊断系统。首先把原神经网络的输出层和其对应权重删除，然后为输出层重新赋上随机权重并把这个神经网络放在x光诊断的数据上重新训练，训练结束后看看效果如何。具体的训练策略有两种，如果你有足够多的x光诊断数据，可以选择训练整个神经网络；如果你的训练数据不是很多，可以选择只训练输出层。 第二个神经网络是一个语音识别系统，我们要把它改成一个激活系统。语音识别系统的输入是一些音频输出是一些听写文本。同样我们选择删除原神经网络的输出层和输出层参数并加入新的输出节点或许这个例子里面你需要再向神经网络中加入几层，然后把新的标签输入神经网络进行训练。同样取决于数据多少，你可以训练新加入的几层或者所有层 3.为什么迁移学习是有效果的？ 简单来说，神经网络每一层用于提取来自输入的不同特征，对于功能相似的神经网络，在前几层或者是某基层的特征是相似的，所以应该具有相似的参数，这就像人学过一类知识会把它迁移到相关领域一样。所以，使用迁移学习在很多的时候能够大大节约了训练的时间成本。 在我们举的关于图像识别的例子中有很多低层次的特征，比如边缘检测、曲线检测、阳性对象探测(positive object detecting),这些特征可以从基于大规模数据的图像神经网络中习得，并应用于放射性诊断中。算法从图像神经网络中学到了很多结构信息、图像形状信息并利用这些信息帮助你的放射性诊断网络。 4.迁移学习什么时候可用？ 迁移对象和被迁移对象有相似的输入 被迁移对象的数据规模远大于迁移神经网络的数据规模。比如在第一个例子中，我们用100000组图像数据搭建了一个图像识别的神经网络，那么这个神经网络就可以迁移出一个只有1000组数据的x光诊断神经网络。相反如果现在用1000组数据训练出来的一个图像识别神经网络就不能用迁移学习的方法设计一个相应的x射线诊断神经网络。 迁移学习常被用于训练那些无法找到足够数据的神经网络当中，比如在现实中我们很难找到上万组关于x射线诊断的图像(毕竟很多时候病人信息需要保密，医院不会透漏)，这时候如果我们有一个成熟的图像识别神经网络以供迁移，那我们可能就会使用较少数据设计出一个功能良好的神经网络了。 如果你觉得被迁移对象的底层特征有助于迁移对象那么通过迁移学习构建的神经网络可能会比较理想，我们前一节也介绍了迁移学习的作用机理，那就是有些底层的特征是相似的，是可以迁移的，这也是为什么可以用较少的数据训练出一个理想神经网络的原因。所有如果觉得两者的底层特征是相似的，不妨尝试一下迁移学习。 多任务学习 1.什么是多任务学习？ 我们之前介绍的神经网络都是串行处理的，即一个神经网络只特定判断某一个特征是否存在，比如图像上是否有猫、是否有人。多任务学习是指用一个神经网络同时输出多个特征的情况。 比如：设计一个无人驾驶汽车，我们需要同时识别路上很多情况。例如路上是否有人、前方是否有车、前方标识牌是什么、是否有红灯等等。一个策略是设计多个神经网络依次判断每一个特征，另一种方法是用一个神经网络，这个神经网络有n个输出，每一个输出代表一个特征。后者的策略就是典型的多任务学习。 2.多任务学习的损失和成本函数 定义变量：假设现在有m个数据，每个数据输出n个特征，上角标i代表是第i组数据，下角标j代表第j个特征。 y j i y_{j}^{i} yji​代表这个元素的样本值， y ^ j i \\hat{y}_{j}^{i} y^​ji​代表估计值来源于神经网络。 损失函数： L = 1 m ∑ i = 1 m ∑ j = 1 n J ( y j i , y ^ n m ) L=\\frac{1}{m}\\sum_{i=1}^{m} \\sum _{j=1}^{n}J(y_{j}^{i},\\hat{y}_{n}^{m}) L=m1​∑i=1m​∑j=1n​J(yji​,y^​nm​) 成本函数： J ( y j i , y ^ j i ) = − y j i l o g y ^ j i − ( 1 − y j i ) l o g ( 1 − y ^ j i ) J(y_{j}^{i},\\hat{y}_{j}^{i})=-y_{j}^{i}log\\hat{y}_{j}^{i}-(1-y_{j}^{i})log(1-\\hat{y}_{j}^{i}) J(yji​,y^​ji​)=−yji​logy^​ji​−(1−yji​)log(1−y^​ji​) 以上这几个公式是老朋友了，就不再赘述了。 3.多任务学习与Softmax的区别是什么？ 两者区别是很明显的，多任务学习的输出是一个含有0、1的向量，它解决的问题是每一个特征是否存在在输入中。Softmax是用来解决多分类问题的，它输出的是每一种特征在输入之中的概率，经过归一化操作后向量中各元素的和等于1。此外Softmax最终得到的结果是唯一的，即到底出现在图片中的是哪一个特征？而多任务中存在多个特征出现在同一图片中的情况 Softmax传送门：https://blog.csdn.net/scanf_yourname/article/details/85501170 4. 多任务学习是如何做到提高效率的 和迁移学习中提到的一样，不同的输出之间可能有一些底层特征是相似的，如果使用每一个特征单独训练的方法，这些特征可能会被重复训练从而导致效率低下，多任务学习在前几层神经网络被训练的特征是可以共享的，这样可以提高效率。 此外，在迁移学习中，我们提到过迁移学习的另一个优势就是在迁移对象数据不够多的时候，可以依靠被迁移对象的数量来构建一个较为理想的神经网络。在多任务学习中，对于某一特定的特征，可能都面临着数据不够的困扰，但是对于特定的特征，其他特征的数据都可以当成是被迁移对象的数据，从而实现一个互相加强的功能。 比如：在一个无人驾驶领域的识别问题中，可能有100样东西需要去识别，但是处于某种原因，我们只能收集到1000组实际驾驶过程中交通状况的图样。如果对某一个特征单独训练，那么只有1000组数据可能是不足以训练出一个良好的神经网络的。但是如果采用多任务的方法，某一个特征以外的99个特征都可以作为这个特征的被迁移对象数据，这样我们就可以获得99000组数据来训练这一特征，这就是多任务学习的优势所在了。 5.多任务学习什么时候适用？ 基于上一节的第一个特点，当不同输出具有相似的底层特征的时候(即可以迁移的时候)，多任务学习适用。 基于上一节的第二个特点，不同的输出的数据规模需要相当。 此外，多任务学习还需要能够设计一个足够大神经网络以满足所有测试数据。因为研究员Rich Carona 发现在多任务学习中如果你的神经网络不够大，效果会比对于每一个输出单独一个神经网络的效果要差。 题外话：在实际应用中迁移学习的使用率远大于多任务学习，在视觉领域的应用是多任务学习最主要的一个应用了 端对端的深度学习 1.什么是端对端的深度学习？ 简而言之，之前的深度学习会将学习过程分为几个阶段进行，端对端的深度学习忽略中间过程用一个神经网络来替代。 举个例子：早期的语音识别模型是经历几个阶段的：首先输入为音频,j经过一些处理提取出一些基本特征，利用机器学习的方法获得音位，然后将音位串在一起构成一个独立的词，最后将词串起来构成音频片段的听写文本。而端对端的深度学习模型则忽略中间过程用一个神经网络代替，直接由输入到输出。 2.端对端深度学习的特点 端对端的深度学习的胃口很大，需要很多数据才能取得比较好的效果。，在较少量数据的情况下，端对端的深度学习并不能表现出比传统方法更好的效果，至少不明显。但是当数据达到一定规模后，端对端的深度学习就表现得比较优异了。 端对端的深度学习的一大优点是它可以让数据自己&quot;做主&quot;,因为以往的分阶段的方法实际上限制了机器分析问题的方法，即机器需要按照人类的方法去进行运算、提取特征以及估计。但是谁也不能保证按照人的方法进行一定是一个最优的方法，有时候将主动权交给机器不失为一种比较好的方法。 端对端的深度学习可以简化你设计的工作流程，不需要手工设计中间的表达方式。 **看似矛盾的，完全由计算机自己做主成为了端对端深度学习的一个缺点。**因为很多时候我们能够给神经网络提供的数据是有限的，如果完全任由神经网络自己做主而不考虑成本是不可能的。所以，在数据有限的情况下，我们需要一些中间过程，对神经网络加以引导，从而降低其对于数据的要求。如果你看到这里有点迷惑，请不要着急，往下看我会用一些例子来证明这一观点。 3.什么时候采用端对端的深度学习 我的结论是：看你由输入到输出的映射是否是明确的，看你的数据能否允许你构建一个由输入直接指向输出的神经网络。对于那些无法端对端实现的问题，我们可以通过拆分成几个明确的映射关系。并且对每个关系实现端对端。 比如运用在语言识别领域，你需要的输入是音频，输出是一句话，这中间实现的实际是一个音频到文本的映射关系，这种映射在生活中实际是很常见的，我们可以不断的收集数据，来实现这一功能。 再比如一个机器翻译模型，输入时英语，输出时汉语，这种映射关系是明确的，是可以端对端实现的。 然而不幸的是有的问题的直接映射关系是不明确的。生活中很常见的了，人脸识别系统，小名&quot;刷脸&quot;。输入是来自摄像头的一张图片，输出是是否与系统里的人匹配。为什么说这种关系是不明确的呢？因为实际拍摄过程中可能有各种情况发生：人离得远还是近？可能同时有几个人入镜到底谁是主角？要实现端对端，那么就需要各种情况下的人像数据，这不现实！所以采用第二种方法，将输入A映射成中间量B再映射到输出C。如下图所示： Andrew延续了他灵魂画手一贯的画风2333! 这里面的输入A是来自摄像头的第一张图片，中间量B是第二张图片，这里设计一个神经网络负责锁定人脸，并用圈定下来放大，这就是一个由A映射到B的过程。第二步相信是一个再熟悉不过的过程了，两张人脸进行匹配，如果匹配成功则输出1，失败则输出0。 现在你看有没有觉得海阔天空呢？相比端对端的方法，此方法将其分解成两个子问题，需要的代价大大减小了。这也就是我想说的，是否采用端对端取决于由输入到输出的关系是否明显，如果不明显那么想要实现端对端要求数据规模就会变大，如果有足够的数据做保障，完全ok，但是要是没有那么多数据，可以考虑绕个弯、想个办法。","@type":"BlogPosting","url":"https://mlh.app/2019/01/15/ac77251f46464f2b00df112c2fd80dfb.html","headline":"Deeplearning.ai 结构化机器学习项目 Week2 6-10","dateModified":"2019-01-15T00:00:00+08:00","datePublished":"2019-01-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/01/15/ac77251f46464f2b00df112c2fd80dfb.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>Deeplearning.ai 结构化机器学习项目 Week2 6-10</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="Deeplearningai__Week2_610_0"></a><a href="http://Deeplearning.ai" rel="nofollow">Deeplearning.ai</a> 结构化机器学习项目 Week2 6-10</h1> 
  <h2><a id="_1"></a>目录</h2> 
  <ul> 
   <li>如何解决数据不匹配</li> 
   <li>迁移学习</li> 
   <li>多任务学习</li> 
   <li>端对端的深度学习</li> 
  </ul> 
  <h2><a id="_7"></a>如何解决数据不匹配</h2> 
  <h4><a id="1_8"></a>1.复习内容</h4> 
  <ul> 
   <li>在第四节中我们已经学习了一些偏差分析的策略。</li> 
   <li>如果人类水平(Human error)和训练水平(Training error)的相差很大，我们认为可能是训练不到位或者是神经网络规模不够大。我们可以通过给神经网络"喂"更多的数据或者用一个更大的神经网络来改善这一状况</li> 
   <li>如果训练水平(Training error)和Training-dev error 相差较大，可以认为这个神经网络训练出来的结果不具有很好的泛化能力、方差较大，造成了过拟合。处理过拟合的问题我们也学过一些正则化方式，比如L2正则化方法、dropout正则化方法、早停法(early stop)等等</li> 
   <li>如果Training-dev error 和Dev error相差过大可以认为出现了数据不匹配的问题，什么是数据不匹配的问题呢？举个例子，我们训练了一个猫的分类器，训练集来源是一些网络爬虫得到的猫的图片，这些图片比较专业、清晰、易于分辨，而开发集中的猫来源于手机，手机图片的像素较低、不清晰、有时候会出现抖动。我们的分类器没有见过这样的猫自然分辨能力比较差，这就是数据不匹配的问题，不是说我们的分类器训练的不够好，而是它"孤陋寡闻"了。那么我们应该如何解决这个问题这就是这节课的重点。</li> 
  </ul> 
  <h4><a id="2__14"></a>2. 解决数据不匹配的基本思路</h4> 
  <ul> 
   <li>数据不匹配就是说训练集和开发集的数据有偏差，就是你的神经网络不满足客户的开发需要。那很容易想到的就是针对客户的需要定制一个神经网络。<strong>所以我们第一步就是找到"用户需要什么"——也就是造成偏差的来源是什么</strong>。<br> 举个例子：我们现在要设计一个安装在汽车内部的语音识别的导航系统，比如在开车的时候你打开系统，对系统说我要去某某街道，导航系统就会给你指明一条道路。现在这个系统因数据不匹配而导致识别率较低。我们通过分析训练集数据和实际错误的案例发现偏差的来源可能是：(1)在用户说话的时候，噪声干扰了系统的识别能力。(2)系统对于街道的门牌号识别率比较低(可能是训练集中缺少对于数字识别的训练，当然我们知道识别对门牌号对于导航正确性至关重要的)。(3)可能是因为用户的方言与口音导致的识别率较低。</li> 
   <li>找到了偏差来源，<strong>下一步就是有的放矢的去给神经网络喂一些相关数据来提高他这方面的识别能力</strong>(不会啥咱就学啥呗)。</li> 
   <li>当然很对情况收集一些方面的数据并没有想象中那么简单，所以这时候除了简单的收集数据外，<strong>人工合成一些方面的数据也能达到很好的效果。</strong><br> 沿着上面的例子说，对于导航系统无法准确识别街道门牌号和方言的问题，我们可以收集一些有关于数字和方言的音频文件，用神经网络训练(毕竟数字和方言音频还是相对容易获取的)。<br> 而对于具有噪声环境下有效语境的音频收集起来可能是相对困难的，这时候我们就可以采用人工合成的方法来收集数据。我们首先可以找到一些噪声的音频和一些有效预料的音频，将两者随机结合成我们需要的音频并加入训练。</li> 
  </ul> 
  <h4><a id="3_22"></a>3.人工合成数据的主要事项</h4> 
  <ul> 
   <li>合成的几种元素一定要保持相对均等，就是不要一种要素比另一种要素多好多倍，否则会造成过拟合问题。<br> 还是以汽车导航系统为例：如果你在合成过程中用1h的汽车噪声和10000h的无噪音音频合成，那么对于你这1h的噪音需要使用1万次，那么神经网络肯定会认定这噪音是很重要的因素从而造成对于这1h噪声的过拟合。虽然对于人来书1h的噪声和10000h噪声没什么区别，但是对于机器来说却不是，如下图所示：我们把所有噪声的集合看成一个整体，而我们收集的1h数据只是整体中很小的一部分，如果我们只对这1h的数据训练那势必系统的迁移能力不会太好。<img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190115170449312.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjYW5mX3lvdXJuYW1l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li> 
  </ul> 
  <h2><a id="_26"></a>迁移学习</h2> 
  <h4><a id="1_27"></a>1.什么是迁移学习？</h4> 
  <ul> 
   <li>我们思考一个人，人学习是具有一定的迁移能力的，比如小时候别人教你1+1=2，你可能就会举一反三的说出来2+2=4。人可以基于已有经验来推断未知且相似的问题，这就是人的迁移能力。同样机器也是具有一定的迁移能力的，比如一个训练图像识别的神经网络可以通过一定的改变，变成一个用于识别x光诊断的神经网络；一个经过训练的语音识别系统可以经过一系列的改变变成一个唤醒系统(唤醒系统：我们手机与PC经常用到的，用某几句关键语句唤醒语音助手的功能)</li> 
  </ul> 
  <h4><a id="2_29"></a>2.如何实现迁移学习</h4> 
  <ul> 
   <li>在这里我想举几个例子来说明，如下图所示：<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190115171703712.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjYW5mX3lvdXJuYW1l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 上图中，第一个神经网络是一个图像识别系统，现在要把它改成一个x光诊断系统。首先把原神经网络的输出层和其对应权重删除，然后为输出层重新赋上随机权重并把这个神经网络放在x光诊断的数据上重新训练，训练结束后看看效果如何。具体的训练策略有两种，如果你有足够多的x光诊断数据，可以选择训练整个神经网络；如果你的训练数据不是很多，可以选择只训练输出层。<br> 第二个神经网络是一个语音识别系统，我们要把它改成一个激活系统。语音识别系统的输入是一些音频输出是一些听写文本。同样我们选择删除原神经网络的输出层和输出层参数并加入新的输出节点或许这个例子里面你需要再向神经网络中加入几层，然后把新的标签输入神经网络进行训练。同样取决于数据多少，你可以训练新加入的几层或者所有层</li> 
  </ul> 
  <h4><a id="3_34"></a>3.为什么迁移学习是有效果的？</h4> 
  <ul> 
   <li>简单来说，神经网络每一层用于提取来自输入的不同特征，对于功能相似的神经网络，在前几层或者是某基层的特征是相似的，所以应该具有相似的参数，这就像人学过一类知识会把它迁移到相关领域一样。所以，使用迁移学习在很多的时候能够大大节约了训练的时间成本。</li> 
   <li>在我们举的关于图像识别的例子中有很多低层次的特征，比如边缘检测、曲线检测、阳性对象探测(positive object detecting),这些特征可以从基于大规模数据的图像神经网络中习得，并应用于放射性诊断中。算法从图像神经网络中学到了很多结构信息、图像形状信息并利用这些信息帮助你的放射性诊断网络。</li> 
  </ul> 
  <h4><a id="4_38"></a>4.迁移学习什么时候可用？</h4> 
  <ul> 
   <li><strong>迁移对象和被迁移对象有相似的输入</strong></li> 
   <li><strong>被迁移对象的数据规模远大于迁移神经网络的数据规模</strong>。比如在第一个例子中，我们用100000组图像数据搭建了一个图像识别的神经网络，那么这个神经网络就可以迁移出一个只有1000组数据的x光诊断神经网络。相反如果现在用1000组数据训练出来的一个图像识别神经网络就不能用迁移学习的方法设计一个相应的x射线诊断神经网络。</li> 
   <li><strong>迁移学习常被用于训练那些无法找到足够数据的神经网络当中</strong>，比如在现实中我们很难找到上万组关于x射线诊断的图像(毕竟很多时候病人信息需要保密，医院不会透漏)，这时候如果我们有一个成熟的图像识别神经网络以供迁移，那我们可能就会使用较少数据设计出一个功能良好的神经网络了。</li> 
   <li><strong>如果你觉得被迁移对象的底层特征有助于迁移对象那么通过迁移学习构建的神经网络可能会比较理想</strong>，我们前一节也介绍了迁移学习的作用机理，那就是有些底层的特征是相似的，是可以迁移的，这也是为什么可以用较少的数据训练出一个理想神经网络的原因。所有如果觉得两者的底层特征是相似的，不妨尝试一下迁移学习。</li> 
  </ul> 
  <h2><a id="_44"></a>多任务学习</h2> 
  <h4><a id="1_45"></a>1.什么是多任务学习？</h4> 
  <ul> 
   <li>我们之前介绍的神经网络都是串行处理的，即一个神经网络只特定判断某一个特征是否存在，比如图像上是否有猫、是否有人。多任务学习是指用一个神经网络同时输出多个特征的情况。</li> 
   <li>比如：设计一个无人驾驶汽车，我们需要同时识别路上很多情况。例如路上是否有人、前方是否有车、前方标识牌是什么、是否有红灯等等。一个策略是设计多个神经网络依次判断每一个特征，另一种方法是用一个神经网络，这个神经网络有n个输出，每一个输出代表一个特征。后者的策略就是典型的多任务学习。</li> 
  </ul> 
  <h4><a id="2_49"></a>2.多任务学习的损失和成本函数</h4> 
  <ul> 
   <li>定义变量：假设现在有m个数据，每个数据输出n个特征，上角标i代表是第i组数据，下角标j代表第j个特征。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <msubsup>
           <mi>
            y
           </mi>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
         </mrow>
         <annotation encoding="application/x-tex">
          y_{j}^{i}
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.21944em; vertical-align: -0.394772em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span></span></span></span></span>代表这个元素的样本值，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <msubsup>
           <mover accent="true">
            <mi>
             y
            </mi>
            <mo>
             ^
            </mo>
           </mover>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
         </mrow>
         <annotation encoding="application/x-tex">
          \hat{y}_{j}^{i}
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.21944em; vertical-align: -0.394772em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span></span></span></span></span>代表估计值来源于神经网络。</li> 
   <li>损失函数：<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           L
          </mi>
          <mo>
           =
          </mo>
          <mfrac>
           <mn>
            1
           </mn>
           <mi>
            m
           </mi>
          </mfrac>
          <msubsup>
           <mo>
            ∑
           </mo>
           <mrow>
            <mi>
             i
            </mi>
            <mo>
             =
            </mo>
            <mn>
             1
            </mn>
           </mrow>
           <mi>
            m
           </mi>
          </msubsup>
          <msubsup>
           <mo>
            ∑
           </mo>
           <mrow>
            <mi>
             j
            </mi>
            <mo>
             =
            </mo>
            <mn>
             1
            </mn>
           </mrow>
           <mi>
            n
           </mi>
          </msubsup>
          <mi>
           J
          </mi>
          <mo>
           (
          </mo>
          <msubsup>
           <mi>
            y
           </mi>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
          <mo separator="true">
           ,
          </mo>
          <msubsup>
           <mover accent="true">
            <mi>
             y
            </mi>
            <mo>
             ^
            </mo>
           </mover>
           <mi>
            n
           </mi>
           <mi>
            m
           </mi>
          </msubsup>
          <mo>
           )
          </mo>
         </mrow>
         <annotation encoding="application/x-tex">
          L=\frac{1}{m}\sum_{i=1}^{m} \sum _{j=1}^{n}J(y_{j}^{i},\hat{y}_{n}^{m})
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathit">L</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.28093em; vertical-align: -0.435818em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.845108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.435818em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.09618em;">J</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -2.453em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li> 
   <li>成本函数：<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           J
          </mi>
          <mo>
           (
          </mo>
          <msubsup>
           <mi>
            y
           </mi>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
          <mo separator="true">
           ,
          </mo>
          <msubsup>
           <mover accent="true">
            <mi>
             y
            </mi>
            <mo>
             ^
            </mo>
           </mover>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
          <mo>
           )
          </mo>
          <mo>
           =
          </mo>
          <mo>
           −
          </mo>
          <msubsup>
           <mi>
            y
           </mi>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
          <mi>
           l
          </mi>
          <mi>
           o
          </mi>
          <mi>
           g
          </mi>
          <msubsup>
           <mover accent="true">
            <mi>
             y
            </mi>
            <mo>
             ^
            </mo>
           </mover>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
          <mo>
           −
          </mo>
          <mo>
           (
          </mo>
          <mn>
           1
          </mn>
          <mo>
           −
          </mo>
          <msubsup>
           <mi>
            y
           </mi>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
          <mo>
           )
          </mo>
          <mi>
           l
          </mi>
          <mi>
           o
          </mi>
          <mi>
           g
          </mi>
          <mo>
           (
          </mo>
          <mn>
           1
          </mn>
          <mo>
           −
          </mo>
          <msubsup>
           <mover accent="true">
            <mi>
             y
            </mi>
            <mo>
             ^
            </mo>
           </mover>
           <mi>
            j
           </mi>
           <mi>
            i
           </mi>
          </msubsup>
          <mo>
           )
          </mo>
         </mrow>
         <annotation encoding="application/x-tex">
          J(y_{j}^{i},\hat{y}_{j}^{i})=-y_{j}^{i}log\hat{y}_{j}^{i}-(1-y_{j}^{i})log(1-\hat{y}_{j}^{i})
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.21944em; vertical-align: -0.394772em;"></span><span class="mord mathit" style="margin-right: 0.09618em;">J</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.21944em; vertical-align: -0.394772em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.21944em; vertical-align: -0.394772em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.21944em; vertical-align: -0.394772em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -2.44134em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05724em;">j</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.394772em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></li> 
   <li>以上这几个公式是老朋友了，就不再赘述了。</li> 
  </ul> 
  <h4><a id="3Softmax_57"></a>3.多任务学习与Softmax的区别是什么？</h4> 
  <ul> 
   <li>两者区别是很明显的，多任务学习的输出是一个含有0、1的向量，它解决的问题是每一个特征是否存在在输入中。Softmax是用来解决多分类问题的，它输出的是每一种特征在输入之中的概率，经过归一化操作后向量中各元素的和等于1。此外Softmax最终得到的结果是唯一的，即到底出现在图片中的是哪一个特征？而多任务中存在多个特征出现在同一图片中的情况</li> 
   <li>Softmax传送门：<a href="https://blog.csdn.net/scanf_yourname/article/details/85501170" rel="nofollow">https://blog.csdn.net/scanf_yourname/article/details/85501170</a></li> 
  </ul> 
  <h4><a id="4__61"></a>4. 多任务学习是如何做到提高效率的</h4> 
  <ul> 
   <li>和迁移学习中提到的一样，不同的输出之间可能有一些底层特征是相似的，如果使用每一个特征单独训练的方法，这些特征可能会被重复训练从而导致效率低下，多任务学习在前几层神经网络被训练的特征是可以共享的，这样可以提高效率。</li> 
   <li>此外，在迁移学习中，我们提到过迁移学习的另一个优势就是在迁移对象数据不够多的时候，可以依靠被迁移对象的数量来构建一个较为理想的神经网络。<strong>在多任务学习中，对于某一特定的特征，可能都面临着数据不够的困扰，但是对于特定的特征，其他特征的数据都可以当成是被迁移对象的数据，从而实现一个互相加强的功能。</strong></li> 
   <li>比如：在一个无人驾驶领域的识别问题中，可能有100样东西需要去识别，但是处于某种原因，我们只能收集到1000组实际驾驶过程中交通状况的图样。如果对某一个特征单独训练，那么只有1000组数据可能是不足以训练出一个良好的神经网络的。但是如果采用多任务的方法，某一个特征以外的99个特征都可以作为这个特征的被迁移对象数据，这样我们就可以获得99000组数据来训练这一特征，这就是多任务学习的优势所在了。</li> 
  </ul> 
  <h4><a id="5_66"></a>5.多任务学习什么时候适用？</h4> 
  <ul> 
   <li>基于上一节的第一个特点，当不同输出具有相似的底层特征的时候(即可以迁移的时候)，多任务学习适用。</li> 
   <li>基于上一节的第二个特点，不同的输出的数据规模需要相当。</li> 
   <li>此外，多任务学习还需要能够设计一个足够大神经网络以满足所有测试数据。因为研究员Rich Carona 发现在多任务学习中如果你的神经网络不够大，效果会比对于每一个输出单独一个神经网络的效果要差。</li> 
   <li>题外话：在实际应用中迁移学习的使用率远大于多任务学习，在视觉领域的应用是多任务学习最主要的一个应用了</li> 
  </ul> 
  <h2><a id="_72"></a>端对端的深度学习</h2> 
  <h4><a id="1_73"></a>1.什么是端对端的深度学习？</h4> 
  <ul> 
   <li>简而言之，之前的深度学习会将学习过程分为几个阶段进行，端对端的深度学习忽略中间过程用一个神经网络来替代。</li> 
   <li>举个例子：早期的语音识别模型是经历几个阶段的：首先输入为音频,j经过一些处理提取出一些基本特征，利用机器学习的方法获得音位，然后将音位串在一起构成一个独立的词，最后将词串起来构成音频片段的听写文本。而端对端的深度学习模型则忽略中间过程用一个神经网络代替，直接由输入到输出。</li> 
  </ul> 
  <h4><a id="2_76"></a>2.端对端深度学习的特点</h4> 
  <ul> 
   <li><strong>端对端的深度学习的胃口很大，需要很多数据才能取得比较好的效果。</strong>，在较少量数据的情况下，端对端的深度学习并不能表现出比传统方法更好的效果，至少不明显。但是当数据达到一定规模后，端对端的深度学习就表现得比较优异了。</li> 
   <li><strong>端对端的深度学习的一大优点是它可以让数据自己"做主"</strong>,因为以往的分阶段的方法实际上限制了机器分析问题的方法，即机器需要按照人类的方法去进行运算、提取特征以及估计。但是谁也不能保证按照人的方法进行一定是一个最优的方法，有时候将主动权交给机器不失为一种比较好的方法。</li> 
   <li>端对端的深度学习可以简化你设计的工作流程，不需要手工设计中间的表达方式。</li> 
   <li>**看似矛盾的，完全由计算机自己做主成为了端对端深度学习的一个缺点。**因为很多时候我们能够给神经网络提供的数据是有限的，如果完全任由神经网络自己做主而不考虑成本是不可能的。所以，在数据有限的情况下，我们需要一些中间过程，对神经网络加以引导，从而降低其对于数据的要求。如果你看到这里有点迷惑，请不要着急，往下看我会用一些例子来证明这一观点。</li> 
  </ul> 
  <h4><a id="3_82"></a>3.什么时候采用端对端的深度学习</h4> 
  <ul> 
   <li><strong>我的结论是：看你由输入到输出的映射是否是明确的，看你的数据能否允许你构建一个由输入直接指向输出的神经网络。对于那些无法端对端实现的问题，我们可以通过拆分成几个明确的映射关系。并且对每个关系实现端对端。</strong></li> 
   <li>比如运用在语言识别领域，你需要的输入是音频，输出是一句话，这中间实现的实际是一个音频到文本的映射关系，这种映射在生活中实际是很常见的，我们可以不断的收集数据，来实现这一功能。</li> 
   <li>再比如一个机器翻译模型，输入时英语，输出时汉语，这种映射关系是明确的，是可以端对端实现的。</li> 
   <li>然而不幸的是有的问题的直接映射关系是不明确的。生活中很常见的了，人脸识别系统，小名"刷脸"。输入是来自摄像头的一张图片，输出是是否与系统里的人匹配。为什么说这种关系是不明确的呢？因为实际拍摄过程中可能有各种情况发生：人离得远还是近？可能同时有几个人入镜到底谁是主角？要实现端对端，那么就需要各种情况下的人像数据，这不现实！所以采用第二种方法，将输入A映射成中间量B再映射到输出C。如下图所示：<br> <img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190115202831574.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjYW5mX3lvdXJuYW1l,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> Andrew延续了他灵魂画手一贯的画风2333!<br> 这里面的输入A是来自摄像头的第一张图片，中间量B是第二张图片，这里设计一个神经网络负责锁定人脸，并用圈定下来放大，这就是一个由A映射到B的过程。第二步相信是一个再熟悉不过的过程了，两张人脸进行匹配，如果匹配成功则输出1，失败则输出0。<br> <strong>现在你看有没有觉得海阔天空呢？相比端对端的方法，此方法将其分解成两个子问题，需要的代价大大减小了。这也就是我想说的，是否采用端对端取决于由输入到输出的关系是否明显，如果不明显那么想要实现端对端要求数据规模就会变大，如果有足够的数据做保障，完全ok，但是要是没有那么多数据，可以考虑绕个弯、想个办法。</strong></li> 
  </ul> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
