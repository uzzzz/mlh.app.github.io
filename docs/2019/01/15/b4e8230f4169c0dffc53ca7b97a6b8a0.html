<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>目标识别 YOLO 学习笔记（一） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="目标识别 YOLO 学习笔记（一）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本人博客除特别声明，均为个人原创，转载请注明。 https://blog.csdn.net/Lin_Danny/article/details/86498513 文章源于我的个人博客，地址：目标识别 YOLO 学习笔记（一）， 尊重原创，转载请注明。 这个笔记，主要是学习 YOLO 入门教程《How to implement a YOLO (v3) object detector from scratch in PyTorch》的笔记，其中包含自己学习过程中遇到的不懂之处的记录，其中一些英文单词并没有翻译，考虑到因为语言的差异，中文很难表达地很形象。与大家分享，以交流共勉。 笔记也会分为5个部分，层层递进，使用 PyTorch实现 YOLO (v3)。 完整的内容可参考原教程，在这里对教程的作者表示感谢。 基本YOLO知识 YOLO 全称为 You Only Look Once. YOLO 是全卷积网络，一共有75个卷积层，其中包含 skip connections 和 unsampling 层。没有使用任何池化层，使用步长为2的卷积层对特征图进行下采样（downsample）， 这就避免了由于池化所带来的低阶特征消失的问题。 虽然全卷积网络对图像的输入大小并不敏感，但我们仍希望输入图像的大小是固定了，以免在实现算法的过程中出现各种问题。 这些问题中最重要的一点是，如果我们想要批量处理图像（批量生成的图像可以由GPU并行处理，从而提高速度），我们需要拥有固定高度和宽度的图像。 这需要将多个图像连接成一个大批量（将许多PyTorch张量连接成一个） 输出 在YOLO中，通过使用使用1×1卷积的卷积层来完成预测。 所以，在YOLO中，输出是一个feature map。 由于我们使用了1 x 1个卷积，因此预测map的大小正好是之前的feature map的大小。 在YOLO v3（及其后代）中，您解释此预测图的方式是每个单元格可以预测固定数量的边界框。 深度方面，我们在特征图中有$B \times (5 + C)) $个条目，其中B 代表每个cell 可以预测的边界框（bounding box）的数量，根据论文研究，每个边界框可以专门检测某种对象。每个边界框有 ( 5 + C ) (5+C) (5+C) 个属性，描述了每个边界框的中心坐标，尺寸，对象度分数和C类置信度（confidence）。YOLO v3 在每个cell中预测三个边界框。 如果对象的中心落在该cell 的感知区域中，您希望feature map的每个cell 通过其中一个边界框预测对象。 与YOLO的训练方式有关的是，只有一个边界框（bounding box）负责检测任何给定的对象，即我们要确定这个边界框属于哪个 cell。为此，我们将输入图像划分为尺寸等于最终feature map的网格。 举例来说，我们有一个 416×416 的输入图像，网络的stride 为 32， 那么我们就将图像划为 13×13 个网格，即将输入图像切割为 13×13 个 cell。 然后，选择包含对象的ground truth box的中心的单元（在输入图像上）作为负责预测对象的单元。在该例子中，红色的cell 就是包含 ground truth box （黄色框）中心的cell。 现在，红色单元格是网格中第7行第7列的单元格。我们现在将特征图上的第7行中的第7个单元（特征图上的相应单元）指定为负责检测狗的单元。 现在，这个 cell 可以预测3个 bounding box（YOLO v3 中每个cell预测3个bounding box），那么哪一个将作为狗的 ground truth label呢？ Anchor Boxes 预测bounding box的宽度和高度可能是有意义的，但实际上，这会导致训练期间出现不稳定的梯度。 相反，大多数现代 object detectors 预测对数空间变换（log-space transforms），或简单地偏移到预定义的称为**锚（anchor）**的default bounding box。 然后，将这些reansforms 应用于 anchor 以获得预测。 YOLO v3有三个anchor，可以预测每个单元格的三个边界框 回到我们之前的问题，负责检测狗的bounding box将是其 anchor 具有最高IoU和ground truth box的那个。 做出预测 Marking Predictions 下面的公式给出了 如何由神经网络的输出经过转换，获得 bounding box 的预测。 b x = σ ( t x ) + c x b y = σ ( t y ) + c y b w = p w e t w b h = p h e t h b_x = \sigma (t_x) + c_x \\ b_y = \sigma (t_y) + c_y \\ b_w = p_w e^{t_w} \\ b_h = p_h e^{t_h} bx​=σ(tx​)+cx​by​=σ(ty​)+cy​bw​=pw​etw​bh​=ph​eth​ 这里的 b x , b y , b w , b h b_x, b_y, b_w, b_h bx​,by​,bw​,bh​ 分别是预测的中心坐标，宽度和高度； t x , t y , t w , t h t_x, t_y, t_w, t_h tx​,ty​,tw​,th​ 是神经网络的输出； c x , c y c_x, c_y cx​,cy​ 是ground truth box 中的中心所在网格（grid）的左上角坐标； p w , p h p_w, p_h pw​,ph​ 是 box 的 anchor 尺寸。 σ \sigma σ代表 sigmoid 函数 中心坐标 Center Coordinas 我们使用 sigmoid 函数来寻找我们的中心坐标的预测，这样的输出值范围为 0~1，我们为什么这么做呢？ 通常，YOLO不会预测 bounding box中心的绝对坐标，它预测的是偏移量： 相对于预测对象的grid cell 的左上角。 由feature map中的cell尺寸标准化。 例如，考虑上面的狗的图像，如果对中心的预测是（0.4, 0.7），那么这意味着中心位于13 x 13特征图上的（6.4,6.7）。（因为红色 cell 的左上角坐标是（6,6）） 但是，如果预测的x，y坐标大于1，会发生什么呢？比如（1.2, 0.7）， 这意味着中心位于（7.2, 6.7）。 请注意，中心现在位于我们的红色 cell 右侧的cell中，或者位于第7行的第8个cell中。 这打破了YOLO背后的理论，因为如果我们假设红色框负责预测狗，那么狗的中心必须位于红色单元格中，而不是位于旁边的单元格中。 因此，为了解决这个问题，输出通过sigmoid函数，该函数将输出压缩在0到1的范围内，有效地将中心保持在预测的网格中。 Dimension of Bounding Box 通过对输出应用 对数空间变换（log-space transform），然后乘以anchor 来预测边界框的尺寸。 预测得到的 b w , b h ​ b_w, b_h​ bw​,bh​​ 是经过图像的高度和宽度标准化的，因此，如果包含狗的bounding box 的预测bx和by是（0.3, 0.8），那么13 x 13特征图上的实际宽度和高度是（13 x 0.3,13 x 0.8）。 Objectness Score object score 表示对象包含在边界框内的概率。 对于红色和相邻的网格，它应该接近1，而对于角落处的网格，几乎为0。 对象性得分也通过sigmoid传递，因为它被解释为概率。 Class Confidences Class confidences （置信度）表示检测到的对象属于特定类（狗，猫，香蕉，汽车等）的概率。 在v3之前，YOLO使用 softmax的class score， 但是，该设计选择已在v3中删除，作者选择使用sigmoid。 原因是Softmaxing类得分假设类是互斥的。 简单来说，如果一个对象属于一个类，那么它就保证它不属于另一个类。 这对于我们将以检测器为基础的COCO数据库来说是正确的。 但是，当我们有像女人和人一样的课程时，这种假设可能不会成立。 这就是作者避免使用Softmax 的原因。 Prediction across different scales. YOLO v3通过3种不同的尺度进行预测。 检测层用于在三种不同尺寸的特征图上进行检测，分别具有步幅32,16,8。 这意味着，在输入为416 x 416的情况下，我们在13 x 13,26 x 26和52 x 52尺寸上进行检测。 网络对输入图像进行下采样，直到第一个检测层为止，其中使用具有步幅32的layer的feature maps 进行检测。 此外，对层进行2倍上采样，并与具有相同feature map尺寸的先前层的feature map连接。在具有步幅16的层处进行另一检测。重复相同的上采样过程，并且在步幅8的层处进行最终检测。在每个比例下，每个单元使用3个anchor来预测3个bounding box，使得使用的 anthor总数为9.（不同尺度的anchor不同） Output Processing 对于一个输入为 416×416 的图像，YOLO检测到 ( 52 × 52 + 26 × 26 + 13 × 13 ) × 3 = 10647 (52 \times 52 + 26 \times 26 + 13 \times 13) \times 3 = 10647 (52×52+26×26+13×13)×3=10647 个 bounding box， 但是对于我们的例子，图像中只有一个需要检测的对象，那么如何从 10467 得到 1 呢？ Thresholding by Object Confidence 通过对象置信度进行阈值处理。 首先，我们根据 objectness score 过滤boxes，通常，忽略具有低于阈值分数的box。 Non-maximum Suppression NMS旨在解决同一图像的多次检测问题，这时可以使用 NMS 算法获取其中最好的一个 box。 新名词学习 Receptive field 1. 是什么 中文可以译为 “感受野”。（个人感觉译过来并不好，直接使用英文就好） The receptive field is defined as the region in the input space that a particular CNN’s feature is looking at. 在卷积神经网络中，receptive map 的定义是：卷积神经网络每一层输出的特征图（feature map）上的像素点在原始图像上映射的区域大小。 在机器视觉领域的深度神经网络中的 receptive field，用来表示网络内部的不同位置的神经元对原图像的感受范围的大小。 所以，总结来看，receptive field 就是输入图像对某一层输出神经元的影响有多大。 2. Receptive Field 计算公式 从第一层卷积层，层层迭代，计算RF R F N = ( R F N − 1 − 1 ) ∗ s t r i d e + k e r n e l RF_{N} = (RF_{N-1} - 1) * stride + kernel RFN​=(RFN−1​−1)∗stride+kernel 其中 R F N − 1 RF_{N-1} RFN−1​ 表示第（N-1）层神经网络的 RF， R F N RF_N RFN​ 表示第 N 层 的RF，stride 表示由 (N-1) 层到 (N) 层的卷积步长，kernel表示卷积核大小。 注意：卷积神经网络的第一个卷积层的 RF 就是卷积核大小，因为它的一个像素点，代表了上一层的 kernel 个像素点的特征，这就是RF 的含义。 3. 举例 举一个例子，原始图像为 5 × 5 5 \times 5 5×5，卷积核（Kernel Size）为 3 × 3 3 \times 3 3×3 ，padding 为 1 &nbsp; t i m e s 1 1 \ times 1 1&nbsp;times1，stride为 2 × 2 2 \times 2 2×2，依照此卷积规则，连续做两次卷积，则第一次卷积结果是 3 × 3 3 \times 3 3×3的feature map，第二次卷积结果是 2 × 2 2 \times 2 2×2 大小的feature map。 则第一层卷积结束后，RF 为 3 × 3 ​ 3 \times 3​ 3×3​； 第二层卷积结束后，RF 大小为 ( 3 − 1 ) ∗ 2 + 3 = 7 ​ (3-1)*2+3 = 7​ (3−1)∗2+3=7​ 4. 检验RF 下面这个网站提供了 RF 的一键计算功能。 FOMORO AI 三个高级工程师搞的网站，可以简单的输入网络参数，就直接把你的感受野计算出来。界面如下。 IoU (Intersection over Union) IoU 用来表征在目标检测中，预测的 bounding box 和 ground truth 的bounding box 的重合程度。 待学习的知识 skip connections是什么 上采样和下采样（unsample， downsample）是什么 空间池化（spatial Pooling），也称为子采样（subsampling）或下采样（downsampling），其减少了每一个特征映射的维度，但是保留了最重要的信息。 bounding box regression是什么" />
<meta property="og:description" content="版权声明：本人博客除特别声明，均为个人原创，转载请注明。 https://blog.csdn.net/Lin_Danny/article/details/86498513 文章源于我的个人博客，地址：目标识别 YOLO 学习笔记（一）， 尊重原创，转载请注明。 这个笔记，主要是学习 YOLO 入门教程《How to implement a YOLO (v3) object detector from scratch in PyTorch》的笔记，其中包含自己学习过程中遇到的不懂之处的记录，其中一些英文单词并没有翻译，考虑到因为语言的差异，中文很难表达地很形象。与大家分享，以交流共勉。 笔记也会分为5个部分，层层递进，使用 PyTorch实现 YOLO (v3)。 完整的内容可参考原教程，在这里对教程的作者表示感谢。 基本YOLO知识 YOLO 全称为 You Only Look Once. YOLO 是全卷积网络，一共有75个卷积层，其中包含 skip connections 和 unsampling 层。没有使用任何池化层，使用步长为2的卷积层对特征图进行下采样（downsample）， 这就避免了由于池化所带来的低阶特征消失的问题。 虽然全卷积网络对图像的输入大小并不敏感，但我们仍希望输入图像的大小是固定了，以免在实现算法的过程中出现各种问题。 这些问题中最重要的一点是，如果我们想要批量处理图像（批量生成的图像可以由GPU并行处理，从而提高速度），我们需要拥有固定高度和宽度的图像。 这需要将多个图像连接成一个大批量（将许多PyTorch张量连接成一个） 输出 在YOLO中，通过使用使用1×1卷积的卷积层来完成预测。 所以，在YOLO中，输出是一个feature map。 由于我们使用了1 x 1个卷积，因此预测map的大小正好是之前的feature map的大小。 在YOLO v3（及其后代）中，您解释此预测图的方式是每个单元格可以预测固定数量的边界框。 深度方面，我们在特征图中有$B \times (5 + C)) $个条目，其中B 代表每个cell 可以预测的边界框（bounding box）的数量，根据论文研究，每个边界框可以专门检测某种对象。每个边界框有 ( 5 + C ) (5+C) (5+C) 个属性，描述了每个边界框的中心坐标，尺寸，对象度分数和C类置信度（confidence）。YOLO v3 在每个cell中预测三个边界框。 如果对象的中心落在该cell 的感知区域中，您希望feature map的每个cell 通过其中一个边界框预测对象。 与YOLO的训练方式有关的是，只有一个边界框（bounding box）负责检测任何给定的对象，即我们要确定这个边界框属于哪个 cell。为此，我们将输入图像划分为尺寸等于最终feature map的网格。 举例来说，我们有一个 416×416 的输入图像，网络的stride 为 32， 那么我们就将图像划为 13×13 个网格，即将输入图像切割为 13×13 个 cell。 然后，选择包含对象的ground truth box的中心的单元（在输入图像上）作为负责预测对象的单元。在该例子中，红色的cell 就是包含 ground truth box （黄色框）中心的cell。 现在，红色单元格是网格中第7行第7列的单元格。我们现在将特征图上的第7行中的第7个单元（特征图上的相应单元）指定为负责检测狗的单元。 现在，这个 cell 可以预测3个 bounding box（YOLO v3 中每个cell预测3个bounding box），那么哪一个将作为狗的 ground truth label呢？ Anchor Boxes 预测bounding box的宽度和高度可能是有意义的，但实际上，这会导致训练期间出现不稳定的梯度。 相反，大多数现代 object detectors 预测对数空间变换（log-space transforms），或简单地偏移到预定义的称为**锚（anchor）**的default bounding box。 然后，将这些reansforms 应用于 anchor 以获得预测。 YOLO v3有三个anchor，可以预测每个单元格的三个边界框 回到我们之前的问题，负责检测狗的bounding box将是其 anchor 具有最高IoU和ground truth box的那个。 做出预测 Marking Predictions 下面的公式给出了 如何由神经网络的输出经过转换，获得 bounding box 的预测。 b x = σ ( t x ) + c x b y = σ ( t y ) + c y b w = p w e t w b h = p h e t h b_x = \sigma (t_x) + c_x \\ b_y = \sigma (t_y) + c_y \\ b_w = p_w e^{t_w} \\ b_h = p_h e^{t_h} bx​=σ(tx​)+cx​by​=σ(ty​)+cy​bw​=pw​etw​bh​=ph​eth​ 这里的 b x , b y , b w , b h b_x, b_y, b_w, b_h bx​,by​,bw​,bh​ 分别是预测的中心坐标，宽度和高度； t x , t y , t w , t h t_x, t_y, t_w, t_h tx​,ty​,tw​,th​ 是神经网络的输出； c x , c y c_x, c_y cx​,cy​ 是ground truth box 中的中心所在网格（grid）的左上角坐标； p w , p h p_w, p_h pw​,ph​ 是 box 的 anchor 尺寸。 σ \sigma σ代表 sigmoid 函数 中心坐标 Center Coordinas 我们使用 sigmoid 函数来寻找我们的中心坐标的预测，这样的输出值范围为 0~1，我们为什么这么做呢？ 通常，YOLO不会预测 bounding box中心的绝对坐标，它预测的是偏移量： 相对于预测对象的grid cell 的左上角。 由feature map中的cell尺寸标准化。 例如，考虑上面的狗的图像，如果对中心的预测是（0.4, 0.7），那么这意味着中心位于13 x 13特征图上的（6.4,6.7）。（因为红色 cell 的左上角坐标是（6,6）） 但是，如果预测的x，y坐标大于1，会发生什么呢？比如（1.2, 0.7）， 这意味着中心位于（7.2, 6.7）。 请注意，中心现在位于我们的红色 cell 右侧的cell中，或者位于第7行的第8个cell中。 这打破了YOLO背后的理论，因为如果我们假设红色框负责预测狗，那么狗的中心必须位于红色单元格中，而不是位于旁边的单元格中。 因此，为了解决这个问题，输出通过sigmoid函数，该函数将输出压缩在0到1的范围内，有效地将中心保持在预测的网格中。 Dimension of Bounding Box 通过对输出应用 对数空间变换（log-space transform），然后乘以anchor 来预测边界框的尺寸。 预测得到的 b w , b h ​ b_w, b_h​ bw​,bh​​ 是经过图像的高度和宽度标准化的，因此，如果包含狗的bounding box 的预测bx和by是（0.3, 0.8），那么13 x 13特征图上的实际宽度和高度是（13 x 0.3,13 x 0.8）。 Objectness Score object score 表示对象包含在边界框内的概率。 对于红色和相邻的网格，它应该接近1，而对于角落处的网格，几乎为0。 对象性得分也通过sigmoid传递，因为它被解释为概率。 Class Confidences Class confidences （置信度）表示检测到的对象属于特定类（狗，猫，香蕉，汽车等）的概率。 在v3之前，YOLO使用 softmax的class score， 但是，该设计选择已在v3中删除，作者选择使用sigmoid。 原因是Softmaxing类得分假设类是互斥的。 简单来说，如果一个对象属于一个类，那么它就保证它不属于另一个类。 这对于我们将以检测器为基础的COCO数据库来说是正确的。 但是，当我们有像女人和人一样的课程时，这种假设可能不会成立。 这就是作者避免使用Softmax 的原因。 Prediction across different scales. YOLO v3通过3种不同的尺度进行预测。 检测层用于在三种不同尺寸的特征图上进行检测，分别具有步幅32,16,8。 这意味着，在输入为416 x 416的情况下，我们在13 x 13,26 x 26和52 x 52尺寸上进行检测。 网络对输入图像进行下采样，直到第一个检测层为止，其中使用具有步幅32的layer的feature maps 进行检测。 此外，对层进行2倍上采样，并与具有相同feature map尺寸的先前层的feature map连接。在具有步幅16的层处进行另一检测。重复相同的上采样过程，并且在步幅8的层处进行最终检测。在每个比例下，每个单元使用3个anchor来预测3个bounding box，使得使用的 anthor总数为9.（不同尺度的anchor不同） Output Processing 对于一个输入为 416×416 的图像，YOLO检测到 ( 52 × 52 + 26 × 26 + 13 × 13 ) × 3 = 10647 (52 \times 52 + 26 \times 26 + 13 \times 13) \times 3 = 10647 (52×52+26×26+13×13)×3=10647 个 bounding box， 但是对于我们的例子，图像中只有一个需要检测的对象，那么如何从 10467 得到 1 呢？ Thresholding by Object Confidence 通过对象置信度进行阈值处理。 首先，我们根据 objectness score 过滤boxes，通常，忽略具有低于阈值分数的box。 Non-maximum Suppression NMS旨在解决同一图像的多次检测问题，这时可以使用 NMS 算法获取其中最好的一个 box。 新名词学习 Receptive field 1. 是什么 中文可以译为 “感受野”。（个人感觉译过来并不好，直接使用英文就好） The receptive field is defined as the region in the input space that a particular CNN’s feature is looking at. 在卷积神经网络中，receptive map 的定义是：卷积神经网络每一层输出的特征图（feature map）上的像素点在原始图像上映射的区域大小。 在机器视觉领域的深度神经网络中的 receptive field，用来表示网络内部的不同位置的神经元对原图像的感受范围的大小。 所以，总结来看，receptive field 就是输入图像对某一层输出神经元的影响有多大。 2. Receptive Field 计算公式 从第一层卷积层，层层迭代，计算RF R F N = ( R F N − 1 − 1 ) ∗ s t r i d e + k e r n e l RF_{N} = (RF_{N-1} - 1) * stride + kernel RFN​=(RFN−1​−1)∗stride+kernel 其中 R F N − 1 RF_{N-1} RFN−1​ 表示第（N-1）层神经网络的 RF， R F N RF_N RFN​ 表示第 N 层 的RF，stride 表示由 (N-1) 层到 (N) 层的卷积步长，kernel表示卷积核大小。 注意：卷积神经网络的第一个卷积层的 RF 就是卷积核大小，因为它的一个像素点，代表了上一层的 kernel 个像素点的特征，这就是RF 的含义。 3. 举例 举一个例子，原始图像为 5 × 5 5 \times 5 5×5，卷积核（Kernel Size）为 3 × 3 3 \times 3 3×3 ，padding 为 1 &nbsp; t i m e s 1 1 \ times 1 1&nbsp;times1，stride为 2 × 2 2 \times 2 2×2，依照此卷积规则，连续做两次卷积，则第一次卷积结果是 3 × 3 3 \times 3 3×3的feature map，第二次卷积结果是 2 × 2 2 \times 2 2×2 大小的feature map。 则第一层卷积结束后，RF 为 3 × 3 ​ 3 \times 3​ 3×3​； 第二层卷积结束后，RF 大小为 ( 3 − 1 ) ∗ 2 + 3 = 7 ​ (3-1)*2+3 = 7​ (3−1)∗2+3=7​ 4. 检验RF 下面这个网站提供了 RF 的一键计算功能。 FOMORO AI 三个高级工程师搞的网站，可以简单的输入网络参数，就直接把你的感受野计算出来。界面如下。 IoU (Intersection over Union) IoU 用来表征在目标检测中，预测的 bounding box 和 ground truth 的bounding box 的重合程度。 待学习的知识 skip connections是什么 上采样和下采样（unsample， downsample）是什么 空间池化（spatial Pooling），也称为子采样（subsampling）或下采样（downsampling），其减少了每一个特征映射的维度，但是保留了最重要的信息。 bounding box regression是什么" />
<link rel="canonical" href="https://mlh.app/2019/01/15/b4e8230f4169c0dffc53ca7b97a6b8a0.html" />
<meta property="og:url" content="https://mlh.app/2019/01/15/b4e8230f4169c0dffc53ca7b97a6b8a0.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-15T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本人博客除特别声明，均为个人原创，转载请注明。 https://blog.csdn.net/Lin_Danny/article/details/86498513 文章源于我的个人博客，地址：目标识别 YOLO 学习笔记（一）， 尊重原创，转载请注明。 这个笔记，主要是学习 YOLO 入门教程《How to implement a YOLO (v3) object detector from scratch in PyTorch》的笔记，其中包含自己学习过程中遇到的不懂之处的记录，其中一些英文单词并没有翻译，考虑到因为语言的差异，中文很难表达地很形象。与大家分享，以交流共勉。 笔记也会分为5个部分，层层递进，使用 PyTorch实现 YOLO (v3)。 完整的内容可参考原教程，在这里对教程的作者表示感谢。 基本YOLO知识 YOLO 全称为 You Only Look Once. YOLO 是全卷积网络，一共有75个卷积层，其中包含 skip connections 和 unsampling 层。没有使用任何池化层，使用步长为2的卷积层对特征图进行下采样（downsample）， 这就避免了由于池化所带来的低阶特征消失的问题。 虽然全卷积网络对图像的输入大小并不敏感，但我们仍希望输入图像的大小是固定了，以免在实现算法的过程中出现各种问题。 这些问题中最重要的一点是，如果我们想要批量处理图像（批量生成的图像可以由GPU并行处理，从而提高速度），我们需要拥有固定高度和宽度的图像。 这需要将多个图像连接成一个大批量（将许多PyTorch张量连接成一个） 输出 在YOLO中，通过使用使用1×1卷积的卷积层来完成预测。 所以，在YOLO中，输出是一个feature map。 由于我们使用了1 x 1个卷积，因此预测map的大小正好是之前的feature map的大小。 在YOLO v3（及其后代）中，您解释此预测图的方式是每个单元格可以预测固定数量的边界框。 深度方面，我们在特征图中有$B \\times (5 + C)) $个条目，其中B 代表每个cell 可以预测的边界框（bounding box）的数量，根据论文研究，每个边界框可以专门检测某种对象。每个边界框有 ( 5 + C ) (5+C) (5+C) 个属性，描述了每个边界框的中心坐标，尺寸，对象度分数和C类置信度（confidence）。YOLO v3 在每个cell中预测三个边界框。 如果对象的中心落在该cell 的感知区域中，您希望feature map的每个cell 通过其中一个边界框预测对象。 与YOLO的训练方式有关的是，只有一个边界框（bounding box）负责检测任何给定的对象，即我们要确定这个边界框属于哪个 cell。为此，我们将输入图像划分为尺寸等于最终feature map的网格。 举例来说，我们有一个 416×416 的输入图像，网络的stride 为 32， 那么我们就将图像划为 13×13 个网格，即将输入图像切割为 13×13 个 cell。 然后，选择包含对象的ground truth box的中心的单元（在输入图像上）作为负责预测对象的单元。在该例子中，红色的cell 就是包含 ground truth box （黄色框）中心的cell。 现在，红色单元格是网格中第7行第7列的单元格。我们现在将特征图上的第7行中的第7个单元（特征图上的相应单元）指定为负责检测狗的单元。 现在，这个 cell 可以预测3个 bounding box（YOLO v3 中每个cell预测3个bounding box），那么哪一个将作为狗的 ground truth label呢？ Anchor Boxes 预测bounding box的宽度和高度可能是有意义的，但实际上，这会导致训练期间出现不稳定的梯度。 相反，大多数现代 object detectors 预测对数空间变换（log-space transforms），或简单地偏移到预定义的称为**锚（anchor）**的default bounding box。 然后，将这些reansforms 应用于 anchor 以获得预测。 YOLO v3有三个anchor，可以预测每个单元格的三个边界框 回到我们之前的问题，负责检测狗的bounding box将是其 anchor 具有最高IoU和ground truth box的那个。 做出预测 Marking Predictions 下面的公式给出了 如何由神经网络的输出经过转换，获得 bounding box 的预测。 b x = σ ( t x ) + c x b y = σ ( t y ) + c y b w = p w e t w b h = p h e t h b_x = \\sigma (t_x) + c_x \\\\ b_y = \\sigma (t_y) + c_y \\\\ b_w = p_w e^{t_w} \\\\ b_h = p_h e^{t_h} bx​=σ(tx​)+cx​by​=σ(ty​)+cy​bw​=pw​etw​bh​=ph​eth​ 这里的 b x , b y , b w , b h b_x, b_y, b_w, b_h bx​,by​,bw​,bh​ 分别是预测的中心坐标，宽度和高度； t x , t y , t w , t h t_x, t_y, t_w, t_h tx​,ty​,tw​,th​ 是神经网络的输出； c x , c y c_x, c_y cx​,cy​ 是ground truth box 中的中心所在网格（grid）的左上角坐标； p w , p h p_w, p_h pw​,ph​ 是 box 的 anchor 尺寸。 σ \\sigma σ代表 sigmoid 函数 中心坐标 Center Coordinas 我们使用 sigmoid 函数来寻找我们的中心坐标的预测，这样的输出值范围为 0~1，我们为什么这么做呢？ 通常，YOLO不会预测 bounding box中心的绝对坐标，它预测的是偏移量： 相对于预测对象的grid cell 的左上角。 由feature map中的cell尺寸标准化。 例如，考虑上面的狗的图像，如果对中心的预测是（0.4, 0.7），那么这意味着中心位于13 x 13特征图上的（6.4,6.7）。（因为红色 cell 的左上角坐标是（6,6）） 但是，如果预测的x，y坐标大于1，会发生什么呢？比如（1.2, 0.7）， 这意味着中心位于（7.2, 6.7）。 请注意，中心现在位于我们的红色 cell 右侧的cell中，或者位于第7行的第8个cell中。 这打破了YOLO背后的理论，因为如果我们假设红色框负责预测狗，那么狗的中心必须位于红色单元格中，而不是位于旁边的单元格中。 因此，为了解决这个问题，输出通过sigmoid函数，该函数将输出压缩在0到1的范围内，有效地将中心保持在预测的网格中。 Dimension of Bounding Box 通过对输出应用 对数空间变换（log-space transform），然后乘以anchor 来预测边界框的尺寸。 预测得到的 b w , b h ​ b_w, b_h​ bw​,bh​​ 是经过图像的高度和宽度标准化的，因此，如果包含狗的bounding box 的预测bx和by是（0.3, 0.8），那么13 x 13特征图上的实际宽度和高度是（13 x 0.3,13 x 0.8）。 Objectness Score object score 表示对象包含在边界框内的概率。 对于红色和相邻的网格，它应该接近1，而对于角落处的网格，几乎为0。 对象性得分也通过sigmoid传递，因为它被解释为概率。 Class Confidences Class confidences （置信度）表示检测到的对象属于特定类（狗，猫，香蕉，汽车等）的概率。 在v3之前，YOLO使用 softmax的class score， 但是，该设计选择已在v3中删除，作者选择使用sigmoid。 原因是Softmaxing类得分假设类是互斥的。 简单来说，如果一个对象属于一个类，那么它就保证它不属于另一个类。 这对于我们将以检测器为基础的COCO数据库来说是正确的。 但是，当我们有像女人和人一样的课程时，这种假设可能不会成立。 这就是作者避免使用Softmax 的原因。 Prediction across different scales. YOLO v3通过3种不同的尺度进行预测。 检测层用于在三种不同尺寸的特征图上进行检测，分别具有步幅32,16,8。 这意味着，在输入为416 x 416的情况下，我们在13 x 13,26 x 26和52 x 52尺寸上进行检测。 网络对输入图像进行下采样，直到第一个检测层为止，其中使用具有步幅32的layer的feature maps 进行检测。 此外，对层进行2倍上采样，并与具有相同feature map尺寸的先前层的feature map连接。在具有步幅16的层处进行另一检测。重复相同的上采样过程，并且在步幅8的层处进行最终检测。在每个比例下，每个单元使用3个anchor来预测3个bounding box，使得使用的 anthor总数为9.（不同尺度的anchor不同） Output Processing 对于一个输入为 416×416 的图像，YOLO检测到 ( 52 × 52 + 26 × 26 + 13 × 13 ) × 3 = 10647 (52 \\times 52 + 26 \\times 26 + 13 \\times 13) \\times 3 = 10647 (52×52+26×26+13×13)×3=10647 个 bounding box， 但是对于我们的例子，图像中只有一个需要检测的对象，那么如何从 10467 得到 1 呢？ Thresholding by Object Confidence 通过对象置信度进行阈值处理。 首先，我们根据 objectness score 过滤boxes，通常，忽略具有低于阈值分数的box。 Non-maximum Suppression NMS旨在解决同一图像的多次检测问题，这时可以使用 NMS 算法获取其中最好的一个 box。 新名词学习 Receptive field 1. 是什么 中文可以译为 “感受野”。（个人感觉译过来并不好，直接使用英文就好） The receptive field is defined as the region in the input space that a particular CNN’s feature is looking at. 在卷积神经网络中，receptive map 的定义是：卷积神经网络每一层输出的特征图（feature map）上的像素点在原始图像上映射的区域大小。 在机器视觉领域的深度神经网络中的 receptive field，用来表示网络内部的不同位置的神经元对原图像的感受范围的大小。 所以，总结来看，receptive field 就是输入图像对某一层输出神经元的影响有多大。 2. Receptive Field 计算公式 从第一层卷积层，层层迭代，计算RF R F N = ( R F N − 1 − 1 ) ∗ s t r i d e + k e r n e l RF_{N} = (RF_{N-1} - 1) * stride + kernel RFN​=(RFN−1​−1)∗stride+kernel 其中 R F N − 1 RF_{N-1} RFN−1​ 表示第（N-1）层神经网络的 RF， R F N RF_N RFN​ 表示第 N 层 的RF，stride 表示由 (N-1) 层到 (N) 层的卷积步长，kernel表示卷积核大小。 注意：卷积神经网络的第一个卷积层的 RF 就是卷积核大小，因为它的一个像素点，代表了上一层的 kernel 个像素点的特征，这就是RF 的含义。 3. 举例 举一个例子，原始图像为 5 × 5 5 \\times 5 5×5，卷积核（Kernel Size）为 3 × 3 3 \\times 3 3×3 ，padding 为 1 &nbsp; t i m e s 1 1 \\ times 1 1&nbsp;times1，stride为 2 × 2 2 \\times 2 2×2，依照此卷积规则，连续做两次卷积，则第一次卷积结果是 3 × 3 3 \\times 3 3×3的feature map，第二次卷积结果是 2 × 2 2 \\times 2 2×2 大小的feature map。 则第一层卷积结束后，RF 为 3 × 3 ​ 3 \\times 3​ 3×3​； 第二层卷积结束后，RF 大小为 ( 3 − 1 ) ∗ 2 + 3 = 7 ​ (3-1)*2+3 = 7​ (3−1)∗2+3=7​ 4. 检验RF 下面这个网站提供了 RF 的一键计算功能。 FOMORO AI 三个高级工程师搞的网站，可以简单的输入网络参数，就直接把你的感受野计算出来。界面如下。 IoU (Intersection over Union) IoU 用来表征在目标检测中，预测的 bounding box 和 ground truth 的bounding box 的重合程度。 待学习的知识 skip connections是什么 上采样和下采样（unsample， downsample）是什么 空间池化（spatial Pooling），也称为子采样（subsampling）或下采样（downsampling），其减少了每一个特征映射的维度，但是保留了最重要的信息。 bounding box regression是什么","@type":"BlogPosting","url":"https://mlh.app/2019/01/15/b4e8230f4169c0dffc53ca7b97a6b8a0.html","headline":"目标识别 YOLO 学习笔记（一）","dateModified":"2019-01-15T00:00:00+08:00","datePublished":"2019-01-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/01/15/b4e8230f4169c0dffc53ca7b97a6b8a0.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>目标识别 YOLO 学习笔记（一）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本人博客除特别声明，均为个人原创，转载请注明。 https://blog.csdn.net/Lin_Danny/article/details/86498513 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>文章源于我的个人博客，地址：<a href="https://www.linzhongya.top/235/%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB-yolo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" rel="nofollow">目标识别 YOLO 学习笔记（一）</a>， 尊重原创，转载请注明。</p> 
  <p>这个笔记，主要是学习 YOLO 入门教程《<a href="https://blog.paperspace.com/" rel="nofollow">How to implement a YOLO (v3) object detector from scratch in PyTorch</a>》的笔记，其中包含自己学习过程中遇到的不懂之处的记录，其中一些英文单词并没有翻译，考虑到因为语言的差异，中文很难表达地很形象。与大家分享，以交流共勉。</p> 
  <p>笔记也会分为5个部分，层层递进，使用 PyTorch实现 YOLO (v3)。 完整的内容可参考<a href="https://blog.paperspace.com/how-to-implement-a-yolo-v3-object-detector-from-scratch-in-pytorch-part-1/" rel="nofollow">原教程</a>，在这里对教程的作者表示感谢。</p> 
  <h1><a id="YOLO_6"></a>基本YOLO知识</h1> 
  <p>YOLO 全称为 You Only Look Once.</p> 
  <p>YOLO 是全卷积网络，一共有75个卷积层，其中包含 skip connections 和 unsampling 层。没有使用任何池化层，使用步长为2的卷积层对特征图进行下采样（downsample）， 这就避免了由于池化所带来的低阶特征消失的问题。</p> 
  <p>虽然全卷积网络对图像的输入大小并不敏感，但我们仍希望输入图像的大小是固定了，以免在实现算法的过程中出现各种问题。</p> 
  <p>这些问题中最重要的一点是，如果我们想要批量处理图像（批量生成的图像可以由GPU并行处理，从而提高速度），我们需要拥有固定高度和宽度的图像。 这需要将多个图像连接成一个大批量（将许多PyTorch张量连接成一个）</p> 
  <h1><a id="_18"></a>输出</h1> 
  <p>在YOLO中，通过使用使用1×1卷积的卷积层来完成预测。</p> 
  <p>所以，在YOLO中，输出是一个feature map。 由于我们使用了1 x 1个卷积，因此预测map的大小正好是之前的feature map的大小。 在YOLO v3（及其后代）中，您解释此预测图的方式是每个单元格可以预测固定数量的边界框。</p> 
  <p><strong>深度方面，我们在特征图中有$B \times (5 + C)) $个条目</strong>，其中B 代表每个cell 可以预测的边界框（bounding box）的数量，根据论文研究，每个边界框可以专门检测某种对象。每个边界框有 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mo>
          (
         </mo>
         <mn>
          5
         </mn>
         <mo>
          +
         </mo>
         <mi>
          C
         </mi>
         <mo>
          )
         </mo>
        </mrow>
        <annotation encoding="application/x-tex">
         (5+C)
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mclose">)</span></span></span></span></span> 个属性，描述了每个边界框的中心坐标，尺寸，对象度分数和C类置信度（confidence）。YOLO v3 在每个cell中预测三个边界框。</p> 
  <p><strong>如果对象的中心落在该cell 的感知区域中，您希望feature map的每个cell 通过其中一个边界框预测对象。</strong></p> 
  <p>与YOLO的训练方式有关的是，只有一个边界框（bounding box）负责检测任何给定的对象，即我们要确定这个边界框属于哪个 cell。为此，我们将输入图像划分为尺寸等于最终feature map的网格。</p> 
  <p>举例来说，我们有一个 416×416 的输入图像，网络的stride 为 32， 那么我们就将图像划为 13×13 个网格，即将输入图像切割为 13×13 个 cell。</p> 
  <p>然后，选择包含对象的ground truth box的中心的单元（在输入图像上）作为负责预测对象的单元。在该例子中，红色的cell 就是包含 ground truth box （黄色框）中心的cell。</p> 
  <p>现在，红色单元格是网格中第7行第7列的单元格。我们现在将特征图上的第7行中的第7个单元（特征图上的相应单元）指定为负责检测狗的单元。</p> 
  <p>现在，这个 cell 可以预测3个 bounding box（YOLO v3 中每个cell预测3个bounding box），那么哪一个将作为狗的 ground truth label呢？</p> 
  <p><img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190115201003633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpbl9EYW5ueQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <h1><a id="Anchor_Boxes_40"></a>Anchor Boxes</h1> 
  <p>预测bounding box的宽度和高度可能是有意义的，但实际上，这会导致训练期间出现不稳定的梯度。 相反，大多数现代 object detectors 预测对数空间变换（log-space transforms），或简单地偏移到预定义的称为**锚（anchor）**的default bounding box。</p> 
  <p>然后，将这些reansforms 应用于 anchor 以获得预测。 YOLO v3有三个anchor，可以预测每个单元格的三个边界框</p> 
  <p>回到我们之前的问题，负责检测狗的bounding box将是其 anchor 具有最高IoU和ground truth box的那个。</p> 
  <h1><a id="_Marking_Predictions_50"></a>做出预测 Marking Predictions</h1> 
  <p>下面的公式给出了 如何由神经网络的输出经过转换，获得 bounding box 的预测。<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <msub>
           <mi>
            b
           </mi>
           <mi>
            x
           </mi>
          </msub>
          <mo>
           =
          </mo>
          <mi>
           σ
          </mi>
          <mo>
           (
          </mo>
          <msub>
           <mi>
            t
           </mi>
           <mi>
            x
           </mi>
          </msub>
          <mo>
           )
          </mo>
          <mo>
           +
          </mo>
          <msub>
           <mi>
            c
           </mi>
           <mi>
            x
           </mi>
          </msub>
          <mspace linebreak="newline"></mspace>
          <msub>
           <mi>
            b
           </mi>
           <mi>
            y
           </mi>
          </msub>
          <mo>
           =
          </mo>
          <mi>
           σ
          </mi>
          <mo>
           (
          </mo>
          <msub>
           <mi>
            t
           </mi>
           <mi>
            y
           </mi>
          </msub>
          <mo>
           )
          </mo>
          <mo>
           +
          </mo>
          <msub>
           <mi>
            c
           </mi>
           <mi>
            y
           </mi>
          </msub>
          <mspace linebreak="newline"></mspace>
          <msub>
           <mi>
            b
           </mi>
           <mi>
            w
           </mi>
          </msub>
          <mo>
           =
          </mo>
          <msub>
           <mi>
            p
           </mi>
           <mi>
            w
           </mi>
          </msub>
          <msup>
           <mi>
            e
           </mi>
           <msub>
            <mi>
             t
            </mi>
            <mi>
             w
            </mi>
           </msub>
          </msup>
          <mspace linebreak="newline"></mspace>
          <msub>
           <mi>
            b
           </mi>
           <mi>
            h
           </mi>
          </msub>
          <mo>
           =
          </mo>
          <msub>
           <mi>
            p
           </mi>
           <mi>
            h
           </mi>
          </msub>
          <msup>
           <mi>
            e
           </mi>
           <msub>
            <mi>
             t
            </mi>
            <mi>
             h
            </mi>
           </msub>
          </msup>
         </mrow>
         <annotation encoding="application/x-tex">
           b_x = \sigma (t_x) + c_x \\ b_y = \sigma (t_y) + c_y \\ b_w = p_w e^{t_w} \\ b_h = p_h e^{t_h} 
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.038em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.843556em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.164543em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.038em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.843556em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.34877em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.151229em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br> 这里的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msub>
          <mi>
           b
          </mi>
          <mi>
           x
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           b
          </mi>
          <mi>
           y
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           b
          </mi>
          <mi>
           w
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           b
          </mi>
          <mi>
           h
          </mi>
         </msub>
        </mrow>
        <annotation encoding="application/x-tex">
         b_x, b_y, b_w, b_h
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 分别是预测的中心坐标，宽度和高度； <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msub>
          <mi>
           t
          </mi>
          <mi>
           x
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           t
          </mi>
          <mi>
           y
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           t
          </mi>
          <mi>
           w
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           t
          </mi>
          <mi>
           h
          </mi>
         </msub>
        </mrow>
        <annotation encoding="application/x-tex">
         t_x, t_y, t_w, t_h
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.901188em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是神经网络的输出； <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msub>
          <mi>
           c
          </mi>
          <mi>
           x
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           c
          </mi>
          <mi>
           y
          </mi>
         </msub>
        </mrow>
        <annotation encoding="application/x-tex">
         c_x, c_y
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.716668em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是ground truth box 中的中心所在网格（grid）的左上角坐标；<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msub>
          <mi>
           p
          </mi>
          <mi>
           w
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           p
          </mi>
          <mi>
           h
          </mi>
         </msub>
        </mrow>
        <annotation encoding="application/x-tex">
         p_w, p_h
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是 box 的 anchor 尺寸。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          σ
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         \sigma
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">σ</span></span></span></span></span>代表 sigmoid 函数</p> 
  <h2><a id="_Center_Coordinas_66"></a>中心坐标 Center Coordinas</h2> 
  <p>我们使用 sigmoid 函数来寻找我们的中心坐标的预测，这样的输出值范围为 0~1，我们为什么这么做呢？</p> 
  <p>通常，YOLO不会预测 bounding box中心的绝对坐标，它预测的是偏移量：</p> 
  <ul> 
   <li>相对于预测对象的grid cell 的左上角。</li> 
   <li>由feature map中的cell尺寸标准化。</li> 
  </ul> 
  <p>例如，考虑上面的狗的图像，如果对中心的预测是（0.4, 0.7），那么这意味着中心位于13 x 13特征图上的（6.4,6.7）。（因为红色 cell 的左上角坐标是（6,6））</p> 
  <p>但是，如果预测的x，y坐标大于1，会发生什么呢？比如（1.2, 0.7）， 这意味着中心位于（7.2, 6.7）。 请注意，中心现在位于我们的红色 cell 右侧的cell中，或者位于第7行的第8个cell中。 这打破了YOLO背后的理论，因为如果我们假设红色框负责预测狗，那么狗的中心必须位于红色单元格中，而不是位于旁边的单元格中。 因此，为了解决这个问题，输出通过sigmoid函数，该函数将输出压缩在0到1的范围内，有效地将中心保持在预测的网格中。</p> 
  <h2><a id="Dimension_of_Bounding_Box_81"></a>Dimension of Bounding Box</h2> 
  <p>通过对输出应用 对数空间变换（log-space transform），然后乘以anchor 来预测边界框的尺寸。</p> 
  <p>预测得到的<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <msub>
          <mi>
           b
          </mi>
          <mi>
           w
          </mi>
         </msub>
         <mo separator="true">
          ,
         </mo>
         <msub>
          <mi>
           b
          </mi>
          <mi>
           h
          </mi>
         </msub>
         <mi mathvariant="normal">
          ​
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         b_w, b_h​
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord">​</span></span></span></span></span> 是经过图像的高度和宽度标准化的，因此，如果包含狗的bounding box 的预测bx和by是（0.3, 0.8），那么13 x 13特征图上的实际宽度和高度是（13 x 0.3,13 x 0.8）。</p> 
  <h2><a id="Objectness_Score_89"></a>Objectness Score</h2> 
  <p>object score 表示对象包含在边界框内的概率。 对于红色和相邻的网格，它应该接近1，而对于角落处的网格，几乎为0。 对象性得分也通过sigmoid传递，因为它被解释为概率。</p> 
  <h2><a id="Class_Confidences_95"></a>Class Confidences</h2> 
  <p>Class confidences （置信度）表示检测到的对象属于特定类（狗，猫，香蕉，汽车等）的概率。 在v3之前，YOLO使用 softmax的class score， 但是，该设计选择已在v3中删除，作者选择使用sigmoid。 原因是Softmaxing类得分假设类是互斥的。 简单来说，如果一个对象属于一个类，那么它就保证它不属于另一个类。 这对于我们将以检测器为基础的COCO数据库来说是正确的。 但是，当我们有像女人和人一样的课程时，这种假设可能不会成立。 这就是作者避免使用Softmax 的原因。</p> 
  <h1><a id="Prediction_across_different_scales_101"></a>Prediction across different scales.</h1> 
  <p>YOLO v3通过3种不同的尺度进行预测。 检测层用于在三种不同尺寸的特征图上进行检测，分别具有步幅32,16,8。 这意味着，在输入为416 x 416的情况下，我们在13 x 13,26 x 26和52 x 52尺寸上进行检测。</p> 
  <p>网络对输入图像进行下采样，直到第一个检测层为止，其中使用具有步幅32的layer的feature maps 进行检测。 此外，对层进行2倍上采样，并与具有相同feature map尺寸的先前层的feature map连接。在具有步幅16的层处进行另一检测。重复相同的上采样过程，并且在步幅8的层处进行最终检测。在每个比例下，每个单元使用3个anchor来预测3个bounding box，使得使用的 anthor总数为9.（不同尺度的anchor不同）</p> 
  <h1><a id="Output_Processing_109"></a>Output Processing</h1> 
  <p>对于一个输入为 416×416 的图像，YOLO检测到 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mo>
          (
         </mo>
         <mn>
          52
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          52
         </mn>
         <mo>
          +
         </mo>
         <mn>
          26
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          26
         </mn>
         <mo>
          +
         </mo>
         <mn>
          13
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          13
         </mn>
         <mo>
          )
         </mo>
         <mo>
          ×
         </mo>
         <mn>
          3
         </mn>
         <mo>
          =
         </mo>
         <mn>
          10647
         </mn>
        </mrow>
        <annotation encoding="application/x-tex">
         (52 \times 52 + 26 \times 26 + 13 \times 13) \times 3 = 10647
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span></span></span></span></span> 个 bounding box， 但是对于我们的例子，图像中只有一个需要检测的对象，那么如何从 10467 得到 1 呢？</p> 
  <h2><a id="Thresholding_by_Object_Confidence_113"></a>Thresholding by Object Confidence</h2> 
  <p>通过对象置信度进行阈值处理。</p> 
  <p>首先，我们根据 objectness score 过滤boxes，通常，忽略具有低于阈值分数的box。</p> 
  <h2><a id="Nonmaximum_Suppression_121"></a>Non-maximum Suppression</h2> 
  <p>NMS旨在解决同一图像的多次检测问题，这时可以使用 NMS 算法获取其中最好的一个 box。</p> 
  <h1><a id="_127"></a>新名词学习</h1> 
  <h2><a id="Receptive_field_129"></a>Receptive field</h2> 
  <p><strong>1. 是什么</strong></p> 
  <p>中文可以译为 “感受野”。（个人感觉译过来并不好，直接使用英文就好）</p> 
  <blockquote> 
   <p><em>The</em> <strong>receptive field</strong> is defined as the region in the <strong>input space</strong> that a particular CNN’s feature is looking at.</p> 
  </blockquote> 
  <blockquote> 
   <p>在卷积神经网络中，receptive map 的定义是：卷积神经网络每一层输出的特征图（feature map）上的像素点在<strong>原始图像</strong>上映射的区域大小。</p> 
  </blockquote> 
  <blockquote> 
   <p>在机器视觉领域的深度神经网络中的 receptive field，用来表示网络内部的不同位置的神经元对<strong>原图像</strong>的感受范围的大小。</p> 
  </blockquote> 
  <blockquote> 
   <p>所以，总结来看，receptive field 就是输入图像对某一层输出神经元的影响有多大。</p> 
  </blockquote> 
  <p><strong>2. Receptive Field 计算公式</strong></p> 
  <p>从第一层卷积层，层层迭代，计算RF<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
       <math>
        <semantics>
         <mrow>
          <mi>
           R
          </mi>
          <msub>
           <mi>
            F
           </mi>
           <mi>
            N
           </mi>
          </msub>
          <mo>
           =
          </mo>
          <mo>
           (
          </mo>
          <mi>
           R
          </mi>
          <msub>
           <mi>
            F
           </mi>
           <mrow>
            <mi>
             N
            </mi>
            <mo>
             −
            </mo>
            <mn>
             1
            </mn>
           </mrow>
          </msub>
          <mo>
           −
          </mo>
          <mn>
           1
          </mn>
          <mo>
           )
          </mo>
          <mo>
           ∗
          </mo>
          <mi>
           s
          </mi>
          <mi>
           t
          </mi>
          <mi>
           r
          </mi>
          <mi>
           i
          </mi>
          <mi>
           d
          </mi>
          <mi>
           e
          </mi>
          <mo>
           +
          </mo>
          <mi>
           k
          </mi>
          <mi>
           e
          </mi>
          <mi>
           r
          </mi>
          <mi>
           n
          </mi>
          <mi>
           e
          </mi>
          <mi>
           l
          </mi>
         </mrow>
         <annotation encoding="application/x-tex">
           RF_{N} = (RF_{N-1} - 1) * stride + kernel 
         </annotation>
        </semantics>
       </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord mathit" style="margin-right: 0.00773em;">R</span><span class="mord"><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.00773em;">R</span><span class="mord"><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span></span></span></span></span></span><br> 其中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          R
         </mi>
         <msub>
          <mi>
           F
          </mi>
          <mrow>
           <mi>
            N
           </mi>
           <mo>
            −
           </mo>
           <mn>
            1
           </mn>
          </mrow>
         </msub>
        </mrow>
        <annotation encoding="application/x-tex">
         RF_{N-1}
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.891661em; vertical-align: -0.208331em;"></span><span class="mord mathit" style="margin-right: 0.00773em;">R</span><span class="mord"><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示第（N-1）层神经网络的 RF， <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          R
         </mi>
         <msub>
          <mi>
           F
          </mi>
          <mi>
           N
          </mi>
         </msub>
        </mrow>
        <annotation encoding="application/x-tex">
         RF_N
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord mathit" style="margin-right: 0.00773em;">R</span><span class="mord"><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示第 N 层 的RF，stride 表示由 (N-1) 层到 (N) 层的卷积步长，kernel表示卷积核大小。</p> 
  <p><strong>注意</strong>：卷积神经网络的第一个卷积层的 RF 就是卷积核大小，因为它的一个像素点，代表了上一层的 kernel 个像素点的特征，这就是RF 的含义。</p> 
  <p><strong>3. 举例</strong></p> 
  <p>举一个例子，原始图像为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mn>
          5
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          5
         </mn>
        </mrow>
        <annotation encoding="application/x-tex">
         5 \times 5
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span></span></span></span></span>，卷积核（Kernel Size）为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mn>
          3
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          3
         </mn>
        </mrow>
        <annotation encoding="application/x-tex">
         3 \times 3
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span></span></span></span></span> ，padding 为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mn>
          1
         </mn>
         <mtext>
          &nbsp;
         </mtext>
         <mi>
          t
         </mi>
         <mi>
          i
         </mi>
         <mi>
          m
         </mi>
         <mi>
          e
         </mi>
         <mi>
          s
         </mi>
         <mn>
          1
         </mn>
        </mrow>
        <annotation encoding="application/x-tex">
         1 \ times 1
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mspace">&nbsp;</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord">1</span></span></span></span></span>，stride为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mn>
          2
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          2
         </mn>
        </mrow>
        <annotation encoding="application/x-tex">
         2 \times 2
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span>，依照此卷积规则，连续做两次卷积，则第一次卷积结果是 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mn>
          3
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          3
         </mn>
        </mrow>
        <annotation encoding="application/x-tex">
         3 \times 3
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span></span></span></span></span>的feature map，第二次卷积结果是 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mn>
          2
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          2
         </mn>
        </mrow>
        <annotation encoding="application/x-tex">
         2 \times 2
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span></span></span></span></span> 大小的feature map。</p> 
  <p>则第一层卷积结束后，RF 为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mn>
          3
         </mn>
         <mo>
          ×
         </mo>
         <mn>
          3
         </mn>
         <mi mathvariant="normal">
          ​
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         3 \times 3​
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mord">​</span></span></span></span></span>； 第二层卷积结束后，RF 大小为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mo>
          (
         </mo>
         <mn>
          3
         </mn>
         <mo>
          −
         </mo>
         <mn>
          1
         </mn>
         <mo>
          )
         </mo>
         <mo>
          ∗
         </mo>
         <mn>
          2
         </mn>
         <mo>
          +
         </mo>
         <mn>
          3
         </mn>
         <mo>
          =
         </mo>
         <mn>
          7
         </mn>
         <mi mathvariant="normal">
          ​
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         (3-1)*2+3 = 7​
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">7</span><span class="mord">​</span></span></span></span></span></p> 
  <p><strong>4. 检验RF</strong></p> 
  <p>下面这个网站提供了 RF 的一键计算功能。</p> 
  <p><a href="http://link.zhihu.com/?target=https%3A//fomoro.com/tools/receptive-fields/%233%2C1%2C1%2CVALID%3B2%2C2%2C1%2CVALID%3B3%2C1%2C1%2CVALID%3B2%2C2%2C1%2CVALID%3B3%2C1%2C1%2CVALID%3B3%2C1%2C1%2CVALID%3B2%2C2%2C1%2CVALID" rel="nofollow">FOMORO AI</a></p> 
  <p>三个高级工程师搞的网站，可以简单的输入网络参数，就直接把你的感受野计算出来。界面如下。</p> 
  <h2><a id="IoU_Intersection_over_Union_175"></a>IoU (Intersection over Union)</h2> 
  <p>IoU 用来表征在目标检测中，预测的 bounding box 和 ground truth 的bounding box 的重合程度。</p> 
  <h1><a id="_183"></a>待学习的知识</h1> 
  <ul> 
   <li>skip connections是什么</li> 
   <li>上采样和下采样（unsample， downsample）是什么 
    <ul> 
     <li>空间池化（spatial Pooling），也称为子采样（subsampling）或下采样（downsampling），其减少了每一个特征映射的维度，但是保留了最重要的信息。</li> 
    </ul> </li> 
   <li>bounding box regression是什么</li> 
  </ul> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
