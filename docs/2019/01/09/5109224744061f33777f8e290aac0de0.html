<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>David Silver《强化学习RL》第五讲 不基于模型的控制 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="David Silver《强化学习RL》第五讲 不基于模型的控制" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="某种程度上来说，这个课程所有的内容最后都会集中于本讲内容，通过本讲的学习，我们将会学习到如何训练一个Agent，使其能够在完全未知的环境下较好地完成任务，得到尽可能多的奖励。本讲是基础理论部分的最后一讲，本讲以后的内容都是关于实际应用强化学习解决大规模问题的理论和技巧。本讲的技术核心主要基于先前一讲以及更早的一些内容，如果对先前的内容有深刻的理解，那么理解本讲内容将会比较容易。 &nbsp; 简介 Introduction 上一讲主要讲解了在模型未知的情况下如何进行预测。所谓的预测就是评估一个给定的策略，也就是确定一给定策略下的状态（或状态行为对）的价值函数。这一讲的内容主要是在模型未知的条件下如何优化价值函数，这一过程也称作模型无关的控制。 现实中有很多此类的例子，比如控制一个大厦内的多个电梯使得效率最高；控制直升机的特技飞行，机器人足球世界杯上控制机器人球员，围棋游戏等等。所有的这些问题要么我们对其模型运行机制未知，但是我们可以去经历、去试；要么是虽然问题模型是已知的，但问题的规模太大以至于计算机无法高效的计算，除非使用采样的办法。本节的内容就专注于解决这些问题。 根据优化控制过程中是否利用已有或他人的经验策略来改进我们自身的控制策略，我们可以将这种优化控制分为两类： 一类是现时策略学习（On-policy Learning），其基本思想是个体已有一个策略，并且遵循这个策略进行采样，或者说采取一系列该策略下产生的行为，根据这一系列行为得到的奖励，更新状态函数，最后根据该更新的价值函数来优化策略得到较优的策略。由于要优化的策略就是当前遵循的策略，这里姑且将其翻译为“现时策略”。 另一类是离线策略学习（Off-policy Learning）: 其基本思想是，虽然个体有一个自己的策略，但是个体并不针对这个策略进行采样，而是基于另一个策略进行采样，这另一个策略可以是先前学习到的策略，也可以是人类的策略等一些较为优化成熟的策略，通过观察基于这类策略的行为，或者说通过对这类策略进行采样，得到这类策略下的各种行为，继而得到一些奖励，然后更新价值函数，即在自己的策略形成的价值函数的基础上观察别的策略产生的行为，以此达到学习的目的。这种学习方式类似于“站在别人的肩膀上可以看得更远”。由于这些策略是已有的策略，这里姑且翻译为“离线策略”。 先从简单的“现时策略”开始讲解。 &nbsp; 现时策略蒙特卡洛控制 On-Policy Monte-Carlo Control 在本节中我们使用的主要思想仍然是动态规划的思想。先来回顾下动态规划是如何进行策略迭代的。 通用策略迭代（回顾） &nbsp; 通用策略迭代的核心是在两个交替的过程之间进行策略优化。一个过程是策略评估，另一个是改善策略。如上图的三角形区域所示，从一个策略π和一个价值函数Ｖ开始，每一次箭头向上代表着利用当前策略进行价值函数的更新，每一次箭头向下代表着根据更新的价值函数贪婪地选择新的策略，说它是贪婪的，是因为每次都采取转移到可能的、状态函数最高的新状态的行为。最终将收敛至最优策略和最优价值函数。 注意使用动态规划算法来改善策略是需要知道某一状态的所有后续状态及状态间转移概率： &nbsp; 不基于模型控制的两个条件 那么这种方法是否适用于模型未知的蒙特卡洛学习呢？答案是否定的，这其中至少存在两个问题。其一是在模型未知的条件下无法知道当前状态的所有后续状态，进而无法确定在当前状态下采取怎样的行为更合适。解决这一问题的方法是，使用状态行为对下的价值来代替状态价值&nbsp;： 这样做的目的是可以改善策略而不用知道整个模型，只需要知道在某个状态下采取什么什么样的行为价值最大即可。具体是这样：我们从一个初始的和策略开始，先根据这个策略更新每一个状态行为对的值，随后基于更新的确定改善的贪婪算法。 即使这样，至少还存在一个问题，即当我们每次都使用贪婪算法来改善策略的时候，将很有可能由于没有足够的采样经验而导致产生一个并不是最优的策略，我们需要不时的尝试一些新的行为，这就是探索（Exploration），使用一个示例来解释： 示例——贪婪行为选择 如图：在你面前有两扇门，考虑如下的行为、奖励并使用贪婪算法改善策略： &nbsp; 你打开左侧门得到即时奖励为０：； 你打开右侧门得到即时奖励１：； 在使用贪婪算法时，接下来你将会继续打开右侧的门，而不会尝试打开左侧门 你打开右侧门得到即时奖励＋３：； 你打开右侧门得到即时奖励＋2：； ... 这种情况下，打开右侧门是否就一定是最好的选择呢？答案显而易见是否定的。因此完全使用贪婪算法改善策略通常不能得到最优策略。为了解决这一问题，我们需要引入一个随机机制，以一定的概率选择当前最好的策略，同时给以其它可能的行为一定的几率，这就是Ɛ-贪婪探索。 &nbsp; Ɛ-贪婪探索 Ɛ-贪婪探索的目标使得某一状态下所有可能的行为都有一定非零几率被选中执行，也就保证了持续的探索，的概率下选择当前认为最好的行为，而的概率在所有可能的行为中选择（也包括那个当前最好的行为）。数学表达式如下： &nbsp; 定理：使用Ɛ-贪婪探索策略，对于任意一个给定的策略，我们在评估这个策略的同时也总在改善它。 证明： 注：在证明上述定理过程中使用的不等式是在经过合理、精心设计的。 解决了上述两个问题，我们最终看到蒙特卡洛控制的全貌：使用Ｑ函数进行策略评估，使用Ɛ-贪婪探索来改善策略。该方法最终可以收敛至最优策略。如下图所示： 图中每一个向上或向下的箭头都对应着多个Episode。也就是说我们一般在经历了多个Episode之后才进行依次Ｑ函数更新或策略改善。实际上我们也可以在每经历一个Episode之后就更新Ｑ函数或改善策略。但不管使用那种方式，在Ɛ-贪婪探索算下我们始终只能得到基于某一策略下的近似Ｑ函数，且该算法没有一个终止条件，因为它一直在进行探索。因此我们必须关注以下两个方面：一方面我们不想丢掉任何更好信息和状态，另一方面随着我们策略的改善我们最终希望能终止于某一个最优策略，因为事实上最优策略不应该包括一些随机行为选择。为此引入了另一个理论概念：GLIE。 &nbsp; GLIE GLIE(Greedy in the Limit with Infinite Exploration)，直白的说是在有限的时间内进行无限可能的探索。具体表现为：所有已经经历的状态行为对（state-action pair）会被无限次探索；另外随着探索的无限延伸，贪婪算法中Ɛ值趋向于０。例如如果我们取（为探索的Episode数目），那么该Ɛ贪婪蒙特卡洛控制就具备GLIE特性。 基于GLIE的蒙特卡洛控制流程如下： 对于给定策略，采样第个Episode: {} ～&nbsp; 对于该Episode里出现的每一个状态行为对和,更其计数和Ｑ函数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.基于新的Ｑ函数改善以如下方式改善策略：&nbsp; 定理：GLIE蒙特卡洛控制能收敛至最优的状态行为价值函数。 &nbsp; 示例——二十一点游戏的最优策略 该图最终给出了二十一点比赛时的最优策略，但借用David的话，本文对于使用该策略进行赌博导致的输赢不负任何责任。 最优策略是这样：当你手上有可用Ａ时，大多数情况下当你的牌面和达到17或18时停止要牌，如果庄家可见的牌面在2-9之间，你选择17，其它条件选择18；当你手上没有Ａ时，最优策略提示大多数情况下牌面和达到16就要停止叫牌，当庄家可见的牌面在2-7时，这一数字更小至13甚至12。这种极端情况下，宁愿停止叫牌等待让庄家的牌爆掉。 &nbsp; 现时策略时序差分控制 On-Policy Temporal-Difference Control &nbsp; 上一讲提到TD相比MC有很多优点：低变异性，可以在线实时学习，可以学习不完整Episode等。因此很自然想到是否可以在控制问题上使用TD学习而不是MC学习？答案是肯定的，这就是下文要讲解的SARSA。 SARSA 的名称来源于下图所示的序列描述：针对一个状态，以及一个特定的行为，进而产生一个状态行为对()，与环境交互，环境收到个体的行为后会告诉个体即时奖励以及后续进入的状态；接下来个体遵循现有策略产生一个行为，根据当前的状态行为价值函数得到后一个状态行为对()的价值（），利用这个值更新前一个状态行为对()的价值。 更直观的解释是这样：一个Agent处在某一个状态，在这个状态下它可尝试各种不同的行为，当遵循某一策略时，会根据当前策略选择一个行为，个体实际执行这个行为，与环境发生实际交互，环境会根据其行为给出即时奖励，并且进入下一个状态，在这个后续状态，再次遵循当前策略，产生一个行为，此时，个体并不执行该行为，而是通过自身当前的状态行为价值函数得到该状态行为对的价值，利用该价值同时结合个体状态下采取行为所获得的即时奖励来更新个体在状态下采取行为的（状态）行为价值。 与蒙特卡洛控制不同的时，每一个时间步，也就是在单个Episode内每一次个体在状态采取一个行为后都要更新值，同样使用贪婪探索的形式来改善策略。 现时策略控制的SARSA算法 注： 算法中的是以一张大表存储的，这不适用于解决规模很大的问题； 对于每一个Episode，在状态时采用的行为是基于当前策略的，同时该行为也是实际Episode发生的行为，在更新状态行为对的价值循环里，个体并不实际执行在下的行为，而是将行为留到下一个循环执行。 &nbsp; 定理：满足如下两个条件时，Sarsa算法将收敛至最优行为价值函数。 条件一：任何时候的策略符合GLIE特性; 条件二：步长系数满足： &nbsp;且&nbsp; &nbsp; 示例——有风格子世界 已知：如图所示，环境是一个10*7的长方形格子世界，同时有一个起始位置S和一个终止目标位置G，水平下方的数字表示对应的列中有一定强度的风，当该数字是1时，个体进入该列的某个格子时，会按图中箭头所示的方向自动移动一格，当数字为2时，表示顺风移动2格，以此类推模拟风的作用。任何试图离开格子世界的行为都会使得个体停留在移动前的位置。对于个体来说，它不清楚整个格子世界的构造，即它不知道格子是长方形的，也不知道边界在哪里。也不清楚起始位置、终止目标位置的具体为止。对于它来说，每一个格子就相当于一个封闭的房间，在没推开门离开当前房间之前它无法知道会进入哪个房间。个体具备记住曾经去过的格子的能力。格子可以执行的行为是朝上、下、左、右移动一步。 &nbsp; 问题：个体如何才能找到最短从起始格子S到终止目标格子G的最短路线？ 解答：首先将这个问题用强化学习常用的语言重新描述下。这是一个不基于模型的控制问题，即个体在不清楚模型机制条件下试图寻找最优策略的问题。在这个问题中，环境信息包括格子世界的形状是10*7的长方形；起始和终止格子的位置，可以用二维或一维的坐标描述，同时还包括个体在任何时候所在的格子位置。风的设置是环境动力学的一部分，它与长方形的边界共同及个体的行为共同决定了个体下一步的状态。个体从环境观测不到自身位置、起始位置以及终止位置信息的坐标描述，个体在与环境进行交互的过程中学习到自身及其它格子的位置关系。个体的行为空间是离散的四个方向。可以设置个体每行走一步获得即时奖励为-1，直到到达终止目标位置的即时奖励为0，借此希望找到最优策略。衰减系数λ可设为1。 其最优路线如下图所示： &nbsp; 个体通过学习发现下面的行为序列（共15步）能够得到最大程度的奖励: -14 在个体找到这个最优行为序列的早期，由于个体对环境一无所知，SARSA算法需要尝试许多不同的行为，因此在一开始的2000多步里，个体只能完成少数几个完整的Episode，但随着个体找到一条链接起点到终点的路径，其快速优化策略的能力就显现的很明显了，因为它不需要走完一个Episode才能更新行为价值，而是每走一步就根据下一个状态能够得到的最好价值来更新当前状态的价值。 在实践环节，我们使用Python编写具体的SARSA代码。读者可以根据这些代码深入理解SARSA的核心思想。 &nbsp; n-步SARSA 在之前，我们学习了n-步收获，还记得定义吗？，这里类似的引出一个n-步Sarsa的概念。观察下面一些列的式子： 这里的对应的是一个状态行为对，表示的是在某个状态下采取某个行为的价值大小。如果，则表示状态行为对的Q价值可以用两部分表示，一部分是离开状态st得到的即时奖励，即时奖励只与状态有关，与该状态下采取的行为无关；另一部分是新状态行为对的价值：环境给了个体一个新状态，观察在状态时基于当前策略得到的行为时的，后续的Q价值考虑衰减系数。当时，就向前用2步的即时奖励，然后再用新状态的价值代替；如果，则表示一直用即时奖励计算值，直至Episode结束，个体进入终止状态，获得终止状态的即时奖励。 定义n-步Q收获（Q-return）： 体会：个人感觉这个定义公式里没有体现出状态行为对的概念，理解起来容易与之前的n-步G收获混淆，其实Q本身是包含行为的，也就是在当前策略下基于某一个状态产生的行为。Q收获与G收获是有一定关系的，这可以结合第二章的Bellman方程来理解，这里不再赘述。 有了如上定义，可以把n-步Sarsa用n-步Q收获来表示，如下式： 假如我们给n-步Q收获的每一个收获分配一个权重，如下图引入参数λ分配权重，并按权重对每一步Q收获求和，那么将得到收获，它结合了所有n-步Q收获： Sarsa(λ)前向认识： 如果用某一状态的收获来更新状态行为对的Q值，那么可以表示称如下的形式： 这就是前向认识Sarsa(λ)，使用它更新Q价值需要遍历完整的Episode，我们同样可以反向理解Sarsa(λ). &nbsp; Sarsa(λ)反向认识： 与上一讲对于TD(λ)的反向认识一样，引入效用追踪（Eligibility Trace）概念，不同的是这次的E值针对的不是一个状态，而是一个状态行为对： &nbsp; 它体现的是一个结果与某一个状态行为对的因果关系，与得到结果最近的状态行为对，以及那些在此之前频繁发生的状态行为对对得到这个结果的影响最大。 下式是引入ET概念的之后的Q值更新描述： &nbsp; 引入ET概念，同时使用将可以更有效的在线学习，因为不必要学习完整的Episode，数据用完即可丢弃。ET通常也是更多应用在在线学习算法中(online algorithm)。 具体的算法如下： 这里要提及一下的是E(s,a)在每浏览完一个Episode后需要重新置0，这体现了ET仅在一个Episode中发挥作用；其次要提及的是算法更新Q和E的时候针对的不是某个Episode里的或，而是针对个体掌握的整个状态空间和行为空间产生的Q和E。算法为什么这么做，留给读者思考。 在实践环节，我们同样实现了该算法。 实际如果是基于查表的方式实现该算法，其速度明显比Sarsa要慢。毕竟带的算法主要应用于在线更新。 下图则用了格子世界的例子具体解释了Sarsa和Sarsa(λ)算法区别：假定最左侧图描述的路线是个体采取两种算法中的一个得到的一个完整Episode的路径。为了下文更方便描述、解释两个算法之间的区别，先做几个合理的小约定： 1）认定每一步的即时奖励为0，直到终点处即时奖励为1； 2）根据算法，除了终点以外的任何状态行为对的Q值可以是任意的，但我们设定所有的Q值均为0； 3)&nbsp; &nbsp;该路线是第一次找到终点的路线。 &nbsp; &nbsp; Sarsa(0)算法： 由于是现时策略学习，一开始个体对环境一无所知，即值均为0，它将随机选取移步行为。在到达终点前的每一个位置，个体依据当前策略，产生一个移步行为，执行该行为，环境会将其放置到一个新位置，同时给以即时奖励0，在新的位置上，根据当前的策略它会产生新位置下的一个行为，个体不执行该行为，仅仅在表中查找新状态下新行为的值，由于，依据更新公式，它将把刚才离开的位置以及对应的行为的状态行为对价值更新为0。如此直到个体最到达终点位置，它获得一个即时奖励1，此时个体会依据公式更新其到达终点位置前所在那个位置（暂用表示，也就是图中终点位置下方，向上的箭头所在的位置）时采取向上移步的那个状态行为对价值值，它将不再是0，这是个体在这个Episode中唯一一次用非0数值来更新Q值。这样完成一个Episode，此时个体已经并只进行了一次有意义的行为价值函数的更新；同时依据新的价值函数产生了新的策略。这个策略绝大多数与之前的相同，只是当个体处在某一个特殊位置时将会有一个确定的行为：直接向上移步，这个位置就是与终点相邻的下方的格子。这里请不要误认为Sarsa算法只在经历一个完整的Episode之后才更新，在这个例子中，由于我们的设定，它每走一步都会更新，只是多数时候更新的数据和原来一样罢了。 此时如果要求个体继续学习，则环境将其放入起点。个体的第二次寻路过程一开始与首次一样都是盲目随机的，直到其进入终点位置下方的位置，在这个位置，个体更新的策略要求其选择向上的行为直接进入终点位置。 同样，经过第二次的寻路，个体了解到到达终点下方的位置价值比较大，因为在这个位置直接采取向上移步的行为就可以拿到到达终点的即时奖励。因此它会将其通过移动一步可以到达的其它位置以及相应的到达&nbsp;&nbsp;位置索要采取的行为这一状态行为对的价值提升。如此反复，如果采用greedy策略更新，个体最终将得到一条到达终点的路径，不过这条路径的倒数第二步永远是在终点位置的下方。如果采用Ɛ-greedy策略更新，那么个体还会尝试到终点位置的左上右等其它方向的相邻位置价值也比较大，此时个体每次完成的路径可能都不一样。通过重复多次搜索，这种Q值的实质性的更新将覆盖越来越多的状态行为对，个体在早期采取的随机行为的步数将越来越少，直至最终实质性的更新覆盖到起始位置。此时个体将能直接给出一条确定的从起点到终点的路径。 &nbsp; Sarsa(λ)算法： 该算法同时还针对每一次Episode维护一个关于状态行为对的表，初始时E表值均为0。当个体首次在起点决定移动一步（向右）时，它被环境告知新位置为，此时发生如下事情：首先个体会做一个标记，使的值增加1，表明个体刚刚经历过这个事件；其次它要估计这个事件的对于解决整个问题的价值，也就是估计TD误差，此时依据公式结果为0，说明个体认为在起点处向右走没什么价值，这个“没有什么价值”有两层含义：不仅说明在&nbsp;处往右目前对解决问题没有积极帮助，同时表明个体认为所有能够到达&nbsp;状态的状态行为对的价值没有任何积极或消极的变化。随后个体将要更新该Episode中所有已经经历的值，由于存在E值，那些在之前近期发生或频繁发生的的Q值将改变得比其他Q值明显些，此外个体还要更新其值，以备下次使用。对于刚从起点出发的个体，这次更新没有使得任何值发生变化，仅仅在处有了一个实质的变化。随后的过程类似，个体有意义的发现就是对路径有一个记忆，体现在里，具体的值没发生变化。这一情况直到个体到达终点位置时发生改变。此时个体得到了一个即时奖励1，它会发现这一次变化（从采取向上行为到达）价值明显，它会计算这个TD误差为1，同时告诉整个经历过程中所有，根据其与的密切关系更新这些状态行为对的价值（上图右所示），个体在这个Episode中经历的所有状态行为对的Q值都将得到一个非0的更新，但是那些在个体到达之前就近发生以及频繁发生的状态行为对的价值提升得更加明显。 在图示的例子中没有显示某一状态行为频发的情况，如果个体在寻路的过程中绕过一些弯，多次到达同一个位置，并在该位置采取的相同的动作，最终个体到达终止状态时，就产生了多次发生的，这时的的价值也会得到提升。也就是说，个体每得到一个即时奖励，同时会对所有历史事件的价值进行依次更新，当然那些与该事件关系紧密的事件价值改变的较为明显。这里的事件指的就是状态行为对。在同一状态采取不同行为是不同的事件。 当个体重新从起点第二次出发时，它会发现起点处向右走的价值不再是0。如果采用greedy策略更新，个体将根据上次经验得到的新策略直接选择右走，并且一直按照原路找到终点。如果采用Ɛ-greedy策略更新，那么个体还会尝试新的路线。 由于为了解释方便，做了一些约定，这会导致问题并不要求个体找到最短一条路径，如果需要找最短路径，需要在每一次状态转移时给个体一个负的奖励。 &nbsp; 离线策略学习 Off-Policy Learning 现时策略学习的特点就是当前遵循的策略就是个体学习改善的策略。离线策略学习（Off-Policy Learning）则指的是在遵循一个策略的同时评估另一个策略，也就是计算确定这另一个策略下的状态价值函数或状态行为价值函数。为什么要这么做呢？因为这样可以较容易的从人类经验或其他个体的经验中学习，也可以从一些旧的策略中学习，可以比较两个策略的优劣。其中可能也是最主要的原因就是遵循一个探索式策略的基础上优化现有的策略。同样根据是否经历完整的Episode可以将其分为基于蒙特卡洛的和基于TD的。基于蒙特卡洛的离线策略学习仅有理论上的研究价值，在实际中毫无用处。在解释这一结论时引入了“重要性采样（importance sampling）”这个概念，这里就不详述了，有兴趣的读者可以参考原讲义。这里主要讲解常用的TD下的离线策略学习。 &nbsp; 离线策略TD学习 离线策略TD学习的任务就是使用TD方法在遵循一个策略的同时评估另一个策略。具体数学表示为： 这个公式可以这样解释：个体处在状态中，基于策略产生了一个行为，执行该行为后进入新的状态，那么在当前策略下如何根据新状态的价值调整原来状态的价值呢？离线策略的方法就是，在状态时比较分别依据另一个策略和当前遵循的策略产生行为的概率大小，如果策略得到的概率值与遵循当前策略得到的概率值接近，说明根据状态价值来更新的价值同时得到两个策略的支持，这一更新操作比较有说服力。同时也说明在状态时，两个策略有接近的概率选择行为。假如这一概率比值很小，则表明如果依照被评估的策略，选择的机会很小，这时候我们在更新价值的时候就不能过多的考虑基于当前策略得到的状态的价值。同样概率比值大于1时的道理也类似。这就相当于借鉴被评估策略的经验来更新我们自己的策略。 应用这种思想最好的方法是基于TD(0)的Q-学习（Q-learning）。它的要点在于，更新一个状态行为对的Q价值时，采用的不是当前遵循策略的下一个状态行为对的Q价值，而是采用的待评估策略产生的下一个状态行为对的Q价值。公式如下： 式中，红色部分的TD目标是基于另一个估策略产生的行为得到的价值。Q学习最主要的表现形式是：个体遵循的策略是基于当前状态行为价值函数的一个策略，而目标策略是基于当前状态行为价值函数不包含的单纯策略： 注：原讲义中的w.r.t是 with respect to的缩写，表示”在...基础上“。 这样Q学习的TD目标值可以被大幅简化： 这样在状态&nbsp;&nbsp;依据Ɛ-greedy遵循策略得到的行为的价值将朝着状态所具有的最大价值的方向做一定比例的更新。这种算法能够使策略最终收敛到最佳策略。由于个体实际与环境交互的时候遵循的是策略，它能保证经历足够丰富的新状态。 定理：Q学习控制将收敛至最优状态行为价值函数：。 下图是Q学习具体的更新公式和图解： 下图是Q学习的算法流程： &nbsp; 示例——悬崖行走 因为时间关系这个例子视频里没有讲解，这个例子也比较简单，可以用格子世界来模拟，图中悬崖用灰色的长方形表示，在其两端一个是起点，一个是目标终点。途中从悬崖指向起点的箭头提示悬崖同时也是终止状态。可以看出最优路线是贴着悬崖上方行走。 个人体会：该例体现出早期Q学习得到的策略要比SARSA要差一些，但后期最终总能找到最优策略。两者的曲线都有一定的起伏，说明两者都有一定的探索，即遵循的策略都是执行的，但Q学习在进行价值评估时采用的是而不是再是方法确定要观察的状态。 &nbsp; &nbsp; 总结DP与TD关系 下面两张图概括了各种DP算法和各种TD算法，同时也揭示了各种不同算法之间的区别和联系。总的来说TD是采样+有数据引导(bootstrap)，DP是全宽度+实际数据。如果从Bellman期望方程角度看：聚焦于状态本身价值的是迭代法策略评估（DP）和TD学习，聚焦于状态行为对价值函数的则是Q-策略迭代（DP）和SARSA；如果从针对状态行为价值函数的Bellman优化方程角度看，则是Q-价值迭代（DP）和Q学习。 &nbsp; &nbsp; 注： &nbsp; 至此，David Silver强化学习公开课的第一部分就讲完了，第二部分将聚焦于各种价值函数、策略函数的近似表示；个体如何通过训练得到一个模型，并结合模型进行强化学习；如何从理论角度看平衡探索与利用这对矛盾；并最终结合经典游戏谈强化学习的实际应用。第二部分的内容虽然不像第一部分的这些内容之间联系比较紧密，但结合了不少深度学习的知识和宏观层次的模型架构，涉及到模型训练时参数的选择和调优，还是有相当难度的。在此之前读者们最好能动手实践基础部分的强化学习理论，我也将陆续贴出针对第一部分课程中提到的格子世界的代码和相关解释。敬请期待。 &nbsp; &nbsp;" />
<meta property="og:description" content="某种程度上来说，这个课程所有的内容最后都会集中于本讲内容，通过本讲的学习，我们将会学习到如何训练一个Agent，使其能够在完全未知的环境下较好地完成任务，得到尽可能多的奖励。本讲是基础理论部分的最后一讲，本讲以后的内容都是关于实际应用强化学习解决大规模问题的理论和技巧。本讲的技术核心主要基于先前一讲以及更早的一些内容，如果对先前的内容有深刻的理解，那么理解本讲内容将会比较容易。 &nbsp; 简介 Introduction 上一讲主要讲解了在模型未知的情况下如何进行预测。所谓的预测就是评估一个给定的策略，也就是确定一给定策略下的状态（或状态行为对）的价值函数。这一讲的内容主要是在模型未知的条件下如何优化价值函数，这一过程也称作模型无关的控制。 现实中有很多此类的例子，比如控制一个大厦内的多个电梯使得效率最高；控制直升机的特技飞行，机器人足球世界杯上控制机器人球员，围棋游戏等等。所有的这些问题要么我们对其模型运行机制未知，但是我们可以去经历、去试；要么是虽然问题模型是已知的，但问题的规模太大以至于计算机无法高效的计算，除非使用采样的办法。本节的内容就专注于解决这些问题。 根据优化控制过程中是否利用已有或他人的经验策略来改进我们自身的控制策略，我们可以将这种优化控制分为两类： 一类是现时策略学习（On-policy Learning），其基本思想是个体已有一个策略，并且遵循这个策略进行采样，或者说采取一系列该策略下产生的行为，根据这一系列行为得到的奖励，更新状态函数，最后根据该更新的价值函数来优化策略得到较优的策略。由于要优化的策略就是当前遵循的策略，这里姑且将其翻译为“现时策略”。 另一类是离线策略学习（Off-policy Learning）: 其基本思想是，虽然个体有一个自己的策略，但是个体并不针对这个策略进行采样，而是基于另一个策略进行采样，这另一个策略可以是先前学习到的策略，也可以是人类的策略等一些较为优化成熟的策略，通过观察基于这类策略的行为，或者说通过对这类策略进行采样，得到这类策略下的各种行为，继而得到一些奖励，然后更新价值函数，即在自己的策略形成的价值函数的基础上观察别的策略产生的行为，以此达到学习的目的。这种学习方式类似于“站在别人的肩膀上可以看得更远”。由于这些策略是已有的策略，这里姑且翻译为“离线策略”。 先从简单的“现时策略”开始讲解。 &nbsp; 现时策略蒙特卡洛控制 On-Policy Monte-Carlo Control 在本节中我们使用的主要思想仍然是动态规划的思想。先来回顾下动态规划是如何进行策略迭代的。 通用策略迭代（回顾） &nbsp; 通用策略迭代的核心是在两个交替的过程之间进行策略优化。一个过程是策略评估，另一个是改善策略。如上图的三角形区域所示，从一个策略π和一个价值函数Ｖ开始，每一次箭头向上代表着利用当前策略进行价值函数的更新，每一次箭头向下代表着根据更新的价值函数贪婪地选择新的策略，说它是贪婪的，是因为每次都采取转移到可能的、状态函数最高的新状态的行为。最终将收敛至最优策略和最优价值函数。 注意使用动态规划算法来改善策略是需要知道某一状态的所有后续状态及状态间转移概率： &nbsp; 不基于模型控制的两个条件 那么这种方法是否适用于模型未知的蒙特卡洛学习呢？答案是否定的，这其中至少存在两个问题。其一是在模型未知的条件下无法知道当前状态的所有后续状态，进而无法确定在当前状态下采取怎样的行为更合适。解决这一问题的方法是，使用状态行为对下的价值来代替状态价值&nbsp;： 这样做的目的是可以改善策略而不用知道整个模型，只需要知道在某个状态下采取什么什么样的行为价值最大即可。具体是这样：我们从一个初始的和策略开始，先根据这个策略更新每一个状态行为对的值，随后基于更新的确定改善的贪婪算法。 即使这样，至少还存在一个问题，即当我们每次都使用贪婪算法来改善策略的时候，将很有可能由于没有足够的采样经验而导致产生一个并不是最优的策略，我们需要不时的尝试一些新的行为，这就是探索（Exploration），使用一个示例来解释： 示例——贪婪行为选择 如图：在你面前有两扇门，考虑如下的行为、奖励并使用贪婪算法改善策略： &nbsp; 你打开左侧门得到即时奖励为０：； 你打开右侧门得到即时奖励１：； 在使用贪婪算法时，接下来你将会继续打开右侧的门，而不会尝试打开左侧门 你打开右侧门得到即时奖励＋３：； 你打开右侧门得到即时奖励＋2：； ... 这种情况下，打开右侧门是否就一定是最好的选择呢？答案显而易见是否定的。因此完全使用贪婪算法改善策略通常不能得到最优策略。为了解决这一问题，我们需要引入一个随机机制，以一定的概率选择当前最好的策略，同时给以其它可能的行为一定的几率，这就是Ɛ-贪婪探索。 &nbsp; Ɛ-贪婪探索 Ɛ-贪婪探索的目标使得某一状态下所有可能的行为都有一定非零几率被选中执行，也就保证了持续的探索，的概率下选择当前认为最好的行为，而的概率在所有可能的行为中选择（也包括那个当前最好的行为）。数学表达式如下： &nbsp; 定理：使用Ɛ-贪婪探索策略，对于任意一个给定的策略，我们在评估这个策略的同时也总在改善它。 证明： 注：在证明上述定理过程中使用的不等式是在经过合理、精心设计的。 解决了上述两个问题，我们最终看到蒙特卡洛控制的全貌：使用Ｑ函数进行策略评估，使用Ɛ-贪婪探索来改善策略。该方法最终可以收敛至最优策略。如下图所示： 图中每一个向上或向下的箭头都对应着多个Episode。也就是说我们一般在经历了多个Episode之后才进行依次Ｑ函数更新或策略改善。实际上我们也可以在每经历一个Episode之后就更新Ｑ函数或改善策略。但不管使用那种方式，在Ɛ-贪婪探索算下我们始终只能得到基于某一策略下的近似Ｑ函数，且该算法没有一个终止条件，因为它一直在进行探索。因此我们必须关注以下两个方面：一方面我们不想丢掉任何更好信息和状态，另一方面随着我们策略的改善我们最终希望能终止于某一个最优策略，因为事实上最优策略不应该包括一些随机行为选择。为此引入了另一个理论概念：GLIE。 &nbsp; GLIE GLIE(Greedy in the Limit with Infinite Exploration)，直白的说是在有限的时间内进行无限可能的探索。具体表现为：所有已经经历的状态行为对（state-action pair）会被无限次探索；另外随着探索的无限延伸，贪婪算法中Ɛ值趋向于０。例如如果我们取（为探索的Episode数目），那么该Ɛ贪婪蒙特卡洛控制就具备GLIE特性。 基于GLIE的蒙特卡洛控制流程如下： 对于给定策略，采样第个Episode: {} ～&nbsp; 对于该Episode里出现的每一个状态行为对和,更其计数和Ｑ函数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.基于新的Ｑ函数改善以如下方式改善策略：&nbsp; 定理：GLIE蒙特卡洛控制能收敛至最优的状态行为价值函数。 &nbsp; 示例——二十一点游戏的最优策略 该图最终给出了二十一点比赛时的最优策略，但借用David的话，本文对于使用该策略进行赌博导致的输赢不负任何责任。 最优策略是这样：当你手上有可用Ａ时，大多数情况下当你的牌面和达到17或18时停止要牌，如果庄家可见的牌面在2-9之间，你选择17，其它条件选择18；当你手上没有Ａ时，最优策略提示大多数情况下牌面和达到16就要停止叫牌，当庄家可见的牌面在2-7时，这一数字更小至13甚至12。这种极端情况下，宁愿停止叫牌等待让庄家的牌爆掉。 &nbsp; 现时策略时序差分控制 On-Policy Temporal-Difference Control &nbsp; 上一讲提到TD相比MC有很多优点：低变异性，可以在线实时学习，可以学习不完整Episode等。因此很自然想到是否可以在控制问题上使用TD学习而不是MC学习？答案是肯定的，这就是下文要讲解的SARSA。 SARSA 的名称来源于下图所示的序列描述：针对一个状态，以及一个特定的行为，进而产生一个状态行为对()，与环境交互，环境收到个体的行为后会告诉个体即时奖励以及后续进入的状态；接下来个体遵循现有策略产生一个行为，根据当前的状态行为价值函数得到后一个状态行为对()的价值（），利用这个值更新前一个状态行为对()的价值。 更直观的解释是这样：一个Agent处在某一个状态，在这个状态下它可尝试各种不同的行为，当遵循某一策略时，会根据当前策略选择一个行为，个体实际执行这个行为，与环境发生实际交互，环境会根据其行为给出即时奖励，并且进入下一个状态，在这个后续状态，再次遵循当前策略，产生一个行为，此时，个体并不执行该行为，而是通过自身当前的状态行为价值函数得到该状态行为对的价值，利用该价值同时结合个体状态下采取行为所获得的即时奖励来更新个体在状态下采取行为的（状态）行为价值。 与蒙特卡洛控制不同的时，每一个时间步，也就是在单个Episode内每一次个体在状态采取一个行为后都要更新值，同样使用贪婪探索的形式来改善策略。 现时策略控制的SARSA算法 注： 算法中的是以一张大表存储的，这不适用于解决规模很大的问题； 对于每一个Episode，在状态时采用的行为是基于当前策略的，同时该行为也是实际Episode发生的行为，在更新状态行为对的价值循环里，个体并不实际执行在下的行为，而是将行为留到下一个循环执行。 &nbsp; 定理：满足如下两个条件时，Sarsa算法将收敛至最优行为价值函数。 条件一：任何时候的策略符合GLIE特性; 条件二：步长系数满足： &nbsp;且&nbsp; &nbsp; 示例——有风格子世界 已知：如图所示，环境是一个10*7的长方形格子世界，同时有一个起始位置S和一个终止目标位置G，水平下方的数字表示对应的列中有一定强度的风，当该数字是1时，个体进入该列的某个格子时，会按图中箭头所示的方向自动移动一格，当数字为2时，表示顺风移动2格，以此类推模拟风的作用。任何试图离开格子世界的行为都会使得个体停留在移动前的位置。对于个体来说，它不清楚整个格子世界的构造，即它不知道格子是长方形的，也不知道边界在哪里。也不清楚起始位置、终止目标位置的具体为止。对于它来说，每一个格子就相当于一个封闭的房间，在没推开门离开当前房间之前它无法知道会进入哪个房间。个体具备记住曾经去过的格子的能力。格子可以执行的行为是朝上、下、左、右移动一步。 &nbsp; 问题：个体如何才能找到最短从起始格子S到终止目标格子G的最短路线？ 解答：首先将这个问题用强化学习常用的语言重新描述下。这是一个不基于模型的控制问题，即个体在不清楚模型机制条件下试图寻找最优策略的问题。在这个问题中，环境信息包括格子世界的形状是10*7的长方形；起始和终止格子的位置，可以用二维或一维的坐标描述，同时还包括个体在任何时候所在的格子位置。风的设置是环境动力学的一部分，它与长方形的边界共同及个体的行为共同决定了个体下一步的状态。个体从环境观测不到自身位置、起始位置以及终止位置信息的坐标描述，个体在与环境进行交互的过程中学习到自身及其它格子的位置关系。个体的行为空间是离散的四个方向。可以设置个体每行走一步获得即时奖励为-1，直到到达终止目标位置的即时奖励为0，借此希望找到最优策略。衰减系数λ可设为1。 其最优路线如下图所示： &nbsp; 个体通过学习发现下面的行为序列（共15步）能够得到最大程度的奖励: -14 在个体找到这个最优行为序列的早期，由于个体对环境一无所知，SARSA算法需要尝试许多不同的行为，因此在一开始的2000多步里，个体只能完成少数几个完整的Episode，但随着个体找到一条链接起点到终点的路径，其快速优化策略的能力就显现的很明显了，因为它不需要走完一个Episode才能更新行为价值，而是每走一步就根据下一个状态能够得到的最好价值来更新当前状态的价值。 在实践环节，我们使用Python编写具体的SARSA代码。读者可以根据这些代码深入理解SARSA的核心思想。 &nbsp; n-步SARSA 在之前，我们学习了n-步收获，还记得定义吗？，这里类似的引出一个n-步Sarsa的概念。观察下面一些列的式子： 这里的对应的是一个状态行为对，表示的是在某个状态下采取某个行为的价值大小。如果，则表示状态行为对的Q价值可以用两部分表示，一部分是离开状态st得到的即时奖励，即时奖励只与状态有关，与该状态下采取的行为无关；另一部分是新状态行为对的价值：环境给了个体一个新状态，观察在状态时基于当前策略得到的行为时的，后续的Q价值考虑衰减系数。当时，就向前用2步的即时奖励，然后再用新状态的价值代替；如果，则表示一直用即时奖励计算值，直至Episode结束，个体进入终止状态，获得终止状态的即时奖励。 定义n-步Q收获（Q-return）： 体会：个人感觉这个定义公式里没有体现出状态行为对的概念，理解起来容易与之前的n-步G收获混淆，其实Q本身是包含行为的，也就是在当前策略下基于某一个状态产生的行为。Q收获与G收获是有一定关系的，这可以结合第二章的Bellman方程来理解，这里不再赘述。 有了如上定义，可以把n-步Sarsa用n-步Q收获来表示，如下式： 假如我们给n-步Q收获的每一个收获分配一个权重，如下图引入参数λ分配权重，并按权重对每一步Q收获求和，那么将得到收获，它结合了所有n-步Q收获： Sarsa(λ)前向认识： 如果用某一状态的收获来更新状态行为对的Q值，那么可以表示称如下的形式： 这就是前向认识Sarsa(λ)，使用它更新Q价值需要遍历完整的Episode，我们同样可以反向理解Sarsa(λ). &nbsp; Sarsa(λ)反向认识： 与上一讲对于TD(λ)的反向认识一样，引入效用追踪（Eligibility Trace）概念，不同的是这次的E值针对的不是一个状态，而是一个状态行为对： &nbsp; 它体现的是一个结果与某一个状态行为对的因果关系，与得到结果最近的状态行为对，以及那些在此之前频繁发生的状态行为对对得到这个结果的影响最大。 下式是引入ET概念的之后的Q值更新描述： &nbsp; 引入ET概念，同时使用将可以更有效的在线学习，因为不必要学习完整的Episode，数据用完即可丢弃。ET通常也是更多应用在在线学习算法中(online algorithm)。 具体的算法如下： 这里要提及一下的是E(s,a)在每浏览完一个Episode后需要重新置0，这体现了ET仅在一个Episode中发挥作用；其次要提及的是算法更新Q和E的时候针对的不是某个Episode里的或，而是针对个体掌握的整个状态空间和行为空间产生的Q和E。算法为什么这么做，留给读者思考。 在实践环节，我们同样实现了该算法。 实际如果是基于查表的方式实现该算法，其速度明显比Sarsa要慢。毕竟带的算法主要应用于在线更新。 下图则用了格子世界的例子具体解释了Sarsa和Sarsa(λ)算法区别：假定最左侧图描述的路线是个体采取两种算法中的一个得到的一个完整Episode的路径。为了下文更方便描述、解释两个算法之间的区别，先做几个合理的小约定： 1）认定每一步的即时奖励为0，直到终点处即时奖励为1； 2）根据算法，除了终点以外的任何状态行为对的Q值可以是任意的，但我们设定所有的Q值均为0； 3)&nbsp; &nbsp;该路线是第一次找到终点的路线。 &nbsp; &nbsp; Sarsa(0)算法： 由于是现时策略学习，一开始个体对环境一无所知，即值均为0，它将随机选取移步行为。在到达终点前的每一个位置，个体依据当前策略，产生一个移步行为，执行该行为，环境会将其放置到一个新位置，同时给以即时奖励0，在新的位置上，根据当前的策略它会产生新位置下的一个行为，个体不执行该行为，仅仅在表中查找新状态下新行为的值，由于，依据更新公式，它将把刚才离开的位置以及对应的行为的状态行为对价值更新为0。如此直到个体最到达终点位置，它获得一个即时奖励1，此时个体会依据公式更新其到达终点位置前所在那个位置（暂用表示，也就是图中终点位置下方，向上的箭头所在的位置）时采取向上移步的那个状态行为对价值值，它将不再是0，这是个体在这个Episode中唯一一次用非0数值来更新Q值。这样完成一个Episode，此时个体已经并只进行了一次有意义的行为价值函数的更新；同时依据新的价值函数产生了新的策略。这个策略绝大多数与之前的相同，只是当个体处在某一个特殊位置时将会有一个确定的行为：直接向上移步，这个位置就是与终点相邻的下方的格子。这里请不要误认为Sarsa算法只在经历一个完整的Episode之后才更新，在这个例子中，由于我们的设定，它每走一步都会更新，只是多数时候更新的数据和原来一样罢了。 此时如果要求个体继续学习，则环境将其放入起点。个体的第二次寻路过程一开始与首次一样都是盲目随机的，直到其进入终点位置下方的位置，在这个位置，个体更新的策略要求其选择向上的行为直接进入终点位置。 同样，经过第二次的寻路，个体了解到到达终点下方的位置价值比较大，因为在这个位置直接采取向上移步的行为就可以拿到到达终点的即时奖励。因此它会将其通过移动一步可以到达的其它位置以及相应的到达&nbsp;&nbsp;位置索要采取的行为这一状态行为对的价值提升。如此反复，如果采用greedy策略更新，个体最终将得到一条到达终点的路径，不过这条路径的倒数第二步永远是在终点位置的下方。如果采用Ɛ-greedy策略更新，那么个体还会尝试到终点位置的左上右等其它方向的相邻位置价值也比较大，此时个体每次完成的路径可能都不一样。通过重复多次搜索，这种Q值的实质性的更新将覆盖越来越多的状态行为对，个体在早期采取的随机行为的步数将越来越少，直至最终实质性的更新覆盖到起始位置。此时个体将能直接给出一条确定的从起点到终点的路径。 &nbsp; Sarsa(λ)算法： 该算法同时还针对每一次Episode维护一个关于状态行为对的表，初始时E表值均为0。当个体首次在起点决定移动一步（向右）时，它被环境告知新位置为，此时发生如下事情：首先个体会做一个标记，使的值增加1，表明个体刚刚经历过这个事件；其次它要估计这个事件的对于解决整个问题的价值，也就是估计TD误差，此时依据公式结果为0，说明个体认为在起点处向右走没什么价值，这个“没有什么价值”有两层含义：不仅说明在&nbsp;处往右目前对解决问题没有积极帮助，同时表明个体认为所有能够到达&nbsp;状态的状态行为对的价值没有任何积极或消极的变化。随后个体将要更新该Episode中所有已经经历的值，由于存在E值，那些在之前近期发生或频繁发生的的Q值将改变得比其他Q值明显些，此外个体还要更新其值，以备下次使用。对于刚从起点出发的个体，这次更新没有使得任何值发生变化，仅仅在处有了一个实质的变化。随后的过程类似，个体有意义的发现就是对路径有一个记忆，体现在里，具体的值没发生变化。这一情况直到个体到达终点位置时发生改变。此时个体得到了一个即时奖励1，它会发现这一次变化（从采取向上行为到达）价值明显，它会计算这个TD误差为1，同时告诉整个经历过程中所有，根据其与的密切关系更新这些状态行为对的价值（上图右所示），个体在这个Episode中经历的所有状态行为对的Q值都将得到一个非0的更新，但是那些在个体到达之前就近发生以及频繁发生的状态行为对的价值提升得更加明显。 在图示的例子中没有显示某一状态行为频发的情况，如果个体在寻路的过程中绕过一些弯，多次到达同一个位置，并在该位置采取的相同的动作，最终个体到达终止状态时，就产生了多次发生的，这时的的价值也会得到提升。也就是说，个体每得到一个即时奖励，同时会对所有历史事件的价值进行依次更新，当然那些与该事件关系紧密的事件价值改变的较为明显。这里的事件指的就是状态行为对。在同一状态采取不同行为是不同的事件。 当个体重新从起点第二次出发时，它会发现起点处向右走的价值不再是0。如果采用greedy策略更新，个体将根据上次经验得到的新策略直接选择右走，并且一直按照原路找到终点。如果采用Ɛ-greedy策略更新，那么个体还会尝试新的路线。 由于为了解释方便，做了一些约定，这会导致问题并不要求个体找到最短一条路径，如果需要找最短路径，需要在每一次状态转移时给个体一个负的奖励。 &nbsp; 离线策略学习 Off-Policy Learning 现时策略学习的特点就是当前遵循的策略就是个体学习改善的策略。离线策略学习（Off-Policy Learning）则指的是在遵循一个策略的同时评估另一个策略，也就是计算确定这另一个策略下的状态价值函数或状态行为价值函数。为什么要这么做呢？因为这样可以较容易的从人类经验或其他个体的经验中学习，也可以从一些旧的策略中学习，可以比较两个策略的优劣。其中可能也是最主要的原因就是遵循一个探索式策略的基础上优化现有的策略。同样根据是否经历完整的Episode可以将其分为基于蒙特卡洛的和基于TD的。基于蒙特卡洛的离线策略学习仅有理论上的研究价值，在实际中毫无用处。在解释这一结论时引入了“重要性采样（importance sampling）”这个概念，这里就不详述了，有兴趣的读者可以参考原讲义。这里主要讲解常用的TD下的离线策略学习。 &nbsp; 离线策略TD学习 离线策略TD学习的任务就是使用TD方法在遵循一个策略的同时评估另一个策略。具体数学表示为： 这个公式可以这样解释：个体处在状态中，基于策略产生了一个行为，执行该行为后进入新的状态，那么在当前策略下如何根据新状态的价值调整原来状态的价值呢？离线策略的方法就是，在状态时比较分别依据另一个策略和当前遵循的策略产生行为的概率大小，如果策略得到的概率值与遵循当前策略得到的概率值接近，说明根据状态价值来更新的价值同时得到两个策略的支持，这一更新操作比较有说服力。同时也说明在状态时，两个策略有接近的概率选择行为。假如这一概率比值很小，则表明如果依照被评估的策略，选择的机会很小，这时候我们在更新价值的时候就不能过多的考虑基于当前策略得到的状态的价值。同样概率比值大于1时的道理也类似。这就相当于借鉴被评估策略的经验来更新我们自己的策略。 应用这种思想最好的方法是基于TD(0)的Q-学习（Q-learning）。它的要点在于，更新一个状态行为对的Q价值时，采用的不是当前遵循策略的下一个状态行为对的Q价值，而是采用的待评估策略产生的下一个状态行为对的Q价值。公式如下： 式中，红色部分的TD目标是基于另一个估策略产生的行为得到的价值。Q学习最主要的表现形式是：个体遵循的策略是基于当前状态行为价值函数的一个策略，而目标策略是基于当前状态行为价值函数不包含的单纯策略： 注：原讲义中的w.r.t是 with respect to的缩写，表示”在...基础上“。 这样Q学习的TD目标值可以被大幅简化： 这样在状态&nbsp;&nbsp;依据Ɛ-greedy遵循策略得到的行为的价值将朝着状态所具有的最大价值的方向做一定比例的更新。这种算法能够使策略最终收敛到最佳策略。由于个体实际与环境交互的时候遵循的是策略，它能保证经历足够丰富的新状态。 定理：Q学习控制将收敛至最优状态行为价值函数：。 下图是Q学习具体的更新公式和图解： 下图是Q学习的算法流程： &nbsp; 示例——悬崖行走 因为时间关系这个例子视频里没有讲解，这个例子也比较简单，可以用格子世界来模拟，图中悬崖用灰色的长方形表示，在其两端一个是起点，一个是目标终点。途中从悬崖指向起点的箭头提示悬崖同时也是终止状态。可以看出最优路线是贴着悬崖上方行走。 个人体会：该例体现出早期Q学习得到的策略要比SARSA要差一些，但后期最终总能找到最优策略。两者的曲线都有一定的起伏，说明两者都有一定的探索，即遵循的策略都是执行的，但Q学习在进行价值评估时采用的是而不是再是方法确定要观察的状态。 &nbsp; &nbsp; 总结DP与TD关系 下面两张图概括了各种DP算法和各种TD算法，同时也揭示了各种不同算法之间的区别和联系。总的来说TD是采样+有数据引导(bootstrap)，DP是全宽度+实际数据。如果从Bellman期望方程角度看：聚焦于状态本身价值的是迭代法策略评估（DP）和TD学习，聚焦于状态行为对价值函数的则是Q-策略迭代（DP）和SARSA；如果从针对状态行为价值函数的Bellman优化方程角度看，则是Q-价值迭代（DP）和Q学习。 &nbsp; &nbsp; 注： &nbsp; 至此，David Silver强化学习公开课的第一部分就讲完了，第二部分将聚焦于各种价值函数、策略函数的近似表示；个体如何通过训练得到一个模型，并结合模型进行强化学习；如何从理论角度看平衡探索与利用这对矛盾；并最终结合经典游戏谈强化学习的实际应用。第二部分的内容虽然不像第一部分的这些内容之间联系比较紧密，但结合了不少深度学习的知识和宏观层次的模型架构，涉及到模型训练时参数的选择和调优，还是有相当难度的。在此之前读者们最好能动手实践基础部分的强化学习理论，我也将陆续贴出针对第一部分课程中提到的格子世界的代码和相关解释。敬请期待。 &nbsp; &nbsp;" />
<link rel="canonical" href="https://mlh.app/2019/01/09/5109224744061f33777f8e290aac0de0.html" />
<meta property="og:url" content="https://mlh.app/2019/01/09/5109224744061f33777f8e290aac0de0.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"某种程度上来说，这个课程所有的内容最后都会集中于本讲内容，通过本讲的学习，我们将会学习到如何训练一个Agent，使其能够在完全未知的环境下较好地完成任务，得到尽可能多的奖励。本讲是基础理论部分的最后一讲，本讲以后的内容都是关于实际应用强化学习解决大规模问题的理论和技巧。本讲的技术核心主要基于先前一讲以及更早的一些内容，如果对先前的内容有深刻的理解，那么理解本讲内容将会比较容易。 &nbsp; 简介 Introduction 上一讲主要讲解了在模型未知的情况下如何进行预测。所谓的预测就是评估一个给定的策略，也就是确定一给定策略下的状态（或状态行为对）的价值函数。这一讲的内容主要是在模型未知的条件下如何优化价值函数，这一过程也称作模型无关的控制。 现实中有很多此类的例子，比如控制一个大厦内的多个电梯使得效率最高；控制直升机的特技飞行，机器人足球世界杯上控制机器人球员，围棋游戏等等。所有的这些问题要么我们对其模型运行机制未知，但是我们可以去经历、去试；要么是虽然问题模型是已知的，但问题的规模太大以至于计算机无法高效的计算，除非使用采样的办法。本节的内容就专注于解决这些问题。 根据优化控制过程中是否利用已有或他人的经验策略来改进我们自身的控制策略，我们可以将这种优化控制分为两类： 一类是现时策略学习（On-policy Learning），其基本思想是个体已有一个策略，并且遵循这个策略进行采样，或者说采取一系列该策略下产生的行为，根据这一系列行为得到的奖励，更新状态函数，最后根据该更新的价值函数来优化策略得到较优的策略。由于要优化的策略就是当前遵循的策略，这里姑且将其翻译为“现时策略”。 另一类是离线策略学习（Off-policy Learning）: 其基本思想是，虽然个体有一个自己的策略，但是个体并不针对这个策略进行采样，而是基于另一个策略进行采样，这另一个策略可以是先前学习到的策略，也可以是人类的策略等一些较为优化成熟的策略，通过观察基于这类策略的行为，或者说通过对这类策略进行采样，得到这类策略下的各种行为，继而得到一些奖励，然后更新价值函数，即在自己的策略形成的价值函数的基础上观察别的策略产生的行为，以此达到学习的目的。这种学习方式类似于“站在别人的肩膀上可以看得更远”。由于这些策略是已有的策略，这里姑且翻译为“离线策略”。 先从简单的“现时策略”开始讲解。 &nbsp; 现时策略蒙特卡洛控制 On-Policy Monte-Carlo Control 在本节中我们使用的主要思想仍然是动态规划的思想。先来回顾下动态规划是如何进行策略迭代的。 通用策略迭代（回顾） &nbsp; 通用策略迭代的核心是在两个交替的过程之间进行策略优化。一个过程是策略评估，另一个是改善策略。如上图的三角形区域所示，从一个策略π和一个价值函数Ｖ开始，每一次箭头向上代表着利用当前策略进行价值函数的更新，每一次箭头向下代表着根据更新的价值函数贪婪地选择新的策略，说它是贪婪的，是因为每次都采取转移到可能的、状态函数最高的新状态的行为。最终将收敛至最优策略和最优价值函数。 注意使用动态规划算法来改善策略是需要知道某一状态的所有后续状态及状态间转移概率： &nbsp; 不基于模型控制的两个条件 那么这种方法是否适用于模型未知的蒙特卡洛学习呢？答案是否定的，这其中至少存在两个问题。其一是在模型未知的条件下无法知道当前状态的所有后续状态，进而无法确定在当前状态下采取怎样的行为更合适。解决这一问题的方法是，使用状态行为对下的价值来代替状态价值&nbsp;： 这样做的目的是可以改善策略而不用知道整个模型，只需要知道在某个状态下采取什么什么样的行为价值最大即可。具体是这样：我们从一个初始的和策略开始，先根据这个策略更新每一个状态行为对的值，随后基于更新的确定改善的贪婪算法。 即使这样，至少还存在一个问题，即当我们每次都使用贪婪算法来改善策略的时候，将很有可能由于没有足够的采样经验而导致产生一个并不是最优的策略，我们需要不时的尝试一些新的行为，这就是探索（Exploration），使用一个示例来解释： 示例——贪婪行为选择 如图：在你面前有两扇门，考虑如下的行为、奖励并使用贪婪算法改善策略： &nbsp; 你打开左侧门得到即时奖励为０：； 你打开右侧门得到即时奖励１：； 在使用贪婪算法时，接下来你将会继续打开右侧的门，而不会尝试打开左侧门 你打开右侧门得到即时奖励＋３：； 你打开右侧门得到即时奖励＋2：； ... 这种情况下，打开右侧门是否就一定是最好的选择呢？答案显而易见是否定的。因此完全使用贪婪算法改善策略通常不能得到最优策略。为了解决这一问题，我们需要引入一个随机机制，以一定的概率选择当前最好的策略，同时给以其它可能的行为一定的几率，这就是Ɛ-贪婪探索。 &nbsp; Ɛ-贪婪探索 Ɛ-贪婪探索的目标使得某一状态下所有可能的行为都有一定非零几率被选中执行，也就保证了持续的探索，的概率下选择当前认为最好的行为，而的概率在所有可能的行为中选择（也包括那个当前最好的行为）。数学表达式如下： &nbsp; 定理：使用Ɛ-贪婪探索策略，对于任意一个给定的策略，我们在评估这个策略的同时也总在改善它。 证明： 注：在证明上述定理过程中使用的不等式是在经过合理、精心设计的。 解决了上述两个问题，我们最终看到蒙特卡洛控制的全貌：使用Ｑ函数进行策略评估，使用Ɛ-贪婪探索来改善策略。该方法最终可以收敛至最优策略。如下图所示： 图中每一个向上或向下的箭头都对应着多个Episode。也就是说我们一般在经历了多个Episode之后才进行依次Ｑ函数更新或策略改善。实际上我们也可以在每经历一个Episode之后就更新Ｑ函数或改善策略。但不管使用那种方式，在Ɛ-贪婪探索算下我们始终只能得到基于某一策略下的近似Ｑ函数，且该算法没有一个终止条件，因为它一直在进行探索。因此我们必须关注以下两个方面：一方面我们不想丢掉任何更好信息和状态，另一方面随着我们策略的改善我们最终希望能终止于某一个最优策略，因为事实上最优策略不应该包括一些随机行为选择。为此引入了另一个理论概念：GLIE。 &nbsp; GLIE GLIE(Greedy in the Limit with Infinite Exploration)，直白的说是在有限的时间内进行无限可能的探索。具体表现为：所有已经经历的状态行为对（state-action pair）会被无限次探索；另外随着探索的无限延伸，贪婪算法中Ɛ值趋向于０。例如如果我们取（为探索的Episode数目），那么该Ɛ贪婪蒙特卡洛控制就具备GLIE特性。 基于GLIE的蒙特卡洛控制流程如下： 对于给定策略，采样第个Episode: {} ～&nbsp; 对于该Episode里出现的每一个状态行为对和,更其计数和Ｑ函数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.基于新的Ｑ函数改善以如下方式改善策略：&nbsp; 定理：GLIE蒙特卡洛控制能收敛至最优的状态行为价值函数。 &nbsp; 示例——二十一点游戏的最优策略 该图最终给出了二十一点比赛时的最优策略，但借用David的话，本文对于使用该策略进行赌博导致的输赢不负任何责任。 最优策略是这样：当你手上有可用Ａ时，大多数情况下当你的牌面和达到17或18时停止要牌，如果庄家可见的牌面在2-9之间，你选择17，其它条件选择18；当你手上没有Ａ时，最优策略提示大多数情况下牌面和达到16就要停止叫牌，当庄家可见的牌面在2-7时，这一数字更小至13甚至12。这种极端情况下，宁愿停止叫牌等待让庄家的牌爆掉。 &nbsp; 现时策略时序差分控制 On-Policy Temporal-Difference Control &nbsp; 上一讲提到TD相比MC有很多优点：低变异性，可以在线实时学习，可以学习不完整Episode等。因此很自然想到是否可以在控制问题上使用TD学习而不是MC学习？答案是肯定的，这就是下文要讲解的SARSA。 SARSA 的名称来源于下图所示的序列描述：针对一个状态，以及一个特定的行为，进而产生一个状态行为对()，与环境交互，环境收到个体的行为后会告诉个体即时奖励以及后续进入的状态；接下来个体遵循现有策略产生一个行为，根据当前的状态行为价值函数得到后一个状态行为对()的价值（），利用这个值更新前一个状态行为对()的价值。 更直观的解释是这样：一个Agent处在某一个状态，在这个状态下它可尝试各种不同的行为，当遵循某一策略时，会根据当前策略选择一个行为，个体实际执行这个行为，与环境发生实际交互，环境会根据其行为给出即时奖励，并且进入下一个状态，在这个后续状态，再次遵循当前策略，产生一个行为，此时，个体并不执行该行为，而是通过自身当前的状态行为价值函数得到该状态行为对的价值，利用该价值同时结合个体状态下采取行为所获得的即时奖励来更新个体在状态下采取行为的（状态）行为价值。 与蒙特卡洛控制不同的时，每一个时间步，也就是在单个Episode内每一次个体在状态采取一个行为后都要更新值，同样使用贪婪探索的形式来改善策略。 现时策略控制的SARSA算法 注： 算法中的是以一张大表存储的，这不适用于解决规模很大的问题； 对于每一个Episode，在状态时采用的行为是基于当前策略的，同时该行为也是实际Episode发生的行为，在更新状态行为对的价值循环里，个体并不实际执行在下的行为，而是将行为留到下一个循环执行。 &nbsp; 定理：满足如下两个条件时，Sarsa算法将收敛至最优行为价值函数。 条件一：任何时候的策略符合GLIE特性; 条件二：步长系数满足： &nbsp;且&nbsp; &nbsp; 示例——有风格子世界 已知：如图所示，环境是一个10*7的长方形格子世界，同时有一个起始位置S和一个终止目标位置G，水平下方的数字表示对应的列中有一定强度的风，当该数字是1时，个体进入该列的某个格子时，会按图中箭头所示的方向自动移动一格，当数字为2时，表示顺风移动2格，以此类推模拟风的作用。任何试图离开格子世界的行为都会使得个体停留在移动前的位置。对于个体来说，它不清楚整个格子世界的构造，即它不知道格子是长方形的，也不知道边界在哪里。也不清楚起始位置、终止目标位置的具体为止。对于它来说，每一个格子就相当于一个封闭的房间，在没推开门离开当前房间之前它无法知道会进入哪个房间。个体具备记住曾经去过的格子的能力。格子可以执行的行为是朝上、下、左、右移动一步。 &nbsp; 问题：个体如何才能找到最短从起始格子S到终止目标格子G的最短路线？ 解答：首先将这个问题用强化学习常用的语言重新描述下。这是一个不基于模型的控制问题，即个体在不清楚模型机制条件下试图寻找最优策略的问题。在这个问题中，环境信息包括格子世界的形状是10*7的长方形；起始和终止格子的位置，可以用二维或一维的坐标描述，同时还包括个体在任何时候所在的格子位置。风的设置是环境动力学的一部分，它与长方形的边界共同及个体的行为共同决定了个体下一步的状态。个体从环境观测不到自身位置、起始位置以及终止位置信息的坐标描述，个体在与环境进行交互的过程中学习到自身及其它格子的位置关系。个体的行为空间是离散的四个方向。可以设置个体每行走一步获得即时奖励为-1，直到到达终止目标位置的即时奖励为0，借此希望找到最优策略。衰减系数λ可设为1。 其最优路线如下图所示： &nbsp; 个体通过学习发现下面的行为序列（共15步）能够得到最大程度的奖励: -14 在个体找到这个最优行为序列的早期，由于个体对环境一无所知，SARSA算法需要尝试许多不同的行为，因此在一开始的2000多步里，个体只能完成少数几个完整的Episode，但随着个体找到一条链接起点到终点的路径，其快速优化策略的能力就显现的很明显了，因为它不需要走完一个Episode才能更新行为价值，而是每走一步就根据下一个状态能够得到的最好价值来更新当前状态的价值。 在实践环节，我们使用Python编写具体的SARSA代码。读者可以根据这些代码深入理解SARSA的核心思想。 &nbsp; n-步SARSA 在之前，我们学习了n-步收获，还记得定义吗？，这里类似的引出一个n-步Sarsa的概念。观察下面一些列的式子： 这里的对应的是一个状态行为对，表示的是在某个状态下采取某个行为的价值大小。如果，则表示状态行为对的Q价值可以用两部分表示，一部分是离开状态st得到的即时奖励，即时奖励只与状态有关，与该状态下采取的行为无关；另一部分是新状态行为对的价值：环境给了个体一个新状态，观察在状态时基于当前策略得到的行为时的，后续的Q价值考虑衰减系数。当时，就向前用2步的即时奖励，然后再用新状态的价值代替；如果，则表示一直用即时奖励计算值，直至Episode结束，个体进入终止状态，获得终止状态的即时奖励。 定义n-步Q收获（Q-return）： 体会：个人感觉这个定义公式里没有体现出状态行为对的概念，理解起来容易与之前的n-步G收获混淆，其实Q本身是包含行为的，也就是在当前策略下基于某一个状态产生的行为。Q收获与G收获是有一定关系的，这可以结合第二章的Bellman方程来理解，这里不再赘述。 有了如上定义，可以把n-步Sarsa用n-步Q收获来表示，如下式： 假如我们给n-步Q收获的每一个收获分配一个权重，如下图引入参数λ分配权重，并按权重对每一步Q收获求和，那么将得到收获，它结合了所有n-步Q收获： Sarsa(λ)前向认识： 如果用某一状态的收获来更新状态行为对的Q值，那么可以表示称如下的形式： 这就是前向认识Sarsa(λ)，使用它更新Q价值需要遍历完整的Episode，我们同样可以反向理解Sarsa(λ). &nbsp; Sarsa(λ)反向认识： 与上一讲对于TD(λ)的反向认识一样，引入效用追踪（Eligibility Trace）概念，不同的是这次的E值针对的不是一个状态，而是一个状态行为对： &nbsp; 它体现的是一个结果与某一个状态行为对的因果关系，与得到结果最近的状态行为对，以及那些在此之前频繁发生的状态行为对对得到这个结果的影响最大。 下式是引入ET概念的之后的Q值更新描述： &nbsp; 引入ET概念，同时使用将可以更有效的在线学习，因为不必要学习完整的Episode，数据用完即可丢弃。ET通常也是更多应用在在线学习算法中(online algorithm)。 具体的算法如下： 这里要提及一下的是E(s,a)在每浏览完一个Episode后需要重新置0，这体现了ET仅在一个Episode中发挥作用；其次要提及的是算法更新Q和E的时候针对的不是某个Episode里的或，而是针对个体掌握的整个状态空间和行为空间产生的Q和E。算法为什么这么做，留给读者思考。 在实践环节，我们同样实现了该算法。 实际如果是基于查表的方式实现该算法，其速度明显比Sarsa要慢。毕竟带的算法主要应用于在线更新。 下图则用了格子世界的例子具体解释了Sarsa和Sarsa(λ)算法区别：假定最左侧图描述的路线是个体采取两种算法中的一个得到的一个完整Episode的路径。为了下文更方便描述、解释两个算法之间的区别，先做几个合理的小约定： 1）认定每一步的即时奖励为0，直到终点处即时奖励为1； 2）根据算法，除了终点以外的任何状态行为对的Q值可以是任意的，但我们设定所有的Q值均为0； 3)&nbsp; &nbsp;该路线是第一次找到终点的路线。 &nbsp; &nbsp; Sarsa(0)算法： 由于是现时策略学习，一开始个体对环境一无所知，即值均为0，它将随机选取移步行为。在到达终点前的每一个位置，个体依据当前策略，产生一个移步行为，执行该行为，环境会将其放置到一个新位置，同时给以即时奖励0，在新的位置上，根据当前的策略它会产生新位置下的一个行为，个体不执行该行为，仅仅在表中查找新状态下新行为的值，由于，依据更新公式，它将把刚才离开的位置以及对应的行为的状态行为对价值更新为0。如此直到个体最到达终点位置，它获得一个即时奖励1，此时个体会依据公式更新其到达终点位置前所在那个位置（暂用表示，也就是图中终点位置下方，向上的箭头所在的位置）时采取向上移步的那个状态行为对价值值，它将不再是0，这是个体在这个Episode中唯一一次用非0数值来更新Q值。这样完成一个Episode，此时个体已经并只进行了一次有意义的行为价值函数的更新；同时依据新的价值函数产生了新的策略。这个策略绝大多数与之前的相同，只是当个体处在某一个特殊位置时将会有一个确定的行为：直接向上移步，这个位置就是与终点相邻的下方的格子。这里请不要误认为Sarsa算法只在经历一个完整的Episode之后才更新，在这个例子中，由于我们的设定，它每走一步都会更新，只是多数时候更新的数据和原来一样罢了。 此时如果要求个体继续学习，则环境将其放入起点。个体的第二次寻路过程一开始与首次一样都是盲目随机的，直到其进入终点位置下方的位置，在这个位置，个体更新的策略要求其选择向上的行为直接进入终点位置。 同样，经过第二次的寻路，个体了解到到达终点下方的位置价值比较大，因为在这个位置直接采取向上移步的行为就可以拿到到达终点的即时奖励。因此它会将其通过移动一步可以到达的其它位置以及相应的到达&nbsp;&nbsp;位置索要采取的行为这一状态行为对的价值提升。如此反复，如果采用greedy策略更新，个体最终将得到一条到达终点的路径，不过这条路径的倒数第二步永远是在终点位置的下方。如果采用Ɛ-greedy策略更新，那么个体还会尝试到终点位置的左上右等其它方向的相邻位置价值也比较大，此时个体每次完成的路径可能都不一样。通过重复多次搜索，这种Q值的实质性的更新将覆盖越来越多的状态行为对，个体在早期采取的随机行为的步数将越来越少，直至最终实质性的更新覆盖到起始位置。此时个体将能直接给出一条确定的从起点到终点的路径。 &nbsp; Sarsa(λ)算法： 该算法同时还针对每一次Episode维护一个关于状态行为对的表，初始时E表值均为0。当个体首次在起点决定移动一步（向右）时，它被环境告知新位置为，此时发生如下事情：首先个体会做一个标记，使的值增加1，表明个体刚刚经历过这个事件；其次它要估计这个事件的对于解决整个问题的价值，也就是估计TD误差，此时依据公式结果为0，说明个体认为在起点处向右走没什么价值，这个“没有什么价值”有两层含义：不仅说明在&nbsp;处往右目前对解决问题没有积极帮助，同时表明个体认为所有能够到达&nbsp;状态的状态行为对的价值没有任何积极或消极的变化。随后个体将要更新该Episode中所有已经经历的值，由于存在E值，那些在之前近期发生或频繁发生的的Q值将改变得比其他Q值明显些，此外个体还要更新其值，以备下次使用。对于刚从起点出发的个体，这次更新没有使得任何值发生变化，仅仅在处有了一个实质的变化。随后的过程类似，个体有意义的发现就是对路径有一个记忆，体现在里，具体的值没发生变化。这一情况直到个体到达终点位置时发生改变。此时个体得到了一个即时奖励1，它会发现这一次变化（从采取向上行为到达）价值明显，它会计算这个TD误差为1，同时告诉整个经历过程中所有，根据其与的密切关系更新这些状态行为对的价值（上图右所示），个体在这个Episode中经历的所有状态行为对的Q值都将得到一个非0的更新，但是那些在个体到达之前就近发生以及频繁发生的状态行为对的价值提升得更加明显。 在图示的例子中没有显示某一状态行为频发的情况，如果个体在寻路的过程中绕过一些弯，多次到达同一个位置，并在该位置采取的相同的动作，最终个体到达终止状态时，就产生了多次发生的，这时的的价值也会得到提升。也就是说，个体每得到一个即时奖励，同时会对所有历史事件的价值进行依次更新，当然那些与该事件关系紧密的事件价值改变的较为明显。这里的事件指的就是状态行为对。在同一状态采取不同行为是不同的事件。 当个体重新从起点第二次出发时，它会发现起点处向右走的价值不再是0。如果采用greedy策略更新，个体将根据上次经验得到的新策略直接选择右走，并且一直按照原路找到终点。如果采用Ɛ-greedy策略更新，那么个体还会尝试新的路线。 由于为了解释方便，做了一些约定，这会导致问题并不要求个体找到最短一条路径，如果需要找最短路径，需要在每一次状态转移时给个体一个负的奖励。 &nbsp; 离线策略学习 Off-Policy Learning 现时策略学习的特点就是当前遵循的策略就是个体学习改善的策略。离线策略学习（Off-Policy Learning）则指的是在遵循一个策略的同时评估另一个策略，也就是计算确定这另一个策略下的状态价值函数或状态行为价值函数。为什么要这么做呢？因为这样可以较容易的从人类经验或其他个体的经验中学习，也可以从一些旧的策略中学习，可以比较两个策略的优劣。其中可能也是最主要的原因就是遵循一个探索式策略的基础上优化现有的策略。同样根据是否经历完整的Episode可以将其分为基于蒙特卡洛的和基于TD的。基于蒙特卡洛的离线策略学习仅有理论上的研究价值，在实际中毫无用处。在解释这一结论时引入了“重要性采样（importance sampling）”这个概念，这里就不详述了，有兴趣的读者可以参考原讲义。这里主要讲解常用的TD下的离线策略学习。 &nbsp; 离线策略TD学习 离线策略TD学习的任务就是使用TD方法在遵循一个策略的同时评估另一个策略。具体数学表示为： 这个公式可以这样解释：个体处在状态中，基于策略产生了一个行为，执行该行为后进入新的状态，那么在当前策略下如何根据新状态的价值调整原来状态的价值呢？离线策略的方法就是，在状态时比较分别依据另一个策略和当前遵循的策略产生行为的概率大小，如果策略得到的概率值与遵循当前策略得到的概率值接近，说明根据状态价值来更新的价值同时得到两个策略的支持，这一更新操作比较有说服力。同时也说明在状态时，两个策略有接近的概率选择行为。假如这一概率比值很小，则表明如果依照被评估的策略，选择的机会很小，这时候我们在更新价值的时候就不能过多的考虑基于当前策略得到的状态的价值。同样概率比值大于1时的道理也类似。这就相当于借鉴被评估策略的经验来更新我们自己的策略。 应用这种思想最好的方法是基于TD(0)的Q-学习（Q-learning）。它的要点在于，更新一个状态行为对的Q价值时，采用的不是当前遵循策略的下一个状态行为对的Q价值，而是采用的待评估策略产生的下一个状态行为对的Q价值。公式如下： 式中，红色部分的TD目标是基于另一个估策略产生的行为得到的价值。Q学习最主要的表现形式是：个体遵循的策略是基于当前状态行为价值函数的一个策略，而目标策略是基于当前状态行为价值函数不包含的单纯策略： 注：原讲义中的w.r.t是 with respect to的缩写，表示”在...基础上“。 这样Q学习的TD目标值可以被大幅简化： 这样在状态&nbsp;&nbsp;依据Ɛ-greedy遵循策略得到的行为的价值将朝着状态所具有的最大价值的方向做一定比例的更新。这种算法能够使策略最终收敛到最佳策略。由于个体实际与环境交互的时候遵循的是策略，它能保证经历足够丰富的新状态。 定理：Q学习控制将收敛至最优状态行为价值函数：。 下图是Q学习具体的更新公式和图解： 下图是Q学习的算法流程： &nbsp; 示例——悬崖行走 因为时间关系这个例子视频里没有讲解，这个例子也比较简单，可以用格子世界来模拟，图中悬崖用灰色的长方形表示，在其两端一个是起点，一个是目标终点。途中从悬崖指向起点的箭头提示悬崖同时也是终止状态。可以看出最优路线是贴着悬崖上方行走。 个人体会：该例体现出早期Q学习得到的策略要比SARSA要差一些，但后期最终总能找到最优策略。两者的曲线都有一定的起伏，说明两者都有一定的探索，即遵循的策略都是执行的，但Q学习在进行价值评估时采用的是而不是再是方法确定要观察的状态。 &nbsp; &nbsp; 总结DP与TD关系 下面两张图概括了各种DP算法和各种TD算法，同时也揭示了各种不同算法之间的区别和联系。总的来说TD是采样+有数据引导(bootstrap)，DP是全宽度+实际数据。如果从Bellman期望方程角度看：聚焦于状态本身价值的是迭代法策略评估（DP）和TD学习，聚焦于状态行为对价值函数的则是Q-策略迭代（DP）和SARSA；如果从针对状态行为价值函数的Bellman优化方程角度看，则是Q-价值迭代（DP）和Q学习。 &nbsp; &nbsp; 注： &nbsp; 至此，David Silver强化学习公开课的第一部分就讲完了，第二部分将聚焦于各种价值函数、策略函数的近似表示；个体如何通过训练得到一个模型，并结合模型进行强化学习；如何从理论角度看平衡探索与利用这对矛盾；并最终结合经典游戏谈强化学习的实际应用。第二部分的内容虽然不像第一部分的这些内容之间联系比较紧密，但结合了不少深度学习的知识和宏观层次的模型架构，涉及到模型训练时参数的选择和调优，还是有相当难度的。在此之前读者们最好能动手实践基础部分的强化学习理论，我也将陆续贴出针对第一部分课程中提到的格子世界的代码和相关解释。敬请期待。 &nbsp; &nbsp;","@type":"BlogPosting","url":"https://mlh.app/2019/01/09/5109224744061f33777f8e290aac0de0.html","headline":"David Silver《强化学习RL》第五讲 不基于模型的控制","dateModified":"2019-01-09T00:00:00+08:00","datePublished":"2019-01-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/01/09/5109224744061f33777f8e290aac0de0.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>David Silver《强化学习RL》第五讲 不基于模型的控制</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>某种程度上来说，这个课程所有的内容最后都会集中于本讲内容，通过本讲的学习，我们将会学习到如何训练一个Agent，使其能够在完全未知的环境下较好地完成任务，得到尽可能多的奖励。本讲是基础理论部分的最后一讲，本讲以后的内容都是关于实际应用强化学习解决大规模问题的理论和技巧。本讲的技术核心主要基于先前一讲以及更早的一些内容，如果对先前的内容有深刻的理解，那么理解本讲内容将会比较容易。</p> 
  <p>&nbsp;</p> 
  <h2><strong>简介 Introduction </strong></h2> 
  <p>上一讲主要讲解了在模型未知的情况下如何进行预测。所谓的预测就是评估一个给定的策略，也就是确定一给定策略下的状态（或状态行为对）的价值函数。这一讲的内容主要是在模型未知的条件下如何优化价值函数，这一过程也称作<strong>模型无关的控制</strong>。</p> 
  <p>现实中有很多此类的例子，比如控制一个大厦内的多个电梯使得效率最高；控制直升机的特技飞行，机器人足球世界杯上控制机器人球员，围棋游戏等等。所有的这些问题要么我们对其模型运行机制未知，但是我们可以去经历、去试；要么是虽然问题模型是已知的，但问题的规模太大以至于计算机无法高效的计算，除非使用采样的办法。本节的内容就专注于解决这些问题。</p> 
  <p>根据优化控制过程中是否利用已有或他人的经验策略来改进我们自身的控制策略，我们可以将这种优化控制分为两类：</p> 
  <p><strong>一类是现时策略学习（On-policy Learning）</strong>，其基本思想是<strong>个体已有一个策略</strong>，并且<strong>遵循这个策略进行采样</strong>，或者说采取一系列该策略下产生的行为，根据这一系列行为得到的奖励，更新状态函数，最后根据该更新的价值函数来优化策略得到较优的策略。由于要优化的策略就是当前遵循的策略，这里姑且将其翻译为“现时策略”。</p> 
  <p><strong>另一类是离线策略学习（Off-policy Learning）</strong>: 其基本思想是，虽然个体有一个自己的策略，但是<strong>个体并不针对这个策略进行采样</strong>，而是基于另一个策略进行采样，这另一个策略可以是先前学习到的策略，也可以是人类的策略等一些较为优化成熟的策略，通过观察基于这类策略的行为，或者说通过对这类策略进行采样，得到这类策略下的各种行为，继而得到一些奖励，然后更新价值函数，即在自己的策略形成的价值函数的基础上观察别的策略产生的行为，以此达到学习的目的。这种学习方式类似于“站在别人的肩膀上可以看得更远”。由于这些策略是已有的策略，这里姑且翻译为“离线策略”。</p> 
  <p>先从简单的“现时策略”开始讲解。</p> 
  <p>&nbsp;</p> 
  <h2><strong>现时策略蒙特卡洛控制 On-Policy Monte-Carlo Control</strong></h2> 
  <p>在本节中我们使用的主要思想仍然是动态规划的思想。先来回顾下动态规划是如何进行策略迭代的。</p> 
  <ul>
   <li><strong>通用策略迭代（回顾）</strong></li> 
  </ul>
  <p style="text-align:center;"><img alt="" class="has" height="441" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109140757614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="795"></p> 
  <p>&nbsp;</p> 
  <p>通用策略迭代的核心是在两个交替的过程之间进行策略优化。一个过程是<strong>策略评估</strong>，另一个是<strong>改善策略</strong>。如上图的三角形区域所示，从一个策略π和一个价值函数Ｖ开始，每一次箭头<strong>向上</strong>代表着<strong>利用当前策略进行价值函数的更新</strong>，每一次箭头<strong>向下</strong>代表着<strong>根据更新的价值函数贪婪地选择新的策略</strong>，说它是贪婪的，是因为每次都采取转移到可能的、状态函数最高的新状态的行为。最终将收敛至最优策略和最优价值函数。</p> 
  <p>注意使用动态规划算法来改善策略是需要知道<strong>某一状态的所有后续状态及状态间转移概率</strong>：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="64" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109141005564.png" width="361"></p> 
  <p>&nbsp;</p> 
  <ul>
   <li><strong>不基于模型控制的两个条件</strong></li> 
  </ul>
  <p>那么这种方法是否适用于<strong>模型未知</strong>的蒙特卡洛学习呢？答案是否定的，这其中至少存在两个问题。其一是在模<strong>型未知的条件下无法知道当前状态的所有后续状态</strong>，进而无法确定在当前状态下采取怎样的行为更合适。解决这一问题的方法是，使用状态行为对下的<strong>价值<img alt="Q(s,a)" class="has" src="https://www.zhihu.com/equation?tex=Q%28s%2Ca%29">来代替状态价值</strong>&nbsp;：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="60" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109141225212.png" width="263"></p> 
  <p>这样做的目的是可以<strong>改善策略</strong>而不用知道整个模型，只需要知道在某个状态下采取什么什么样的行为价值最大即可。具体是这样：我们从一个初始的<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">和策略<img alt="\pi" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi">开始，先根据这个策略更新每一个状态行为对的<img alt="q" class="has" src="https://www.zhihu.com/equation?tex=q">值，<img alt="s" class="has" src="https://www.zhihu.com/equation?tex=s">随后基于更新的<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">确定改善的贪婪算法。</p> 
  <p>即使这样，至少还存在一个问题，即当我们每次都使用贪婪算法来改善策略的时候，将很有可能由于没有足够的采样经验而导致产生一个并不是最优的策略，我们需要不时的尝试一些新的行为，这就是探索（Exploration），使用一个示例来解释：</p> 
  <ul>
   <li><strong>示例——贪婪行为选择</strong></li> 
  </ul>
  <p>如图：在你面前有两扇门，考虑如下的行为、奖励并使用贪婪算法改善策略：</p> 
  <p style="text-align:center;"><img alt="" class="has" src="https://pic2.zhimg.com/80/v2-116fb6cf5e7d3e9038ddf6214406d79d_hd.png" width="203"></p> 
  <p>&nbsp;</p> 
  <p>你打开左侧门得到即时奖励为０：<img alt="V(left) = 0" class="has" src="https://www.zhihu.com/equation?tex=V%28left%29+%3D+0">；</p> 
  <p>你打开右侧门得到即时奖励１：<img alt="V(right) = +1" class="has" src="https://www.zhihu.com/equation?tex=V%28right%29+%3D+%2B1">；</p> 
  <p>在使用贪婪算法时，接下来你将会继续打开右侧的门，而不会尝试打开左侧门</p> 
  <p>你打开右侧门得到即时奖励＋３：<img alt="V(right) = +2" class="has" src="https://www.zhihu.com/equation?tex=V%28right%29+%3D+%2B2">；</p> 
  <p>你打开右侧门得到即时奖励＋2：<img alt="V(right) = +2" class="has" src="https://www.zhihu.com/equation?tex=V%28right%29+%3D+%2B2">；</p> 
  <p>...</p> 
  <p>这种情况下，打开右侧门是否就一定是最好的选择呢？答案显而易见是否定的。因此完全使用贪婪算法改善策略通常不能得到最优策略。为了解决这一问题，我们需要引入一个随机机制，以一定的概率选择当前最好的策略，同时给以其它可能的行为一定的几率，这就是Ɛ-贪婪探索。</p> 
  <p>&nbsp;</p> 
  <ul>
   <li><strong>Ɛ-贪婪探索</strong></li> 
  </ul>
  <p>Ɛ-贪婪探索的目标使得某一状态下所有可能的行为都有一定非零几率被选中执行，也就保证了持续的探索，<img alt="1-\epsilon" class="has" src="https://www.zhihu.com/equation?tex=1-%5Cepsilon">的概率下选择当前认为最好的行为，而<img alt="\epsilon" class="has" src="https://www.zhihu.com/equation?tex=%5Cepsilon">的概率在所有可能的行为中选择（也包括那个当前最好的行为）。数学表达式如下：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="90" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109141800825.png" width="543"></p> 
  <p>&nbsp;</p> 
  <p><strong>定理：</strong>使用Ɛ-贪婪探索策略，对于任意一个给定的策略<img alt="\pi" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi">，我们在评估这个策略的同时也总在改善它。</p> 
  <p><strong>证明：</strong></p> 
  <p style="text-align:center;"><img alt="" class="has" height="269" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109141846721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="675"></p> 
  <p><strong>注：在证明上述定理过程中使用的不等式是在经过合理、精心设计的。</strong></p> 
  <p>解决了上述两个问题，我们最终看到蒙特卡洛控制的全貌：使用Ｑ函数进行策略评估，使用Ɛ-贪婪探索来改善策略。该方法最终可以收敛至最优策略。如下图所示：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="336" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109142444524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="531"></p> 
  <p>图中每一个向上或向下的箭头都对应着多个Episode。也就是说我们一般在经历了多个Episode之后才进行依次Ｑ函数更新或策略改善。实际上我们也可以在每经历一个Episode之后就更新Ｑ函数或改善策略。但不管使用那种方式，在Ɛ-贪婪探索算下我们始终只能得到基于某一策略下的近似Ｑ函数，且该算法没有一个终止条件，因为它一直在进行探索。因此我们必须关注以下两个方面：一方面我们不想丢掉任何更好信息和状态，另一方面随着我们策略的改善我们最终希望能终止于某一个最优策略，因为事实上最优策略不应该包括一些随机行为选择。为此引入了另一个理论概念：<strong>GLIE</strong>。</p> 
  <p>&nbsp;</p> 
  <ul>
   <li><strong>GLIE</strong></li> 
  </ul>
  <p><strong>GLIE</strong>(Greedy in the Limit with Infinite Exploration)，直白的说是在有限的时间内进行无限可能的探索。具体表现为：所有已经经历的状态行为对（state-action pair）会被无限次探索；另外随着探索的无限延伸，贪婪算法中Ɛ值趋向于０。例如如果我们取<em><img alt="\epsilon = 1/k" class="has" src="https://www.zhihu.com/equation?tex=%5Cepsilon+%3D+1%2Fk"></em>（<img alt="k" class="has" src="https://www.zhihu.com/equation?tex=k">为探索的Episode数目），那么该Ɛ贪婪蒙特卡洛控制就具备GLIE特性。</p> 
  <p>基于GLIE的蒙特卡洛控制流程如下：</p> 
  <ol>
   <li>对于给定策略<em><img alt="\pi" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi"></em>，采样第<img alt="k" class="has" src="https://www.zhihu.com/equation?tex=k">个Episode: {<img alt="{ S_{1}, A_{1}, R_{2}, ..., S_{T} }" class="has" src="https://www.zhihu.com/equation?tex=%7B+S_%7B1%7D%2C+A_%7B1%7D%2C+R_%7B2%7D%2C+...%2C+S_%7BT%7D+%7D">} ～&nbsp;<img alt="\pi" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi"></li> 
   <li>对于该Episode里出现的每一个状态行为对<img alt="S_t" class="has" src="https://www.zhihu.com/equation?tex=S_t">和<img alt="A_t" class="has" src="https://www.zhihu.com/equation?tex=A_t">,更其计数和Ｑ函数：</li> 
  </ol>
  <p>&nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="54" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109143343279.png" width="302"></p> 
  <p>&nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="74" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109143331166.png" width="580"></p> 
  <p>&nbsp; &nbsp; &nbsp;3.基于新的Ｑ函数改善以如下方式改善策略：&nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="85" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109143550736.png" width="223"></p> 
  <p><strong>定理：GLIE蒙特卡洛控制能收敛至最优的状态行为价值函数。</strong></p> 
  <p>&nbsp;</p> 
  <ul>
   <li><strong>示例——二十一点游戏的最优策略</strong></li> 
  </ul>
  <p>该图最终给出了二十一点比赛时的最优策略，但借用David的话，本文对于使用该策略进行赌博导致的输赢不负任何责任。</p> 
  <p>最优策略是这样：当你手上有可用Ａ时，大多数情况下当你的牌面和达到17或18时停止要牌，如果庄家可见的牌面在2-9之间，你选择17，其它条件选择18；当你手上没有Ａ时，最优策略提示大多数情况下牌面和达到16就要停止叫牌，当庄家可见的牌面在2-7时，这一数字更小至13甚至12。这种极端情况下，宁愿停止叫牌等待让庄家的牌爆掉。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="451" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109144155952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="652"></p> 
  <h2>&nbsp;</h2> 
  <h2><strong>现时策略时序差分控制</strong></h2> 
  <p><strong>On-Policy Temporal-Difference Control</strong></p> 
  <p>&nbsp;</p> 
  <p>上一讲提到TD相比MC有很多优点：低变异性，可以在线实时学习，可以学习不完整Episode等。因此很自然想到是否可以在控制问题上使用TD学习而不是MC学习？答案是肯定的，这就是下文要讲解的SARSA。</p> 
  <ul>
   <li><strong>SARSA</strong></li> 
  </ul>
  <p><img alt="SARSA" class="has" src="https://www.zhihu.com/equation?tex=SARSA">的名称来源于下图所示的序列描述：针对一个状态<img alt="S" class="has" src="https://www.zhihu.com/equation?tex=S">，以及一个特定的行为<img alt="A" class="has" src="https://www.zhihu.com/equation?tex=A">，进而产生一个状态行为对(<img alt="SA" class="has" src="https://www.zhihu.com/equation?tex=SA">)，与环境交互，环境收到个体的行为后会告诉个体即时奖励<img alt="R" class="has" src="https://www.zhihu.com/equation?tex=R">以及后续进入的状态<img alt="S'" class="has" src="https://www.zhihu.com/equation?tex=S%27">；接下来个体遵循<strong>现有策略</strong>产生一个行为<img alt="A'" class="has" src="https://www.zhihu.com/equation?tex=A%27">，根据当前的<strong>状态行为价值函数</strong>得到后一个状态行为对(<img alt="S'A'" class="has" src="https://www.zhihu.com/equation?tex=S%27A%27">)的价值（<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">），利用这个<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">值更新前一个状态行为对(<img alt="SA" class="has" src="https://www.zhihu.com/equation?tex=SA">)的价值。</p> 
  <p style="text-align:center;"><img alt="" class="has" src="https://pic2.zhimg.com/80/v2-5ea63cfe583accda6b162eeef38fa209_hd.png" width="93"></p> 
  <p>更直观的解释是这样：一个Agent处在某一个状态<img alt="S" class="has" src="https://www.zhihu.com/equation?tex=S">，在这个状态下它可尝试各种不同的行为，当遵循某一策略时，会根据当前策略选择一个行为<img alt="A" class="has" src="https://www.zhihu.com/equation?tex=A">，个体实际执行这个行为，与环境发生实际交互，环境会根据其行为给出即时奖励<img alt="R" class="has" src="https://www.zhihu.com/equation?tex=R">，并且进入下一个状态<img alt="S'" class="has" src="https://www.zhihu.com/equation?tex=S%27">，在这个后续状态<img alt="S'" class="has" src="https://www.zhihu.com/equation?tex=S%27">，<strong>再次遵循当前策略</strong>，产生一个行为<img alt="A'" class="has" src="https://www.zhihu.com/equation?tex=A%27">，此时，个体并不执行该行为，而是通过自身当前的状态行为价值函数得到该<img alt="S'A'" class="has" src="https://www.zhihu.com/equation?tex=S%27A%27">状态行为对的价值，利用该价值同时结合个体<img alt="S" class="has" src="https://www.zhihu.com/equation?tex=S">状态下采取行为<img alt="A" class="has" src="https://www.zhihu.com/equation?tex=A">所获得的即时奖励来更新个体在<img alt="S" class="has" src="https://www.zhihu.com/equation?tex=S">状态下采取<img alt="A" class="has" src="https://www.zhihu.com/equation?tex=A">行为的（状态）行为价值。</p> 
  <p>与蒙特卡洛控制不同的时，每一个时间步，也就是在单个Episode内每一次个体在状态<img alt="S_t" class="has" src="https://www.zhihu.com/equation?tex=S_t">采取一个行为后都要更新<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">值，同样使用<strong><img alt="\epsilon-" class="has" src="https://www.zhihu.com/equation?tex=%5Cepsilon-">贪婪探索</strong>的形式来改善策略。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="51" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109145055874.png" width="569"></p> 
  <ul>
   <li><strong>现时策略控制的SARSA算法</strong></li> 
  </ul>
  <p style="text-align:center;"><img alt="" class="has" height="269" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109145043882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="705"></p> 
  <p>注：</p> 
  <ol>
   <li>算法中的<img alt="Q(s,a)" class="has" src="https://www.zhihu.com/equation?tex=Q%28s%2Ca%29">是以一张大表存储的，这不适用于解决规模很大的问题；</li> 
   <li>对于每一个Episode，在<img alt="S" class="has" src="https://www.zhihu.com/equation?tex=S">状态时采用的行为<img alt="A" class="has" src="https://www.zhihu.com/equation?tex=A">是基于当前策略的，同时该行为也是实际Episode发生的行为，在更新<img alt="SA" class="has" src="https://www.zhihu.com/equation?tex=SA">状态行为对的价值循环里，个体并不实际执行在<img alt="S'" class="has" src="https://www.zhihu.com/equation?tex=S%27">下的<img alt="A'" class="has" src="https://www.zhihu.com/equation?tex=A%27">行为，而是将行为<img alt="A'" class="has" src="https://www.zhihu.com/equation?tex=A%27">留到下一个循环执行。</li> 
  </ol>
  <p>&nbsp;</p> 
  <p>定理：满足如下两个条件时，Sarsa算法将收敛至最优行为价值函数。</p> 
  <p>条件一：任何时候的策略<img alt="\pi_t(a|s)" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi_t%28a%7Cs%29">符合GLIE特性;</p> 
  <p>条件二：步长系数<img alt="\alpha_t" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Calpha_t">满足：</p> 
  <p style="text-align:center;"><img alt="\sum_{t=1}^{\infty}{a_t} = \infty" class="has" src="https://www.zhihu.com/equation?tex=%5Csum_%7Bt%3D1%7D%5E%7B%5Cinfty%7D%7Ba_t%7D+%3D+%5Cinfty+"></p> 
  <p>&nbsp;且&nbsp;</p> 
  <p style="text-align:center;"><img alt="\sum_{t=1}^{\infty}{a_t^2} < \infty" class="has" src="https://www.zhihu.com/equation?tex=%5Csum_%7Bt%3D1%7D%5E%7B%5Cinfty%7D%7Ba_t%5E2%7D+%3C+%5Cinfty+"></p> 
  <p>&nbsp;</p> 
  <ul>
   <li>示例——有风格子世界</li> 
  </ul>
  <p><strong>已知：</strong>如图所示，环境是一个10*7的长方形格子世界，同时有一个起始位置S和一个终止目标位置G，水平下方的数字表示对应的列中有一定强度的风，当该数字是1时，个体进入该列的某个格子时，会按图中箭头所示的方向自动移动一格，当数字为2时，表示顺风移动2格，以此类推模拟风的作用。任何试图离开格子世界的行为都会使得个体停留在移动前的位置。对于个体来说，它不清楚整个格子世界的构造，即它不知道格子是长方形的，也不知道边界在哪里。也不清楚起始位置、终止目标位置的具体为止。对于它来说，每一个格子就相当于一个封闭的房间，在没推开门离开当前房间之前它无法知道会进入哪个房间。个体具备记住曾经去过的格子的能力。格子可以执行的行为是朝上、下、左、右移动一步。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="334" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109145740727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="744"></p> 
  <p>&nbsp;</p> 
  <p><strong>问题：</strong>个体如何才能找到最短从起始格子S到终止目标格子G的最短路线？</p> 
  <p><strong>解答：</strong>首先将这个问题用强化学习常用的语言重新描述下。这是一个不基于模型的控制问题，即个体在不清楚模型机制条件下试图寻找最优策略的问题。在这个问题中，环境信息包括格子<strong>世界的形状</strong>是10*7的长方形；<strong>起始和终止格子的位置</strong>，可以用二维或一维的坐标描述，同时还包括个体在任何时候<strong>所在的格子位置</strong>。风的设置是环境动力学的一部分，它与长方形的边界共同及个体的行为共同决定了个体下一步的状态。个体从环境观测不到自身位置、起始位置以及终止位置信息的坐标描述，个体在与环境进行交互的过程中学习到自身及其它格子的位置关系。个体的行为空间是离散的四个方向。可以设置个体每行走一步获得即时奖励为-1，直到到达终止目标位置的即时奖励为0，借此希望找到最优策略。衰减系数λ可设为1。</p> 
  <p>其最优路线如下图所示：</p> 
  <p>&nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="420" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109150133468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="718"></p> 
  <p>个体通过学习发现下面的行为序列（共15步）能够得到最大程度的奖励: -14</p> 
  <p style="text-align:center;"><img alt="R,R,R,R,R,R,R,R,R,D,D,D,D,L,L" class="has" src="https://www.zhihu.com/equation?tex=R%2CR%2CR%2CR%2CR%2CR%2CR%2CR%2CR%2CD%2CD%2CD%2CD%2CL%2CL"></p> 
  <p>在个体找到这个最优行为序列的早期，由于个体对环境一无所知，SARSA算法需要尝试许多不同的行为，因此在一开始的2000多步里，个体只能完成少数几个完整的Episode，但随着个体找到一条链接起点到终点的路径，其快速优化策略的能力就显现的很明显了，因为它不需要走完一个Episode才能更新行为价值，而是每走一步就根据下一个状态能够得到的最好价值来更新当前状态的价值。</p> 
  <p>在实践环节，我们使用Python编写具体的SARSA代码。读者可以根据这些代码深入理解SARSA的核心思想。</p> 
  <p>&nbsp;</p> 
  <ul>
   <li><strong>n-步SARSA</strong></li> 
  </ul>
  <p>在之前，我们学习了n-步收获，还记得定义吗？，这里类似的引出一个n-步Sarsa的概念。观察下面一些列的式子：</p> 
  <p style="text-align:center;"><img alt="" class="has" src="https://pic3.zhimg.com/80/v2-4f4210c614a50d0307650348dee05afa_hd.png" width="472"></p> 
  <p>这里的<img alt="q_t" class="has" src="https://www.zhihu.com/equation?tex=q_t">对应的是一个状态行为对<img alt="<s_t, a_t>" class="has" src="https://www.zhihu.com/equation?tex=%3Cs_t%2C+a_t%3E">，表示的是在某个状态下<strong>采取某个行为的价值大小</strong>。如果<img alt="n = 1" class="has" src="https://www.zhihu.com/equation?tex=n+%3D+1">，则表示状态行为对<img alt="<s_t, a_t>" class="has" src="https://www.zhihu.com/equation?tex=%3Cs_t%2C+a_t%3E">的Q价值可以用两部分表示，一部分是离开状态st得到的即时奖励<img alt="R_{t+1}" class="has" src="https://www.zhihu.com/equation?tex=R_%7Bt%2B1%7D">，即时奖励只与状态有关，与该状态下采取的行为无关；另一部分是新状态行为对<img alt="<s_{t+1}, a_{t+1}>" class="has" src="https://www.zhihu.com/equation?tex=%3Cs_%7Bt%2B1%7D%2C+a_%7Bt%2B1%7D%3E">的<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">价值：环境给了个体一个新状态<img alt="s_{t+1}" class="has" src="https://www.zhihu.com/equation?tex=s_%7Bt%2B1%7D">，观察在<img alt="s_{t+1}" class="has" src="https://www.zhihu.com/equation?tex=s_%7Bt%2B1%7D">状态时基于<strong>当前策略</strong>得到的行为<img alt="a_{t+1}" class="has" src="https://www.zhihu.com/equation?tex=a_%7Bt%2B1%7D">时的<img alt="Q(s_{t+1}, a_{t+1})" class="has" src="https://www.zhihu.com/equation?tex=Q%28s_%7Bt%2B1%7D%2C+a_%7Bt%2B1%7D%29">，后续的Q价值考虑衰减系数。当<img alt="n = 2" class="has" src="https://www.zhihu.com/equation?tex=n+%3D+2">时，就向前用2步的即时奖励，然后再用新状态的<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">价值代替；如果<img alt="n = \infty" class="has" src="https://www.zhihu.com/equation?tex=n+%3D+%5Cinfty">，则表示一直用即时奖励计算<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">值，直至Episode结束，个体进入终止状态，获得终止状态的即时奖励。</p> 
  <p>定义<strong>n-步Q收获（Q-return）：</strong></p> 
  <p style="text-align:center;"><img alt="" class="has" height="53" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109151007387.png" width="570"></p> 
  <p>体会：个人感觉这个定义公式里没有体现出状态行为对的概念，理解起来容易与之前的n-步G收获混淆，其实Q本身是包含行为的，也就是在当前策略下基于某一个状态产生的行为。Q收获与G收获是有一定关系的，这可以结合第二章的Bellman方程来理解，这里不再赘述。</p> 
  <p>有了如上定义，可以把n-步Sarsa用n-步Q收获来表示，如下式：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="59" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/2019010915105345.png" width="509"></p> 
  <p>假如我们给n-步Q收获的每一个收获分配一个权重，如下图引入参数λ分配<strong>权重</strong>，并按权重对每一步Q收获求和，那么将得到<img alt="q^\lambda" class="has" src="https://www.zhihu.com/equation?tex=q%5E%5Clambda">收获，它结合了所有n-步Q收获：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="87" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/2019010915122443.png" width="302"></p> 
  <p><strong>Sarsa(λ)前向认识：</strong></p> 
  <p>如果用某一状态的<img alt="q^\lambda" class="has" src="https://www.zhihu.com/equation?tex=q%5E%5Clambda">收获来更新状态行为对的Q值，那么可以表示称如下的形式：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="54" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109152125317.png" width="484"></p> 
  <p>这就是前向认识Sarsa(λ)，使用它更新Q价值需要遍历完整的Episode，我们同样可以反向理解Sarsa(λ).</p> 
  <p>&nbsp;</p> 
  <p><strong>Sarsa(λ)反向认识：</strong></p> 
  <p>与上一讲对于TD(λ)的反向认识一样，引入<strong>效用追踪</strong>（Eligibility Trace）概念，不同的是这次的E值针对的不是一个状态，而是一个状态行为对：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="84" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109152250103.png" width="493"></p> 
  <p>&nbsp;</p> 
  <p>它体现的是一个结果与某一个状态行为对的因果关系，与得到结果最近的状态行为对，以及那些在此之前频繁发生的状态行为对对得到这个结果的影响最大。</p> 
  <p>下式是引入ET概念的<img alt="SARSA(\lambda)" class="has" src="https://www.zhihu.com/equation?tex=SARSA%28%5Clambda%29">之后的Q值更新描述：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="77" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109152337794.png" width="446"></p> 
  <p>&nbsp;</p> 
  <p>引入ET概念，同时使用<img alt="SARSA(\lambda)" class="has" src="https://www.zhihu.com/equation?tex=SARSA%28%5Clambda%29">将可以更有效的在线学习，因为不必要学习完整的Episode，数据用完即可丢弃。ET通常也是更多应用在在线学习算法中(online algorithm)。</p> 
  <p>具体的<img alt="SARSA(\lambda)" class="has" src="https://www.zhihu.com/equation?tex=SARSA%28%5Clambda%29">算法如下：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="398" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109152450318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="700"></p> 
  <p>这里要提及一下的是E(s,a)在每浏览完一个Episode后需要重新置0，这体现了ET仅在一个Episode中发挥作用；其次要提及的是算法更新Q和E的时候针对的不是某个Episode里的<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">或<img alt="E" class="has" src="https://www.zhihu.com/equation?tex=E">，而是针对个体掌握的整个状态空间和行为空间产生的Q和E。算法为什么这么做，留给读者思考。</p> 
  <p>在实践环节，我们同样实现了该算法。</p> 
  <p>实际如果是基于查表的方式实现该算法，其速度明显比Sarsa要慢。毕竟带<img alt="E" class="has" src="https://www.zhihu.com/equation?tex=E">的算法主要应用于在线更新。</p> 
  <p>下图则用了格子世界的例子具体解释了Sarsa和Sarsa(λ)算法区别：假定最左侧图描述的路线是个体采取两种算法中的一个得到的一个完整Episode的路径。为了下文更方便描述、解释两个算法之间的区别，先做几个合理的小约定：</p> 
  <p>1）认定每一步的即时奖励为0，直到终点处即时奖励为1；</p> 
  <p>2）根据算法，除了终点以外的任何状态行为对的Q值可以是任意的，但我们设定所有的Q值均为0；</p> 
  <p>3)&nbsp; &nbsp;该路线是第一次找到终点的路线。</p> 
  <p>&nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="213" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109152625323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="730"></p> 
  <p>&nbsp;</p> 
  <p><strong>Sarsa(0)算法</strong>：</p> 
  <p>由于是现时策略学习，一开始个体对环境一无所知，即<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">值均为0，它将随机选取移步行为。在到达终点前的每一个位置<img alt="S" class="has" src="https://www.zhihu.com/equation?tex=S">，个体依据当前策略，产生一个移步行为，执行该行为，环境会将其放置到一个新位置<img alt="S'" class="has" src="https://www.zhihu.com/equation?tex=S%27">，同时给以即时奖励0，在新的位置<img alt="S'" class="has" src="https://www.zhihu.com/equation?tex=S%27">上，根据当前的策略它会产生新位置下的一个行为，个体不执行该行为，仅仅在表中查找新状态下新行为的<img alt="Q'" class="has" src="https://www.zhihu.com/equation?tex=Q%27">值，由于<img alt="Q=0" class="has" src="https://www.zhihu.com/equation?tex=Q%3D0">，依据更新公式，它将把刚才离开的位置以及对应的行为的状态行为对价值<img alt="Q<S,A>" class="has" src="https://www.zhihu.com/equation?tex=Q%3CS%2CA%3E">更新为0。如此直到个体最到达终点位置<img alt="S_G" class="has" src="https://www.zhihu.com/equation?tex=S_G">，它获得一个即时奖励1，此时个体会依据公式更新其到达终点位置前所在那个位置（暂用<img alt="S_H" class="has" src="https://www.zhihu.com/equation?tex=S_H">表示，也就是图中终点位置下方，向上的箭头所在的位置）时采取向上移步的那个状态行为对价值<img alt="Q<S_H,A_{up}>" class="has" src="https://www.zhihu.com/equation?tex=Q%3CS_H%2CA_%7Bup%7D%3E">值，它将不再是0，这是个体在这个Episode中唯一一次用非0数值来更新Q值。这样完成一个Episode，此时个体已经并只进行了<strong>一次有意义的行为</strong>价值函数的更新；同时依据新的价值函数产生了新的策略。这个策略绝大多数与之前的相同，只是当个体处在某一个特殊位置时将会有一个确定的行为：直接向上移步，这个位置就是与终点相邻的下方的格子。这里请不要误认为Sarsa算法只在经历一个完整的Episode之后才更新，在这个例子中，由于我们的设定，它每走一步都会更新，只是多数时候更新的数据和原来一样罢了。</p> 
  <p>此时如果要求个体继续学习，则环境将其放入起点。个体的第二次寻路过程一开始与首次一样都是盲目随机的，直到其进入终点位置下方的位置<img alt="S_H" class="has" src="https://www.zhihu.com/equation?tex=S_H">，在这个位置，个体更新的策略要求其选择向上的行为直接进入终点位置<img alt="S_G" class="has" src="https://www.zhihu.com/equation?tex=S_G">。</p> 
  <p>同样，经过第二次的寻路，个体了解到到达终点下方的位置<img alt="S_H" class="has" src="https://www.zhihu.com/equation?tex=S_H">价值比较大，因为在这个位置直接采取向上移步的行为就可以拿到到达终点的即时奖励。因此它会将其通过移动一步可以到达<img alt="S_H" class="has" src="https://www.zhihu.com/equation?tex=S_H">的其它位置以及相应的到达&nbsp;<img alt="S_H" class="has" src="https://www.zhihu.com/equation?tex=S_H">&nbsp;位置索要采取的行为这一状态行为对的价值提升。如此反复，如果采用greedy策略更新，个体最终将得到一条到达终点的路径，不过这条路径的倒数第二步永远是在终点位置的下方。如果采用Ɛ-greedy策略更新，那么个体还会尝试到终点位置的左上右等其它方向的相邻位置价值也比较大，此时个体每次完成的路径可能都不一样。通过重复多次搜索，这种Q值的实质性的更新将覆盖越来越多的状态行为对，个体在早期采取的随机行为的步数将越来越少，直至最终实质性的更新覆盖到起始位置。此时个体将能直接给出一条确定的从起点到终点的路径。</p> 
  <p>&nbsp;</p> 
  <p><strong>Sarsa(λ)算法：</strong></p> 
  <p>该算法同时还针对每一次Episode维护一个关于状态行为对<img alt="<S,A>" class="has" src="https://www.zhihu.com/equation?tex=%3CS%2CA%3E">的<img alt="E" class="has" src="https://www.zhihu.com/equation?tex=E">表，初始时E表值均为0。当个体首次在起点<img alt="S_0" class="has" src="https://www.zhihu.com/equation?tex=S_0">决定移动一步<img alt="A_0" class="has" src="https://www.zhihu.com/equation?tex=A_0">（向右）时，它被环境告知新位置为<img alt="S_1" class="has" src="https://www.zhihu.com/equation?tex=S_1">，此时发生如下事情：首先个体会做一个标记，使<img alt="E<S_0, A_0>" class="has" src="https://www.zhihu.com/equation?tex=E%3CS_0%2C+A_0%3E">的值增加1，表明个体刚刚经历过这个事件<img alt="<S_0, A_0>" class="has" src="https://www.zhihu.com/equation?tex=%3CS_0%2C+A_0%3E">；其次它要估计这个事件的对于解决整个问题的价值，也就是估计TD误差，此时依据公式结果为0，说明个体认为在起点处向右走没什么价值，这个“没有什么价值”有两层含义：<strong>不仅说明在</strong>&nbsp;<img alt="S_0" class="has" src="https://www.zhihu.com/equation?tex=S_0"><strong>处往右目前对解决问题没有积极帮助，同时表明个体认为所有能够到达</strong>&nbsp;<img alt="S_0" class="has" src="https://www.zhihu.com/equation?tex=S_0"><strong>状态的状态行为对的价值没有任何积极或消极的变化。</strong>随后个体将要更新该Episode中所有已经经历的<img alt="Q<S,A>" class="has" src="https://www.zhihu.com/equation?tex=Q%3CS%2CA%3E">值，由于存在E值，那些在<img alt="<S_0,A_0>" class="has" src="https://www.zhihu.com/equation?tex=%3CS_0%2CA_0%3E+">之前近期发生或频繁发生的<img alt="<S,A>" class="has" src="https://www.zhihu.com/equation?tex=%3CS%2CA%3E">的Q值将改变得比其他Q值明显些，此外个体还要更新其<img alt="E" class="has" src="https://www.zhihu.com/equation?tex=E">值，以备下次使用。对于刚从起点出发的个体，这次更新没有使得任何<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">值发生变化，仅仅在<img alt="E<S_0, A_0>" class="has" src="https://www.zhihu.com/equation?tex=E%3CS_0%2C+A_0%3E">处有了一个实质的变化。随后的过程类似，个体有意义的发现就是对路径有一个记忆，体现在<img alt="E" class="has" src="https://www.zhihu.com/equation?tex=E">里，具体的<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">值没发生变化。这一情况直到个体到达终点位置时发生改变。此时个体得到了一个即时奖励1，它会发现这一次变化（从<img alt="S_H" class="has" src="https://www.zhihu.com/equation?tex=S_H">采取向上行为<img alt="A_H" class="has" src="https://www.zhihu.com/equation?tex=A_H">到达<img alt="S_G" class="has" src="https://www.zhihu.com/equation?tex=S_G">）价值明显，它会计算这个TD误差为1，同时告诉整个经历过程中所有<img alt="<s,a>" class="has" src="https://www.zhihu.com/equation?tex=%3Cs%2Ca%3E">，根据其与<img alt="<S_H,A_H>" class="has" src="https://www.zhihu.com/equation?tex=%3CS_H%2CA_H%3E">的密切关系更新这些状态行为对的价值<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">（上图右所示），个体在这个Episode中经历的所有状态行为对的Q值都将得到一个非0的更新，但是那些在个体到达<img alt="S_H" class="has" src="https://www.zhihu.com/equation?tex=S_H">之前<strong>就近</strong>发生以及频繁发生的状态行为对的价值提升得更加明显。</p> 
  <p>在图示的例子中没有显示某一状态行为频发的情况，如果个体在寻路的过程中绕过一些弯，多次到达同一个位置，并在该位置采取的相同的动作，最终个体到达终止状态时，就产生了多次发生的<img alt="<s,a>" class="has" src="https://www.zhihu.com/equation?tex=%3Cs%2Ca%3E">，这时的<img alt="<s,a>" class="has" src="https://www.zhihu.com/equation?tex=%3Cs%2Ca%3E">的价值也会得到提升。也就是说，个体每得到一个即时奖励，同时会对所有<strong>历史事件的价值</strong>进行依次更新，当然那些与该事件关系紧密的事件价值改变的较为明显。这里的事件指的就是状态行为对。在同一状态采取不同行为是不同的事件。</p> 
  <p>当个体重新从起点第二次出发时，它会发现起点处向右走的价值不再是0。如果采用greedy策略更新，个体将根据上次经验得到的新策略直接选择右走，并且一直按照原路找到终点。如果采用Ɛ-greedy策略更新，那么个体还会尝试新的路线。</p> 
  <p>由于为了解释方便，做了一些约定，这会导致问题并不要求个体找到最短一条路径，如果需要找最短路径，需要在每一次状态转移时给个体一个负的奖励。</p> 
  <p>&nbsp;</p> 
  <h2><strong>离线策略学习 Off-Policy Learning</strong></h2> 
  <p>现时策略学习的特点就是当前遵循的策略就是个体学习改善的策略。离线策略学习（Off-Policy Learning）则指的是在遵循一个策略<img alt="\mu(a|s)" class="has" src="https://www.zhihu.com/equation?tex=%5Cmu%28a%7Cs%29">的同时评估另一个策略<img alt="\pi(a|s)" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi%28a%7Cs%29">，也就是计算确定这另一个策略下的状态价值函数<img alt="v_{\pi}(s)" class="has" src="https://www.zhihu.com/equation?tex=v_%7B%5Cpi%7D%28s%29">或状态行为价值函数<img alt="q_{\pi}(s, a)" class="has" src="https://www.zhihu.com/equation?tex=q_%7B%5Cpi%7D%28s%2C+a%29">。为什么要这么做呢？因为这样可以较容易的从人类经验或其他个体的经验中学习，也可以从一些旧的策略中学习，可以比较两个策略的优劣。其中可能也是最主要的原因就是<strong>遵循一个探索式策略的基础上优化现有的策略</strong>。同样根据是否经历完整的Episode可以将其分为基于蒙特卡洛的和基于TD的。基于蒙特卡洛的离线策略学习仅有理论上的研究价值，在实际中毫无用处。在解释这一结论时引入了“重要性采样（importance sampling）”这个概念，这里就不详述了，有兴趣的读者可以参考原讲义。这里主要讲解常用的TD下的离线策略学习。</p> 
  <p>&nbsp;</p> 
  <ul>
   <li>离线策略TD学习</li> 
  </ul>
  <p>离线策略TD学习的任务就是使用TD方法在遵循一个策略<img alt="\mu(a|s)" class="has" src="https://www.zhihu.com/equation?tex=%5Cmu%28a%7Cs%29">的同时评估另一个策略<img alt="\pi(a|s)" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi%28a%7Cs%29">。具体数学表示为：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="123" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109160657759.png" width="543"></p> 
  <p>这个公式可以这样解释：个体处在状态<img alt="S_t" class="has" src="https://www.zhihu.com/equation?tex=S_t">中，基于策略<img alt="\mu" class="has" src="https://www.zhihu.com/equation?tex=%5Cmu">产生了一个行为<img alt="A_t" class="has" src="https://www.zhihu.com/equation?tex=A_t">，执行该行为后进入新的状态<img alt="S_{t+1}" class="has" src="https://www.zhihu.com/equation?tex=S_%7Bt%2B1%7D">，那么在当前策略下如何根据新状态的价值调整原来状态的价值呢？离线策略的方法就是，在状态<img alt="S_t" class="has" src="https://www.zhihu.com/equation?tex=S_t">时比较分别依据另一个策略<img alt="\pi" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi">和当前遵循的策略<img alt="\mu" class="has" src="https://www.zhihu.com/equation?tex=%5Cmu">产生行为<img alt="A_t" class="has" src="https://www.zhihu.com/equation?tex=A_t">的概率大小，如果策略<img alt="\pi" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi">得到的概率值与遵循当前策略<img alt="\mu" class="has" src="https://www.zhihu.com/equation?tex=%5Cmu">得到的概率值接近，说明根据状态<img alt="S_{t+1}" class="has" src="https://www.zhihu.com/equation?tex=S_%7Bt%2B1%7D">价值来更新<img alt="S_t" class="has" src="https://www.zhihu.com/equation?tex=S_t">的价值同时得到两个策略的支持，这一更新操作比较有说服力。同时也说明在状态<img alt="S_t" class="has" src="https://www.zhihu.com/equation?tex=S_t">时，两个策略有接近的概率选择行为<img alt="A_t" class="has" src="https://www.zhihu.com/equation?tex=A_t">。假如这一概率比值很小，则表明如果依照被评估的策略，选择<img alt="A_t" class="has" src="https://www.zhihu.com/equation?tex=A_t">的机会很小，这时候我们在更新<img alt="S_t" class="has" src="https://www.zhihu.com/equation?tex=S_t">价值的时候就不能过多的考虑基于当前策略得到的状态<img alt="S_{t+1}" class="has" src="https://www.zhihu.com/equation?tex=S_%7Bt%2B1%7D">的价值。同样概率比值大于1时的道理也类似。这就相当于借鉴被评估策略的经验来更新我们自己的策略。</p> 
  <p>应用这种思想最好的方法是基于TD(0)的Q-学习（Q-learning）。它的要点在于，更新一个状态行为对的Q价值时，采用的不是当前遵循策略的下一个状态行为对的Q价值，而是采用的待评估策略产生的下一个状态行为对的Q价值。公式如下：</p> 
  <p><img alt="" class="has" src="https://pic1.zhimg.com/80/v2-4a91996690f9e799f1dbdae7127fa56c_hd.png" width="475"></p> 
  <p>式中，红色部分的TD目标是基于另一个估策略<img alt="\pi" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi">产生的行为<img alt="A'" class="has" src="https://www.zhihu.com/equation?tex=A%27">得到的<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">价值。Q学习最主要的表现形式是：个体遵循的策略是基于当前状态行为价值函数<img alt="Q(s,a)" class="has" src="https://www.zhihu.com/equation?tex=Q%28s%2Ca%29">的一个<img alt="\epsilon-greedy" class="has" src="https://www.zhihu.com/equation?tex=%5Cepsilon-greedy">策略，而目标策略是基于当前状态行为价值函数<img alt="Q(s,a)" class="has" src="https://www.zhihu.com/equation?tex=Q%28s%2Ca%29">不包含<img alt="\epsilon" class="has" src="https://www.zhihu.com/equation?tex=%5Cepsilon">的单纯<img alt="greedy" class="has" src="https://www.zhihu.com/equation?tex=greedy">策略：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="65" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/2019010916280185.png" width="336"></p> 
  <p>注：原讲义中的w.r.t是 with respect to的缩写，表示”在...基础上“。</p> 
  <p>这样Q学习的TD目标值可以被大幅简化：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="141" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109162827495.png" width="433"></p> 
  <p>这样在状态&nbsp;<img alt="S_t" class="has" src="https://www.zhihu.com/equation?tex=S_t">&nbsp;依据Ɛ-greedy遵循策略得到的行为<img alt="A_t" class="has" src="https://www.zhihu.com/equation?tex=A_t">的<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">价值将朝着<img alt="S_{t+1}" class="has" src="https://www.zhihu.com/equation?tex=S_%7Bt%2B1%7D">状态所具有的最大<img alt="Q" class="has" src="https://www.zhihu.com/equation?tex=Q">价值的方向做一定比例的更新。这种算法能够使<img alt="greedy" class="has" src="https://www.zhihu.com/equation?tex=greedy">策略<img alt="\pi" class="has" src="https://www.zhihu.com/equation?tex=%5Cpi">最终收敛到最佳策略。由于个体实际与环境交互的时候遵循的是<img alt="\epsilon-greedy" class="has" src="https://www.zhihu.com/equation?tex=%5Cepsilon-greedy">策略，它能保证经历足够丰富的新状态。</p> 
  <p><strong>定理：</strong>Q学习控制将收敛至最优状态行为价值函数：<img alt="Q(s,a) \rightarrow q_*(s,a)" class="has" src="https://www.zhihu.com/equation?tex=Q%28s%2Ca%29+%5Crightarrow+q_%2A%28s%2Ca%29">。</p> 
  <p>下图是Q学习具体的更新公式和图解：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="168" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109163014679.png" width="177"></p> 
  <p style="text-align:center;"><img alt="" class="has" height="62" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109163028805.png" width="653"></p> 
  <p>下图是Q学习的算法流程：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="243" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109163051914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="707"></p> 
  <p>&nbsp;</p> 
  <ul>
   <li><strong>示例——悬崖行走</strong></li> 
  </ul>
  <p><strong>因为时间关系这个例子视频里没有讲解，</strong>这个例子也比较简单，可以用格子世界来模拟，图中悬崖用灰色的长方形表示，在其两端一个是起点，一个是目标终点。途中从悬崖指向起点的箭头提示悬崖同时也是终止状态。可以看出最优路线是贴着悬崖上方行走。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="171" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109163135945.png" width="447"></p> 
  <p>个人体会：该例体现出早期Q学习得到的策略要比SARSA要差一些，但后期最终总能找到最优策略。两者的曲线都有一定的起伏，说明两者都有一定的探索，即遵循的策略都是<img alt="\epsilon-greedy" class="has" src="https://www.zhihu.com/equation?tex=%5Cepsilon-greedy">执行的，但Q学习在进行价值评估时采用的是<img alt="greedy" class="has" src="https://www.zhihu.com/equation?tex=greedy">而不是再是<img alt="\epsilon-greedy" class="has" src="https://www.zhihu.com/equation?tex=%5Cepsilon-greedy">方法确定要观察的状态<img alt="S'" class="has" src="https://www.zhihu.com/equation?tex=S%27">。</p> 
  <p>&nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="263" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109163151890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="507"></p> 
  <p>&nbsp;</p> 
  <h2><strong>总结DP与TD关系</strong></h2> 
  <p>下面两张图概括了各种DP算法和各种TD算法，同时也揭示了各种不同算法之间的区别和联系。总的来说TD是采样+有数据引导(bootstrap)，DP是全宽度+实际数据。如果从Bellman期望方程角度看：聚焦于状态本身价值的是迭代法策略评估（DP）和TD学习，聚焦于状态行为对价值函数的则是Q-策略迭代（DP）和SARSA；如果从针对状态行为价值函数的Bellman优化方程角度看，则是Q-价值迭代（DP）和Q学习。</p> 
  <p>&nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="475" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/2019010916321195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="774"></p> 
  <p style="text-align:center;"><img alt="" class="has" height="337" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109163229938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5a19odXN0,size_16,color_FFFFFF,t_70" width="802"></p> 
  <p>&nbsp;</p> 
  <p>注：<img alt="" class="has" height="59" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109163250960.png" width="368"></p> 
  <p>&nbsp;</p> 
  <p>至此，David Silver强化学习公开课的第一部分就讲完了，第二部分将聚焦于各种价值函数、策略函数的近似表示；个体如何通过训练得到一个模型，并结合模型进行强化学习；如何从理论角度看平衡探索与利用这对矛盾；并最终结合经典游戏谈强化学习的实际应用。第二部分的内容虽然不像第一部分的这些内容之间联系比较紧密，但结合了不少深度学习的知识和宏观层次的模型架构，涉及到模型训练时参数的选择和调优，还是有相当难度的。在此之前读者们最好能动手实践基础部分的强化学习理论，我也将陆续贴出针对第一部分课程中提到的格子世界的代码和相关解释。敬请期待。</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
