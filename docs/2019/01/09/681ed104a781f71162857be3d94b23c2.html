<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>PyTorch 1.0 基础教程（4）：训练分类器 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="PyTorch 1.0 基础教程（4）：训练分类器" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：作者原创，转载请注明出处 https://blog.csdn.net/gukedream/article/details/86175635 PyTorch 1.0 基础教程（4）：训练分类器 关于数据 训练一个图像分类器 1.加载和规范化CIFAR10 2.定义一个卷积神经网络 3.定义损失函数和优化器 4.训练网络 5.用测试集测试网络 在GPU上训练 在多GPU上训练 更多 参考 关于数据 目前为止，我们已经定义了神经网络，计算损失，更新网络权重. 接下来，我们要考虑数据的相关问题. 通常来说，我们可以使用标准的python工具包将诸如图像，文本，音频，视频这些数据加载成为numpy数组. 然后我们可以转换这些数组到torch.*Tensor形式. 对于图像，可以使用的工具包有Pillow，OpenCV 对于音频，可以使用scipy和librosa 对于文本，可以使用原始python或Cython，或NLTK和SpaCy 针对视觉来说，可以使用torchvision，它包含一般通用数据集的加载器，如Imagenet，CIFAR10，MNIST等. 以及图像数据转换器，即torchvision.datasets和torch.utils.data.DataLoader. 以上这些工具包为我们的工作提供了很大的便利，同时可以避免重复地编写样板代码. 在本篇中，我们会使用CIFAR10数据集. 它包含的类别有： ‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’.图像的size是3x32x32，即32x32像素的3通道彩色图像. 训练一个图像分类器 要进行的步骤顺序如下： 1.使用torchvision加载和规范化CIFAR10的训练集和测试集 2.定义一个卷积神经网络 3.定义一个损失函数 4.使用训练数据训练网络 5.使用测试数据测试网络 1.加载和规范化CIFAR10 使用torchvision可以非常简单的加载CIFAR10 import torch import torchvision import torchvision.transform as transforms 用torchvision获得的数据集是PILImage 图像数据类型，它像素值的范围是[0, 1]，我们需要将其转换到[-1, 1]. transform = transforms.Compose( [transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)) ] ) trainset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=True, download=True, transform=transform) trainloader = torch.utils.data.DataLoader(trainset, batch_size=4 shuffle=True, num_workers=2) testset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=False, download=True, transform=transform) testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=True, num_workers=2) classes = (&#39;plane&#39;, &#39;car&#39;, &#39;bird&#39;, &#39;cat&#39;, &#39;deer&#39;, &#39;dog&#39;, &#39;frog&#39;, &#39;horse&#39;, &#39;ship&#39;, &#39;truck&#39;) Out: Downloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ./data/cifar-10-python.tar.gz Files already downloaded and verified 现在我们看看刚刚加载的图像. import matplotlib.pyplot as plt import numpy as np # functions to show an image def imshow(img): img = img/2 + 0.5 # unnormalize npimg = img.numpy() plt.imshow(np.transpose(npimg, (1, 2, 0))) plt.show() # get some random training images dataiter = iter(trainloader) images, labels = dataiter.next() # show images imshow(torchvisoin.utils.make_grid(images)) # print labels print(&#39; &#39;.join(&#39;%5s&#39;%classes[label[j]] for j in range(4))) Out: horse horse horse car 2.定义一个卷积神经网络 import torch.nn as nn import torch.nn.functional as F class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(3, 6, 5) self.pool = nn.MaxPool2d(2, 2) self.conv2 = nn.Conv2d(6, 16, 5) self.fc1 = nn.Linear(16*5*5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 16*5*5) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x net = Net() 3.定义损失函数和优化器 本文使用分类中常用的交叉熵损失函数以及带有动量的SGD优化方法. import torch.optim as optim criterion = nn.CrossEntropyLoss() optimizer = optim.SGD(net.parameters(), lr=0.001, momentun=0.9) 4.训练网络 现在开始，有趣的地方才刚开始. 我们简单的将数据进行迭代输入到网络中并且不断的优化. for epoch in range(2): running_loss = 0.0 for i, data in enumerate(trainloader, 0): # get the input inputs, labels = data # zero the parameter gradients optimizer.zero_grad() # forward + backward + optimize outputs = net(inputs) loss = criterion(output, labels) loss.backward() optimizer.step() # print statistics running_loss += loss.item() if i % 2000 == 1999: # print every 2000 mini-batches print(&#39;[%d, %5d] loss: %.3f&#39;% (epoch + 1, i + 1, running_loss /2000)) running_loss = 0.0 print(&#39;Finished Training&#39;) Out: [1, 2000] loss: 2.182 [1, 4000] loss: 1.819 [1, 6000] loss: 1.648 [1, 8000] loss: 1.569 [1, 10000] loss: 1.511 [1, 12000] loss: 1.473 [2, 2000] loss: 1.414 [2, 4000] loss: 1.365 [2, 6000] loss: 1.358 [2, 8000] loss: 1.322 [2, 10000] loss: 1.298 [2, 12000] loss: 1.282 Finished Training 5.用测试集测试网络 我们已经用训练数据将网络训练了2轮. 但我们需要检查网络是否已经学习到了分类能力. 我们接下来使用刚刚训练好的网络预测输入图像的类别，并与该图像的真实值做对比. 我们还会将输出结果显示出来. dataiter = iter(testloader) images, labels = dataiter.next() # print images imshow(torchvision.utils.make_grid(images)) print(&#39;GroundTruth:&#39;, &#39;&#39;.join(&#39;%5s&#39; % classes[labels[j]] for j in range(4))) Out: GroundTruth: cat ship ship plane 好，现在我们看看网络对上述图像的预测结果： outputs = net(images) 输出是10个类别的能量值. 某个类别的能量值越高，代表了网络将输入预测为该类别的程度越大 . 所以，接下来我们将最大能量值对应的索引获取. _, predicted = torch.max(outputs, 1) print(&#39;Predicted:&#39;, &#39;&#39;.join(&#39;%5s&#39;%classes[predicted[j]] for j in range(4))) Out: Predicted: dog ship ship plane 可见，预测结果还行. 接下来看看网络在整个测试集上的识别率能达到多少. correct = 0 with torch.no_grad(): for data in dataloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs.data, 1) total += labels.size(0) correct += (predicted == labels).sum().item() print(&#39;Accuracy of the network on the 10000 test images:%d %%&#39; %( 100* correct / total)) Out: Accuracy of the network on the 10000 test images: 55 % 恩，结果比随机猜测要好得多，%55 VS 10%. 这说明网络确实学习到了一些知识. 那么，那些类别表现的较佳，哪些类别又比较差呢： class_correct = list(0. for i in range(10)) class_total = list(0. for i in range(10)) with torch.no_grad(): for data in testloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs, 1) c = (predicted == labels).squeeze() for i in range(4): label = labels[i] class_correct[label] += c[i].item() class_total[label] += 1 for i in range(10): print(&#39;Accuracy of %5s : %2d %%&#39; % ( classes[i], 100*class_correct[i] /class_total[i] )) Out: Accuracy of plane : 70 % Accuracy of car : 70 % Accuracy of bird : 28 % Accuracy of cat : 25 % Accuracy of deer : 37 % Accuracy of dog : 60 % Accuracy of frog : 66 % Accuracy of horse : 62 % Accuracy of ship : 69 % Accuracy of truck : 61 % 在GPU上训练 就像将Tensor迁移到GPU一样，也可以把神经网络迁移到GPU. 首先，我们将可以用的第一块cuda设备定义： device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_avaliable() else &quot;cpu&quot;) # Assuming that we are on a CUDA machine, this should print a CUDA device: print(device) Out: cuda:0 下面这个方法可以递归地追溯所有模块，并且将他们的参数和缓存转移到CUDA张量中： net.to(device) 需要注意的是，每一次迭代时，还需要将样本对，包括样本值和标签转移到GPU中. inputs, labels = inputs.to(device), labels.to(device) 由于本文所述的模型规模较小，所以没办法体现GPU巨大的加速比. **练习：**尝试增大网络的宽度(第一个nn.Conv2d的第二个参数，以及第二个nn.Conv2d的第一个参数–这两个参数需要一致)，看看能通过GPU获得多大的加速比. 本文达到的目标： 在更高的层次上理解PyTorch的张量库和神经网络. 训练一个小型的神经网络 在多GPU上训练 未获得更大的加速比，我们可以同时使用多块GPU来训练我们的模型，这部分内容将在下一篇博客中介绍. 更多 Train neural nets to play video games Train a state-of-the-art ResNet network on imagenet Train a face generator using Generative Adversarial Networks Train a word-level language model using Recurrent LSTM networks More examples More tutorials Discuss PyTorch on the Forums Chat with other users on Slack 参考 pytorch官方网站" />
<meta property="og:description" content="版权声明：作者原创，转载请注明出处 https://blog.csdn.net/gukedream/article/details/86175635 PyTorch 1.0 基础教程（4）：训练分类器 关于数据 训练一个图像分类器 1.加载和规范化CIFAR10 2.定义一个卷积神经网络 3.定义损失函数和优化器 4.训练网络 5.用测试集测试网络 在GPU上训练 在多GPU上训练 更多 参考 关于数据 目前为止，我们已经定义了神经网络，计算损失，更新网络权重. 接下来，我们要考虑数据的相关问题. 通常来说，我们可以使用标准的python工具包将诸如图像，文本，音频，视频这些数据加载成为numpy数组. 然后我们可以转换这些数组到torch.*Tensor形式. 对于图像，可以使用的工具包有Pillow，OpenCV 对于音频，可以使用scipy和librosa 对于文本，可以使用原始python或Cython，或NLTK和SpaCy 针对视觉来说，可以使用torchvision，它包含一般通用数据集的加载器，如Imagenet，CIFAR10，MNIST等. 以及图像数据转换器，即torchvision.datasets和torch.utils.data.DataLoader. 以上这些工具包为我们的工作提供了很大的便利，同时可以避免重复地编写样板代码. 在本篇中，我们会使用CIFAR10数据集. 它包含的类别有： ‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’.图像的size是3x32x32，即32x32像素的3通道彩色图像. 训练一个图像分类器 要进行的步骤顺序如下： 1.使用torchvision加载和规范化CIFAR10的训练集和测试集 2.定义一个卷积神经网络 3.定义一个损失函数 4.使用训练数据训练网络 5.使用测试数据测试网络 1.加载和规范化CIFAR10 使用torchvision可以非常简单的加载CIFAR10 import torch import torchvision import torchvision.transform as transforms 用torchvision获得的数据集是PILImage 图像数据类型，它像素值的范围是[0, 1]，我们需要将其转换到[-1, 1]. transform = transforms.Compose( [transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)) ] ) trainset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=True, download=True, transform=transform) trainloader = torch.utils.data.DataLoader(trainset, batch_size=4 shuffle=True, num_workers=2) testset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=False, download=True, transform=transform) testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=True, num_workers=2) classes = (&#39;plane&#39;, &#39;car&#39;, &#39;bird&#39;, &#39;cat&#39;, &#39;deer&#39;, &#39;dog&#39;, &#39;frog&#39;, &#39;horse&#39;, &#39;ship&#39;, &#39;truck&#39;) Out: Downloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ./data/cifar-10-python.tar.gz Files already downloaded and verified 现在我们看看刚刚加载的图像. import matplotlib.pyplot as plt import numpy as np # functions to show an image def imshow(img): img = img/2 + 0.5 # unnormalize npimg = img.numpy() plt.imshow(np.transpose(npimg, (1, 2, 0))) plt.show() # get some random training images dataiter = iter(trainloader) images, labels = dataiter.next() # show images imshow(torchvisoin.utils.make_grid(images)) # print labels print(&#39; &#39;.join(&#39;%5s&#39;%classes[label[j]] for j in range(4))) Out: horse horse horse car 2.定义一个卷积神经网络 import torch.nn as nn import torch.nn.functional as F class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(3, 6, 5) self.pool = nn.MaxPool2d(2, 2) self.conv2 = nn.Conv2d(6, 16, 5) self.fc1 = nn.Linear(16*5*5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 16*5*5) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x net = Net() 3.定义损失函数和优化器 本文使用分类中常用的交叉熵损失函数以及带有动量的SGD优化方法. import torch.optim as optim criterion = nn.CrossEntropyLoss() optimizer = optim.SGD(net.parameters(), lr=0.001, momentun=0.9) 4.训练网络 现在开始，有趣的地方才刚开始. 我们简单的将数据进行迭代输入到网络中并且不断的优化. for epoch in range(2): running_loss = 0.0 for i, data in enumerate(trainloader, 0): # get the input inputs, labels = data # zero the parameter gradients optimizer.zero_grad() # forward + backward + optimize outputs = net(inputs) loss = criterion(output, labels) loss.backward() optimizer.step() # print statistics running_loss += loss.item() if i % 2000 == 1999: # print every 2000 mini-batches print(&#39;[%d, %5d] loss: %.3f&#39;% (epoch + 1, i + 1, running_loss /2000)) running_loss = 0.0 print(&#39;Finished Training&#39;) Out: [1, 2000] loss: 2.182 [1, 4000] loss: 1.819 [1, 6000] loss: 1.648 [1, 8000] loss: 1.569 [1, 10000] loss: 1.511 [1, 12000] loss: 1.473 [2, 2000] loss: 1.414 [2, 4000] loss: 1.365 [2, 6000] loss: 1.358 [2, 8000] loss: 1.322 [2, 10000] loss: 1.298 [2, 12000] loss: 1.282 Finished Training 5.用测试集测试网络 我们已经用训练数据将网络训练了2轮. 但我们需要检查网络是否已经学习到了分类能力. 我们接下来使用刚刚训练好的网络预测输入图像的类别，并与该图像的真实值做对比. 我们还会将输出结果显示出来. dataiter = iter(testloader) images, labels = dataiter.next() # print images imshow(torchvision.utils.make_grid(images)) print(&#39;GroundTruth:&#39;, &#39;&#39;.join(&#39;%5s&#39; % classes[labels[j]] for j in range(4))) Out: GroundTruth: cat ship ship plane 好，现在我们看看网络对上述图像的预测结果： outputs = net(images) 输出是10个类别的能量值. 某个类别的能量值越高，代表了网络将输入预测为该类别的程度越大 . 所以，接下来我们将最大能量值对应的索引获取. _, predicted = torch.max(outputs, 1) print(&#39;Predicted:&#39;, &#39;&#39;.join(&#39;%5s&#39;%classes[predicted[j]] for j in range(4))) Out: Predicted: dog ship ship plane 可见，预测结果还行. 接下来看看网络在整个测试集上的识别率能达到多少. correct = 0 with torch.no_grad(): for data in dataloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs.data, 1) total += labels.size(0) correct += (predicted == labels).sum().item() print(&#39;Accuracy of the network on the 10000 test images:%d %%&#39; %( 100* correct / total)) Out: Accuracy of the network on the 10000 test images: 55 % 恩，结果比随机猜测要好得多，%55 VS 10%. 这说明网络确实学习到了一些知识. 那么，那些类别表现的较佳，哪些类别又比较差呢： class_correct = list(0. for i in range(10)) class_total = list(0. for i in range(10)) with torch.no_grad(): for data in testloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs, 1) c = (predicted == labels).squeeze() for i in range(4): label = labels[i] class_correct[label] += c[i].item() class_total[label] += 1 for i in range(10): print(&#39;Accuracy of %5s : %2d %%&#39; % ( classes[i], 100*class_correct[i] /class_total[i] )) Out: Accuracy of plane : 70 % Accuracy of car : 70 % Accuracy of bird : 28 % Accuracy of cat : 25 % Accuracy of deer : 37 % Accuracy of dog : 60 % Accuracy of frog : 66 % Accuracy of horse : 62 % Accuracy of ship : 69 % Accuracy of truck : 61 % 在GPU上训练 就像将Tensor迁移到GPU一样，也可以把神经网络迁移到GPU. 首先，我们将可以用的第一块cuda设备定义： device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_avaliable() else &quot;cpu&quot;) # Assuming that we are on a CUDA machine, this should print a CUDA device: print(device) Out: cuda:0 下面这个方法可以递归地追溯所有模块，并且将他们的参数和缓存转移到CUDA张量中： net.to(device) 需要注意的是，每一次迭代时，还需要将样本对，包括样本值和标签转移到GPU中. inputs, labels = inputs.to(device), labels.to(device) 由于本文所述的模型规模较小，所以没办法体现GPU巨大的加速比. **练习：**尝试增大网络的宽度(第一个nn.Conv2d的第二个参数，以及第二个nn.Conv2d的第一个参数–这两个参数需要一致)，看看能通过GPU获得多大的加速比. 本文达到的目标： 在更高的层次上理解PyTorch的张量库和神经网络. 训练一个小型的神经网络 在多GPU上训练 未获得更大的加速比，我们可以同时使用多块GPU来训练我们的模型，这部分内容将在下一篇博客中介绍. 更多 Train neural nets to play video games Train a state-of-the-art ResNet network on imagenet Train a face generator using Generative Adversarial Networks Train a word-level language model using Recurrent LSTM networks More examples More tutorials Discuss PyTorch on the Forums Chat with other users on Slack 参考 pytorch官方网站" />
<link rel="canonical" href="https://mlh.app/2019/01/09/681ed104a781f71162857be3d94b23c2.html" />
<meta property="og:url" content="https://mlh.app/2019/01/09/681ed104a781f71162857be3d94b23c2.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：作者原创，转载请注明出处 https://blog.csdn.net/gukedream/article/details/86175635 PyTorch 1.0 基础教程（4）：训练分类器 关于数据 训练一个图像分类器 1.加载和规范化CIFAR10 2.定义一个卷积神经网络 3.定义损失函数和优化器 4.训练网络 5.用测试集测试网络 在GPU上训练 在多GPU上训练 更多 参考 关于数据 目前为止，我们已经定义了神经网络，计算损失，更新网络权重. 接下来，我们要考虑数据的相关问题. 通常来说，我们可以使用标准的python工具包将诸如图像，文本，音频，视频这些数据加载成为numpy数组. 然后我们可以转换这些数组到torch.*Tensor形式. 对于图像，可以使用的工具包有Pillow，OpenCV 对于音频，可以使用scipy和librosa 对于文本，可以使用原始python或Cython，或NLTK和SpaCy 针对视觉来说，可以使用torchvision，它包含一般通用数据集的加载器，如Imagenet，CIFAR10，MNIST等. 以及图像数据转换器，即torchvision.datasets和torch.utils.data.DataLoader. 以上这些工具包为我们的工作提供了很大的便利，同时可以避免重复地编写样板代码. 在本篇中，我们会使用CIFAR10数据集. 它包含的类别有： ‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’.图像的size是3x32x32，即32x32像素的3通道彩色图像. 训练一个图像分类器 要进行的步骤顺序如下： 1.使用torchvision加载和规范化CIFAR10的训练集和测试集 2.定义一个卷积神经网络 3.定义一个损失函数 4.使用训练数据训练网络 5.使用测试数据测试网络 1.加载和规范化CIFAR10 使用torchvision可以非常简单的加载CIFAR10 import torch import torchvision import torchvision.transform as transforms 用torchvision获得的数据集是PILImage 图像数据类型，它像素值的范围是[0, 1]，我们需要将其转换到[-1, 1]. transform = transforms.Compose( [transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)) ] ) trainset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=True, download=True, transform=transform) trainloader = torch.utils.data.DataLoader(trainset, batch_size=4 shuffle=True, num_workers=2) testset = torchvision.datasets.CIFAR10(root=&#39;./data&#39;, train=False, download=True, transform=transform) testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=True, num_workers=2) classes = (&#39;plane&#39;, &#39;car&#39;, &#39;bird&#39;, &#39;cat&#39;, &#39;deer&#39;, &#39;dog&#39;, &#39;frog&#39;, &#39;horse&#39;, &#39;ship&#39;, &#39;truck&#39;) Out: Downloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ./data/cifar-10-python.tar.gz Files already downloaded and verified 现在我们看看刚刚加载的图像. import matplotlib.pyplot as plt import numpy as np # functions to show an image def imshow(img): img = img/2 + 0.5 # unnormalize npimg = img.numpy() plt.imshow(np.transpose(npimg, (1, 2, 0))) plt.show() # get some random training images dataiter = iter(trainloader) images, labels = dataiter.next() # show images imshow(torchvisoin.utils.make_grid(images)) # print labels print(&#39; &#39;.join(&#39;%5s&#39;%classes[label[j]] for j in range(4))) Out: horse horse horse car 2.定义一个卷积神经网络 import torch.nn as nn import torch.nn.functional as F class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(3, 6, 5) self.pool = nn.MaxPool2d(2, 2) self.conv2 = nn.Conv2d(6, 16, 5) self.fc1 = nn.Linear(16*5*5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 16*5*5) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x net = Net() 3.定义损失函数和优化器 本文使用分类中常用的交叉熵损失函数以及带有动量的SGD优化方法. import torch.optim as optim criterion = nn.CrossEntropyLoss() optimizer = optim.SGD(net.parameters(), lr=0.001, momentun=0.9) 4.训练网络 现在开始，有趣的地方才刚开始. 我们简单的将数据进行迭代输入到网络中并且不断的优化. for epoch in range(2): running_loss = 0.0 for i, data in enumerate(trainloader, 0): # get the input inputs, labels = data # zero the parameter gradients optimizer.zero_grad() # forward + backward + optimize outputs = net(inputs) loss = criterion(output, labels) loss.backward() optimizer.step() # print statistics running_loss += loss.item() if i % 2000 == 1999: # print every 2000 mini-batches print(&#39;[%d, %5d] loss: %.3f&#39;% (epoch + 1, i + 1, running_loss /2000)) running_loss = 0.0 print(&#39;Finished Training&#39;) Out: [1, 2000] loss: 2.182 [1, 4000] loss: 1.819 [1, 6000] loss: 1.648 [1, 8000] loss: 1.569 [1, 10000] loss: 1.511 [1, 12000] loss: 1.473 [2, 2000] loss: 1.414 [2, 4000] loss: 1.365 [2, 6000] loss: 1.358 [2, 8000] loss: 1.322 [2, 10000] loss: 1.298 [2, 12000] loss: 1.282 Finished Training 5.用测试集测试网络 我们已经用训练数据将网络训练了2轮. 但我们需要检查网络是否已经学习到了分类能力. 我们接下来使用刚刚训练好的网络预测输入图像的类别，并与该图像的真实值做对比. 我们还会将输出结果显示出来. dataiter = iter(testloader) images, labels = dataiter.next() # print images imshow(torchvision.utils.make_grid(images)) print(&#39;GroundTruth:&#39;, &#39;&#39;.join(&#39;%5s&#39; % classes[labels[j]] for j in range(4))) Out: GroundTruth: cat ship ship plane 好，现在我们看看网络对上述图像的预测结果： outputs = net(images) 输出是10个类别的能量值. 某个类别的能量值越高，代表了网络将输入预测为该类别的程度越大 . 所以，接下来我们将最大能量值对应的索引获取. _, predicted = torch.max(outputs, 1) print(&#39;Predicted:&#39;, &#39;&#39;.join(&#39;%5s&#39;%classes[predicted[j]] for j in range(4))) Out: Predicted: dog ship ship plane 可见，预测结果还行. 接下来看看网络在整个测试集上的识别率能达到多少. correct = 0 with torch.no_grad(): for data in dataloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs.data, 1) total += labels.size(0) correct += (predicted == labels).sum().item() print(&#39;Accuracy of the network on the 10000 test images:%d %%&#39; %( 100* correct / total)) Out: Accuracy of the network on the 10000 test images: 55 % 恩，结果比随机猜测要好得多，%55 VS 10%. 这说明网络确实学习到了一些知识. 那么，那些类别表现的较佳，哪些类别又比较差呢： class_correct = list(0. for i in range(10)) class_total = list(0. for i in range(10)) with torch.no_grad(): for data in testloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs, 1) c = (predicted == labels).squeeze() for i in range(4): label = labels[i] class_correct[label] += c[i].item() class_total[label] += 1 for i in range(10): print(&#39;Accuracy of %5s : %2d %%&#39; % ( classes[i], 100*class_correct[i] /class_total[i] )) Out: Accuracy of plane : 70 % Accuracy of car : 70 % Accuracy of bird : 28 % Accuracy of cat : 25 % Accuracy of deer : 37 % Accuracy of dog : 60 % Accuracy of frog : 66 % Accuracy of horse : 62 % Accuracy of ship : 69 % Accuracy of truck : 61 % 在GPU上训练 就像将Tensor迁移到GPU一样，也可以把神经网络迁移到GPU. 首先，我们将可以用的第一块cuda设备定义： device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_avaliable() else &quot;cpu&quot;) # Assuming that we are on a CUDA machine, this should print a CUDA device: print(device) Out: cuda:0 下面这个方法可以递归地追溯所有模块，并且将他们的参数和缓存转移到CUDA张量中： net.to(device) 需要注意的是，每一次迭代时，还需要将样本对，包括样本值和标签转移到GPU中. inputs, labels = inputs.to(device), labels.to(device) 由于本文所述的模型规模较小，所以没办法体现GPU巨大的加速比. **练习：**尝试增大网络的宽度(第一个nn.Conv2d的第二个参数，以及第二个nn.Conv2d的第一个参数–这两个参数需要一致)，看看能通过GPU获得多大的加速比. 本文达到的目标： 在更高的层次上理解PyTorch的张量库和神经网络. 训练一个小型的神经网络 在多GPU上训练 未获得更大的加速比，我们可以同时使用多块GPU来训练我们的模型，这部分内容将在下一篇博客中介绍. 更多 Train neural nets to play video games Train a state-of-the-art ResNet network on imagenet Train a face generator using Generative Adversarial Networks Train a word-level language model using Recurrent LSTM networks More examples More tutorials Discuss PyTorch on the Forums Chat with other users on Slack 参考 pytorch官方网站","@type":"BlogPosting","url":"https://mlh.app/2019/01/09/681ed104a781f71162857be3d94b23c2.html","headline":"PyTorch 1.0 基础教程（4）：训练分类器","dateModified":"2019-01-09T00:00:00+08:00","datePublished":"2019-01-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/01/09/681ed104a781f71162857be3d94b23c2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>PyTorch 1.0 基础教程（4）：训练分类器</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：作者原创，转载请注明出处 https://blog.csdn.net/gukedream/article/details/86175635 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p></p>
  <div class="toc">
   <h3>PyTorch 1.0 基础教程（4）：训练分类器</h3>
   <ul>
    <ul>
     <li><a href="#_1" rel="nofollow">关于数据</a></li>
     <li><a href="#_17" rel="nofollow">训练一个图像分类器</a></li>
     <ul>
      <ul>
       <li><a href="#1CIFAR10_25" rel="nofollow">1.加载和规范化CIFAR10</a></li>
       <li><a href="#2_85" rel="nofollow">2.定义一个卷积神经网络</a></li>
       <li><a href="#3_111" rel="nofollow">3.定义损失函数和优化器</a></li>
       <li><a href="#4_119" rel="nofollow">4.训练网络</a></li>
       <li><a href="#5_161" rel="nofollow">5.用测试集测试网络</a></li>
       <li><a href="#GPU_240" rel="nofollow">在GPU上训练</a></li>
       <li><a href="#GPU_268" rel="nofollow">在多GPU上训练</a></li>
       <li><a href="#_270" rel="nofollow">更多</a></li>
      </ul>
     </ul>
     <li><a href="#_281" rel="nofollow">参考</a></li>
    </ul>
   </ul>
  </div>
  <p></p> 
  <h2><a id="_1"></a>关于数据</h2> 
  <p>目前为止，我们已经定义了神经网络，计算损失，更新网络权重.<br> 接下来，我们要考虑数据的相关问题.<br> 通常来说，我们可以使用标准的python工具包将诸如图像，文本，音频，视频这些数据加载成为numpy数组. 然后我们可以转换这些数组到<code>torch.*Tensor</code>形式.</p> 
  <ul> 
   <li>对于图像，可以使用的工具包有Pillow，OpenCV</li> 
   <li>对于音频，可以使用scipy和librosa</li> 
   <li>对于文本，可以使用原始python或Cython，或NLTK和SpaCy</li> 
  </ul> 
  <p>针对视觉来说，可以使用<code>torchvision</code>，它包含一般通用数据集的加载器，如Imagenet，CIFAR10，MNIST等. 以及图像数据转换器，即<code>torchvision.datasets</code>和<code>torch.utils.data.DataLoader</code>.</p> 
  <p>以上这些工具包为我们的工作提供了很大的便利，同时可以避免重复地编写样板代码.</p> 
  <p>在本篇中，我们会使用<code>CIFAR10</code>数据集. 它包含的类别有： ‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’.图像的size是3x32x32，即32x32像素的3通道彩色图像.</p> 
  <p><img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109181245857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1a2VkcmVhbQ==,size_16,color_FFFFFF,t_70" alt="cifar10"></p> 
  <h2><a id="_17"></a>训练一个图像分类器</h2> 
  <p>要进行的步骤顺序如下：<br> 1.使用<code>torchvision</code>加载和规范化CIFAR10的训练集和测试集<br> 2.定义一个卷积神经网络<br> 3.定义一个损失函数<br> 4.使用训练数据训练网络<br> 5.使用测试数据测试网络</p> 
  <h4><a id="1CIFAR10_25"></a>1.加载和规范化CIFAR10</h4> 
  <p>使用<code>torchvision</code>可以非常简单的加载CIFAR10</p> 
  <pre><code class="prism language-python"><span class="token keyword">import</span> torch
<span class="token keyword">import</span> torchvision
<span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>transform <span class="token keyword">as</span> transforms
</code></pre> 
  <p>用torchvision获得的数据集是PILImage 图像数据类型，它像素值的范围是[0, 1]，我们需要将其转换到[-1, 1].</p> 
  <pre><code class="prism language-python">transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span>
	<span class="token punctuation">[</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">]</span> <span class="token punctuation">)</span>

trainset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">'./data'</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
									    download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>transform<span class="token punctuation">)</span>
trainloader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>trainset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">4</span>
										shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> num_workers<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>

testset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span>root<span class="token operator">=</span><span class="token string">'./data'</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
										download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>transform<span class="token punctuation">)</span>
testloader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>testset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>
										shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> num_workers<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
classes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'plane'</span><span class="token punctuation">,</span> <span class="token string">'car'</span><span class="token punctuation">,</span> <span class="token string">'bird'</span><span class="token punctuation">,</span> <span class="token string">'cat'</span><span class="token punctuation">,</span>
           <span class="token string">'deer'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">,</span> <span class="token string">'frog'</span><span class="token punctuation">,</span> <span class="token string">'horse'</span><span class="token punctuation">,</span> <span class="token string">'ship'</span><span class="token punctuation">,</span> <span class="token string">'truck'</span><span class="token punctuation">)</span>

</code></pre> 
  <p>Out:</p> 
  <pre><code class="prism language-python">Downloading https<span class="token punctuation">:</span><span class="token operator">//</span>www<span class="token punctuation">.</span>cs<span class="token punctuation">.</span>toronto<span class="token punctuation">.</span>edu<span class="token operator">/</span><span class="token operator">~</span>kriz<span class="token operator">/</span>cifar<span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span>python<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz to <span class="token punctuation">.</span><span class="token operator">/</span>data<span class="token operator">/</span>cifar<span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span>python<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz
Files already downloaded <span class="token operator">and</span> verified
</code></pre> 
  <p>现在我们看看刚刚加载的图像.</p> 
  <pre><code class="prism language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token comment"># functions to show an image</span>

<span class="token keyword">def</span> <span class="token function">imshow</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>
	img <span class="token operator">=</span> img<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token comment"># unnormalize</span>
	npimg <span class="token operator">=</span> img<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>
	plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>np<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>npimg<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># get some random training images</span>
dataiter <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>trainloader<span class="token punctuation">)</span>
images<span class="token punctuation">,</span> labels <span class="token operator">=</span> dataiter<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># show images</span>
imshow<span class="token punctuation">(</span>torchvisoin<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>make_grid<span class="token punctuation">(</span>images<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># print labels</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'%5s'</span><span class="token operator">%</span>classes<span class="token punctuation">[</span>label<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
  <p><img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109183707495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1a2VkcmVhbQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p>Out:</p> 
  <pre><code class="prism language-python">horse horse horse   car
</code></pre> 
  <h4><a id="2_85"></a>2.定义一个卷积神经网络</h4> 
  <pre><code class="prism language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn
<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> F

<span class="token keyword">class</span> <span class="token class-name">Net</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token builtin">super</span><span class="token punctuation">(</span>Net<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
		self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
		self<span class="token punctuation">.</span>pool <span class="token operator">=</span> nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
		self<span class="token punctuation">.</span>conv2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
		self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">16</span><span class="token operator">*</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span>
		self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">)</span>
		self<span class="token punctuation">.</span>fc3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>

	<span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
		x <span class="token operator">=</span> self<span class="token punctuation">.</span>pool<span class="token punctuation">(</span>F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		x <span class="token operator">=</span> self<span class="token punctuation">.</span>pool<span class="token punctuation">(</span>F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		x <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token operator">*</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span>
		x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
		x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
		x <span class="token operator">=</span> self<span class="token punctuation">.</span>fc3<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
		<span class="token keyword">return</span> x
net <span class="token operator">=</span> Net<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
  <h4><a id="3_111"></a>3.定义损失函数和优化器</h4> 
  <p>本文使用分类中常用的交叉熵损失函数以及带有动量的SGD优化方法.</p> 
  <pre><code class="prism language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>optim <span class="token keyword">as</span> optim
criterion <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>
optimizer <span class="token operator">=</span> optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">,</span> momentun<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">)</span>

</code></pre> 
  <h4><a id="4_119"></a>4.训练网络</h4> 
  <p>现在开始，有趣的地方才刚开始. 我们简单的将数据进行迭代输入到网络中并且不断的优化.</p> 
  <pre><code class="prism language-python"><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	
	running_loss <span class="token operator">=</span> <span class="token number">0.0</span>
	<span class="token keyword">for</span> i<span class="token punctuation">,</span> data <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>trainloader<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token comment"># get the input</span>
		inputs<span class="token punctuation">,</span> labels <span class="token operator">=</span> data
		<span class="token comment"># zero the parameter gradients</span>
		optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>

		<span class="token comment"># forward + backward + optimize</span>
		outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>
		loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>output<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>
		loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
		optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
	
		<span class="token comment"># print statistics</span>
		running_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">2000</span> <span class="token operator">==</span> <span class="token number">1999</span><span class="token punctuation">:</span> <span class="token comment"># print every 2000 mini-batches</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[%d, %5d] loss: %.3f'</span><span class="token operator">%</span>
					<span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> running_loss <span class="token operator">/</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			running_loss <span class="token operator">=</span> <span class="token number">0.0</span>		
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Finished Training'</span><span class="token punctuation">)</span>
</code></pre> 
  <p>Out:</p> 
  <pre><code class="prism language-python"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">2.182</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">4000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.819</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">6000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.648</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">8000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.569</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.511</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">12000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.473</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">2000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.414</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">4000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.365</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">6000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.358</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">8000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.322</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.298</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">12000</span><span class="token punctuation">]</span> loss<span class="token punctuation">:</span> <span class="token number">1.282</span>
Finished Training
</code></pre> 
  <h4><a id="5_161"></a>5.用测试集测试网络</h4> 
  <p>我们已经用训练数据将网络训练了2轮. 但我们需要检查网络是否已经学习到了分类能力.<br> 我们接下来使用刚刚训练好的网络预测输入图像的类别，并与该图像的真实值做对比. 我们还会将输出结果显示出来.</p> 
  <pre><code class="prism language-python">dataiter <span class="token operator">=</span> <span class="token builtin">iter</span><span class="token punctuation">(</span>testloader<span class="token punctuation">)</span>
images<span class="token punctuation">,</span> labels <span class="token operator">=</span> dataiter<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># print images</span>
imshow<span class="token punctuation">(</span>torchvision<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>make_grid<span class="token punctuation">(</span>images<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'GroundTruth:'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'%5s'</span> <span class="token operator">%</span> classes<span class="token punctuation">[</span>labels<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
  <p><img src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109191003482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1a2VkcmVhbQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> Out:</p> 
  <pre><code class="prism language-python">GroundTruth<span class="token punctuation">:</span>    cat  ship  ship plane
</code></pre> 
  <p>好，现在我们看看网络对上述图像的预测结果：</p> 
  <pre><code class="prism language-python">outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>images<span class="token punctuation">)</span>
</code></pre> 
  <p>输出是10个类别的能量值. 某个类别的能量值越高，代表了网络将输入预测为该类别的程度越大 . 所以，接下来我们将最大能量值对应的索引获取.</p> 
  <pre><code class="prism language-python">_<span class="token punctuation">,</span> predicted <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Predicted:'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'%5s'</span><span class="token operator">%</span>classes<span class="token punctuation">[</span>predicted<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
  <p>Out:</p> 
  <pre><code class="prism language-python">Predicted<span class="token punctuation">:</span>    dog  ship  ship plane
</code></pre> 
  <p>可见，预测结果还行.<br> 接下来看看网络在整个测试集上的识别率能达到多少.</p> 
  <pre><code class="prism language-python">correct <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">for</span> data <span class="token keyword">in</span> dataloader<span class="token punctuation">:</span>
		images<span class="token punctuation">,</span> labels <span class="token operator">=</span> data
		outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>images<span class="token punctuation">)</span>
		_<span class="token punctuation">,</span> predicted <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
		total <span class="token operator">+=</span> labels<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
		correct <span class="token operator">+=</span> <span class="token punctuation">(</span>predicted <span class="token operator">==</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Accuracy of the network on the 10000 test images:%d %%'</span> <span class="token operator">%</span><span class="token punctuation">(</span>
		<span class="token number">100</span><span class="token operator">*</span> correct <span class="token operator">/</span> total<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
  <p>Out:</p> 
  <pre><code class="prism language-python">Accuracy of the network on the <span class="token number">10000</span> test images<span class="token punctuation">:</span> <span class="token number">55</span> <span class="token operator">%</span>
</code></pre> 
  <p>恩，结果比随机猜测要好得多，<code>%55 VS 10%</code>. 这说明网络确实学习到了一些知识.<br> 那么，那些类别表现的较佳，哪些类别又比较差呢：</p> 
  <pre><code class="prism language-python">class_correct <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
class_total <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">for</span> data <span class="token keyword">in</span> testloader<span class="token punctuation">:</span>
		images<span class="token punctuation">,</span> labels <span class="token operator">=</span> data
		outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>images<span class="token punctuation">)</span>
		_<span class="token punctuation">,</span> predicted <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
		c <span class="token operator">=</span> <span class="token punctuation">(</span>predicted <span class="token operator">==</span> labels<span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			label <span class="token operator">=</span> labels<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
			class_correct<span class="token punctuation">[</span>label<span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>
			class_total<span class="token punctuation">[</span>label<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Accuracy of %5s : %2d %%'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>
		classes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token operator">*</span>class_correct<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span>class_total<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
  <p>Out:</p> 
  <pre><code class="prism language-python">Accuracy of plane <span class="token punctuation">:</span> <span class="token number">70</span> <span class="token operator">%</span>
Accuracy of   car <span class="token punctuation">:</span> <span class="token number">70</span> <span class="token operator">%</span>
Accuracy of  bird <span class="token punctuation">:</span> <span class="token number">28</span> <span class="token operator">%</span>
Accuracy of   cat <span class="token punctuation">:</span> <span class="token number">25</span> <span class="token operator">%</span>
Accuracy of  deer <span class="token punctuation">:</span> <span class="token number">37</span> <span class="token operator">%</span>
Accuracy of   dog <span class="token punctuation">:</span> <span class="token number">60</span> <span class="token operator">%</span>
Accuracy of  frog <span class="token punctuation">:</span> <span class="token number">66</span> <span class="token operator">%</span>
Accuracy of horse <span class="token punctuation">:</span> <span class="token number">62</span> <span class="token operator">%</span>
Accuracy of  ship <span class="token punctuation">:</span> <span class="token number">69</span> <span class="token operator">%</span>
Accuracy of truck <span class="token punctuation">:</span> <span class="token number">61</span> <span class="token operator">%</span>
</code></pre> 
  <h4><a id="GPU_240"></a>在GPU上训练</h4> 
  <p>就像将Tensor迁移到GPU一样，也可以把神经网络迁移到GPU.<br> 首先，我们将可以用的第一块cuda设备定义：</p> 
  <pre><code class="prism language-python">device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_avaliable<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">"cpu"</span><span class="token punctuation">)</span>

<span class="token comment"># Assuming that we are on a CUDA machine, this should print a CUDA device:</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>device<span class="token punctuation">)</span>
</code></pre> 
  <p>Out:</p> 
  <pre><code class="prism language-python">cuda<span class="token punctuation">:</span><span class="token number">0</span>
</code></pre> 
  <p>下面这个方法可以递归地追溯所有模块，并且将他们的参数和缓存转移到CUDA张量中：</p> 
  <pre><code class="prism language-python">net<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>
</code></pre> 
  <p>需要注意的是，每一次迭代时，还需要将<code>样本对</code>，包括样本值和标签转移到GPU中.</p> 
  <pre><code class="prism language-python">inputs<span class="token punctuation">,</span> labels <span class="token operator">=</span> inputs<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>
</code></pre> 
  <p>由于本文所述的模型规模较小，所以没办法体现GPU巨大的加速比.<br> **练习：**尝试增大网络的宽度(第一个<code>nn.Conv2d</code>的第二个参数，以及第二个<code>nn.Conv2d</code>的第一个参数–这两个参数需要一致)，看看能通过GPU获得多大的加速比.<br> <strong>本文达到的目标：</strong></p> 
  <ul> 
   <li>在更高的层次上理解PyTorch的张量库和神经网络.</li> 
   <li>训练一个小型的神经网络</li> 
  </ul> 
  <h4><a id="GPU_268"></a>在多GPU上训练</h4> 
  <p>未获得更大的加速比，我们可以同时使用多块GPU来训练我们的模型，这部分内容将在下一篇博客中介绍.</p> 
  <h4><a id="_270"></a>更多</h4> 
  <ul> 
   <li><a href="https://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html" rel="nofollow">Train neural nets to play video games</a></li> 
   <li><a href="https://github.com/pytorch/examples/tree/master/imagenet" rel="nofollow">Train a state-of-the-art ResNet network on imagenet</a></li> 
   <li><a href="https://github.com/pytorch/examples/tree/master/dcgan" rel="nofollow">Train a face generator using Generative Adversarial Networks</a></li> 
   <li><a href="https://github.com/pytorch/examples/tree/master/word_language_model" rel="nofollow">Train a word-level language model using Recurrent LSTM networks</a></li> 
   <li><a href="https://github.com/pytorch/examples" rel="nofollow">More examples</a></li> 
   <li><a href="https://github.com/pytorch/tutorials" rel="nofollow">More tutorials</a></li> 
   <li><a href="https://discuss.pytorch.org/" rel="nofollow">Discuss PyTorch on the Forums</a></li> 
   <li><a href="https://pytorch.slack.com/messages/beginner/" rel="nofollow">Chat with other users on Slack</a></li> 
  </ul> 
  <h2><a id="_281"></a>参考</h2> 
  <p><a href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-py" rel="nofollow">pytorch官方网站</a></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
