<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>《深度学习工程师-吴恩达》02改善深层神经网络–超参数优化、batch正则化和程序框架 学习笔记 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="《深度学习工程师-吴恩达》02改善深层神经网络–超参数优化、batch正则化和程序框架 学习笔记" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="作者：jliang https://blog.csdn.net/jliang3 &nbsp; &nbsp; 《深度学习工程师-吴恩达》02改善深层神经网络--超参数优化、batch正则化和程序框架 学习总结 &nbsp; &nbsp; 1.重点归纳 1）经常需要调试的神经网络参数，重要性由高至低罗列 学习率α Momentum算法参数β、mini-batch size、隐藏单元数量 层数、学习率衰减decay rate Adam算法参数β1、β2和ε 2）调参方法 （1）网格搜索法，适用于参数数量较少时 （2）深度学习领域推荐采用随机参数，在参数空间中随机选取各个值，用这些随机取的点试验超参数的效果 （3）由粗糙到精细的策略 步骤 在整个参数取值空间粗略搜索 然后聚焦到更小的方格中搜索参数，更密集地取点 &nbsp;&nbsp;&nbsp; 随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的标尺来探索超参数 把超参数取值分为多个区间，然后在区间中随机取值 例子：学习率，取值范围是0.0001-1。把取值范围内划分为多个区间：0.0001-0.001, 0.001-0.01, 0.01-0.1, 0.1-1，然后在各个区间内分别随机取值。 3）在几个月后数据会逐渐改变，从而导致原有的超参数设定不再适用，也许只是需要重新测试/评估模型的超参数就可以，建议至少每隔几个月更新一次。 4）Batch归一化 （1）Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，归一化后使学习问题的轮廓从长形变成圆形，更易于算法优化。 （2）在神经网络的在每一层激活函数之前进行数据归一化 （3）公式 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第i层归一化（均值为0，方差为1）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 改变均值和方差： （4）有效的原因 如果输入数据分布发生改变，模型无法很好的对数据进行预测。隐藏层的输入是由其前面的输入参数决定，学习过程中前面的参数一直在发生改变，所以隐藏层的输入数据分布也是一直在改变（covariate shift问题）。 batch归一化做的就是它减少这些隐藏值分布变化的数量，即使前面层参数的变化，隐藏层输入经过batch归一化后的数据保持均值和方差不变化的分布。 它限制了前面参数变化影响数值分布的程度。batch归一化减少了输入值改变的问题，让这些值更稳定，神经网络之后的层就会更稳定。即使输入分布改变一点，它会改变得更少。 它使得网络每层都可以自己学习，稍稍独立于其他层，这有助于加速整个网络的学习。 （5）测试时 每一层在所有mini-batch上都计算得到平均值和方差 分别用每层的平均值和方差来对每层数据进行batch归一化 5）softmax输出数量与输入值数量（类别数量）一致，输出值代表输入该分类的概率，所有分类的概率总和等于1，适用于多分类。公式：a[l]=ez[l]i=1mez[l] 6） 2.调试处理 1）经常需要调试的神经网络参数 （1）参数 学习率α Momentum算法参数β Adam算法参数β1、β2和ε 层数 隐藏单元数量 学习率衰减decay rate mini-batch size （2）重要性（从上至下重要性降低） 学习率α Momentum算法参数β、mini-batch size、隐藏单元数量 层数、学习率衰减decay rate Adam算法参数β1、β2和ε 2） 最直接的调参方法就是网格搜索法，适用于参数数量较少时 3）深度学习领域推荐采用随机参数 （1）在参数空间中随机选取各个值，用这些随机取的点试验超参数的效果 （2）对于要解决的问题而言，很难提前知道哪个超参数最重要，一些超参数要比其它的更重要。例如超参数α和ε，如果α和ε都进行了5个值的尝试（共25次），对于重要性很高的α只尝试了5个不同的值。对于随机取值的方法，会尝试25个不同的α值，这样会更容易发现效果最好的值。 4）另一种方法是采用由粗糙到精细的策略 （1）步骤 在整个参数取值空间粗略搜索 然后聚焦到更小的方格中搜索参数，更密集地取点 （2）比如，在二维空间中，你会发现也许某点的效果比周围区域的其它点的效果都要好。如果你怀疑这些超参数这这附近有最优结果，接下来要做的就是放大这块小区域，然后更密集地取值（下面蓝色区域里）。 3.为超参数选择合适的范围 1）随机取值可以提升搜索效率，但随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的标尺来探索超参数 （1）把超参数取值分为多个区间，然后在区间中随机取值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例子1：学习率，取值范围是0.0001-1 把学习率取值范围内划分为多个区间：0.0001-0.001, 0.001-0.01, 0.01-0.1, 0.1-1 然后在各个区间内分别随机取值 例子2：加权移动平均参数Momentum算法参数β，取值范围0.9-0.999 计算1-β，其取值范围是0.1-0.001 划分取值区间：0.1-0.01, 0.01-0.001，对应β取值范围是：0.9-0.99, 0.99-0.999 在各个区间内分别随机取值 注：基于公式1/(1-β)，当β接近1时，β就会对细微的变化变得很敏感，所以在整个取值过程中，需要在接近1的区间内更加密集地取值 2）如果你不知道哪里才是合适的取值区间，如果取值数量较多的话，使用均匀取值也可以得到不错的效果。然后再由粗到细，聚焦到有用的超参数取值范围上。 4.超参数训练的实践 1）深度学习可以被应用到多个领域，某个应用领域的超参数设定可能在另一领域上也通用，可以参考不同领域的文章来获取灵感。 2）在已经训练好的模型中，也许在几个月后数据会逐渐改变，从而导致原有的超参数设定不再适用，也许只是需要重新测试/评估模型的超参数就可以，建议至少每隔几个月更新一次。 5.正则化网络的激活函数 1）Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，超参数的范围会更庞大，工作效果也很好。 （1）公式： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： （2）归一化后使学习问题的轮廓从长形变成圆形，更易于算法优化。 2）在实际应用中更多的是在神经网络的在每一层激活函数之前进行数据归一化（学术界中对于在激活函数之前或之后进行归一化存在争议）。 3）batch归一化 （1）公式 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第i层归一化（均值为0，方差为1）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： （2）我们不想让隐藏单元总是均值为0和方差为1，也许隐藏单元有了不同的分布会更有意义，因此：。 γ和β是模型学习参数，可以随意设置分布的平均值和方差 （3）batch归一化的作用是它不只是用于归一化输入层，甚至适用于神经网络的深度隐藏层，但对隐藏层归一化不都是平均值为0和方差为1。 6.将Batch Norm拟合神经网络 1）每个隐藏层的输入前添加batch归一化 2）在tenseflow中只需一行代码实现batch归一化：tf.nn.batch-normalization 3）batch归一化通常和mini-batch梯度下降一起使用 （1）使用当前mini-batch输入层数据计算均值和方差，然后在后续的隐藏层中使用前面计算得到的均值和方差进行归一化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）后续每一个mini-batch都重复上面的流程。 &nbsp; 4）在归一化中由于有β参数存储，所以参数b可以删除，因为两者的作用一样，合并成一个参数 7. Batch Norm为什么奏效 1）如果输入数据分布发生改变，模型无法很好的对数据进行预测，如下图中在黑色猫图片上训练，无法很好的对彩色猫进行预测。 2）在神经网络隐藏层中，隐藏层的输入是由其前面的输入参数决定，学习过程中前面的参数一直在发生改变，所以隐藏层的输入数据分布也是一直在改变，也就是上面讨论到的covariate shift问题。 （1）batch归一化做的就是它减少这些隐藏值分布变化的数量，即使前面层参数的变化，隐藏层输入经过batch归一化后的数据保持均值和方差不变化的分布。 它限制了前面参数变化影响数值分布的程度。 （2）batch归一化减少了输入值改变的问题，让这些值更稳定，神经网络之后的层就会更稳定。即使输入分布改变一点，它会改变得更少。 （3）它使得网络每层都可以自己学习，稍稍独立于其他层，这有助于加速整个网络的学习。 3）batch归一化还有轻微正则化效果 （1）均值和方差都只在当前的mini-batch上计算。当数据中有一些噪声时，归一化的过程也会有一些噪声。 （2）这和dropout相似，它往每个隐藏层的激活值上增加了噪声，它使一个隐藏的单元以一定的概率乘以零。因为隐藏单元添加了噪声，迫使后续单元不过分依赖任何一个隐藏单元。 （3）但使用较大的mini-batch size时，会减少噪声，因此减少了正则化效果。 8.测试时的Batch Norm 1）在测试时需要对每个样本逐一处理，一个样本的均值和方差没有意义，用指数加权平均来估计。 （1）这个平均数和方差覆盖所有mini-batch （2）每一层在所有mini-batch上都计算得到平均值和方差 （3）分别用每层的平均值和方差来对每层数据进行batch归一化 2）也可以使用全量训练数据计算平均值和方差，然后再使用它们来对隐藏层进行batch归一化 9.Softmax回归 1）softmax输出数量与输入值数量（类别数量）一致，输出值代表输入该分类的概率，所有分类的概率总和等于1，适用于多分类。 （1）公式： （2）先对输出值z计算，然后再进行归一化（m为总的类别数） 2）例子：z -&gt; t -&gt; a 3）一个没有隐藏层的神经网络经过softmax后是一个线性多分类模型 10.训练一个Softmax分类器 1）softmax这个名称来源是与hard max对比的，hard max中每个样本只能属于一种分类（是或否），softmax所做的从输入z到这些概率的映射更为温和，给出了属于每种分类的概率（不只是“是”或“否”）。 2）当类别数量等于2时，softmax实际上变回到logistic回归。 3）神经网络损失函数一般使用交叉熵损失函数 11.深度学习框架 1）神经网络框架 Caffe/Caffe2 CNTK DL4J Keras Lasagne Mxnet PaddlePaddle Tensorflow Theano Torch 2）衡量这些框架好坏的一些标准 方便编程 高效运行 是否开放，开放的框架不仅需要开源，而且需要良好的管理 &nbsp; &nbsp;" />
<meta property="og:description" content="作者：jliang https://blog.csdn.net/jliang3 &nbsp; &nbsp; 《深度学习工程师-吴恩达》02改善深层神经网络--超参数优化、batch正则化和程序框架 学习总结 &nbsp; &nbsp; 1.重点归纳 1）经常需要调试的神经网络参数，重要性由高至低罗列 学习率α Momentum算法参数β、mini-batch size、隐藏单元数量 层数、学习率衰减decay rate Adam算法参数β1、β2和ε 2）调参方法 （1）网格搜索法，适用于参数数量较少时 （2）深度学习领域推荐采用随机参数，在参数空间中随机选取各个值，用这些随机取的点试验超参数的效果 （3）由粗糙到精细的策略 步骤 在整个参数取值空间粗略搜索 然后聚焦到更小的方格中搜索参数，更密集地取点 &nbsp;&nbsp;&nbsp; 随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的标尺来探索超参数 把超参数取值分为多个区间，然后在区间中随机取值 例子：学习率，取值范围是0.0001-1。把取值范围内划分为多个区间：0.0001-0.001, 0.001-0.01, 0.01-0.1, 0.1-1，然后在各个区间内分别随机取值。 3）在几个月后数据会逐渐改变，从而导致原有的超参数设定不再适用，也许只是需要重新测试/评估模型的超参数就可以，建议至少每隔几个月更新一次。 4）Batch归一化 （1）Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，归一化后使学习问题的轮廓从长形变成圆形，更易于算法优化。 （2）在神经网络的在每一层激活函数之前进行数据归一化 （3）公式 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第i层归一化（均值为0，方差为1）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 改变均值和方差： （4）有效的原因 如果输入数据分布发生改变，模型无法很好的对数据进行预测。隐藏层的输入是由其前面的输入参数决定，学习过程中前面的参数一直在发生改变，所以隐藏层的输入数据分布也是一直在改变（covariate shift问题）。 batch归一化做的就是它减少这些隐藏值分布变化的数量，即使前面层参数的变化，隐藏层输入经过batch归一化后的数据保持均值和方差不变化的分布。 它限制了前面参数变化影响数值分布的程度。batch归一化减少了输入值改变的问题，让这些值更稳定，神经网络之后的层就会更稳定。即使输入分布改变一点，它会改变得更少。 它使得网络每层都可以自己学习，稍稍独立于其他层，这有助于加速整个网络的学习。 （5）测试时 每一层在所有mini-batch上都计算得到平均值和方差 分别用每层的平均值和方差来对每层数据进行batch归一化 5）softmax输出数量与输入值数量（类别数量）一致，输出值代表输入该分类的概率，所有分类的概率总和等于1，适用于多分类。公式：a[l]=ez[l]i=1mez[l] 6） 2.调试处理 1）经常需要调试的神经网络参数 （1）参数 学习率α Momentum算法参数β Adam算法参数β1、β2和ε 层数 隐藏单元数量 学习率衰减decay rate mini-batch size （2）重要性（从上至下重要性降低） 学习率α Momentum算法参数β、mini-batch size、隐藏单元数量 层数、学习率衰减decay rate Adam算法参数β1、β2和ε 2） 最直接的调参方法就是网格搜索法，适用于参数数量较少时 3）深度学习领域推荐采用随机参数 （1）在参数空间中随机选取各个值，用这些随机取的点试验超参数的效果 （2）对于要解决的问题而言，很难提前知道哪个超参数最重要，一些超参数要比其它的更重要。例如超参数α和ε，如果α和ε都进行了5个值的尝试（共25次），对于重要性很高的α只尝试了5个不同的值。对于随机取值的方法，会尝试25个不同的α值，这样会更容易发现效果最好的值。 4）另一种方法是采用由粗糙到精细的策略 （1）步骤 在整个参数取值空间粗略搜索 然后聚焦到更小的方格中搜索参数，更密集地取点 （2）比如，在二维空间中，你会发现也许某点的效果比周围区域的其它点的效果都要好。如果你怀疑这些超参数这这附近有最优结果，接下来要做的就是放大这块小区域，然后更密集地取值（下面蓝色区域里）。 3.为超参数选择合适的范围 1）随机取值可以提升搜索效率，但随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的标尺来探索超参数 （1）把超参数取值分为多个区间，然后在区间中随机取值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例子1：学习率，取值范围是0.0001-1 把学习率取值范围内划分为多个区间：0.0001-0.001, 0.001-0.01, 0.01-0.1, 0.1-1 然后在各个区间内分别随机取值 例子2：加权移动平均参数Momentum算法参数β，取值范围0.9-0.999 计算1-β，其取值范围是0.1-0.001 划分取值区间：0.1-0.01, 0.01-0.001，对应β取值范围是：0.9-0.99, 0.99-0.999 在各个区间内分别随机取值 注：基于公式1/(1-β)，当β接近1时，β就会对细微的变化变得很敏感，所以在整个取值过程中，需要在接近1的区间内更加密集地取值 2）如果你不知道哪里才是合适的取值区间，如果取值数量较多的话，使用均匀取值也可以得到不错的效果。然后再由粗到细，聚焦到有用的超参数取值范围上。 4.超参数训练的实践 1）深度学习可以被应用到多个领域，某个应用领域的超参数设定可能在另一领域上也通用，可以参考不同领域的文章来获取灵感。 2）在已经训练好的模型中，也许在几个月后数据会逐渐改变，从而导致原有的超参数设定不再适用，也许只是需要重新测试/评估模型的超参数就可以，建议至少每隔几个月更新一次。 5.正则化网络的激活函数 1）Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，超参数的范围会更庞大，工作效果也很好。 （1）公式： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： （2）归一化后使学习问题的轮廓从长形变成圆形，更易于算法优化。 2）在实际应用中更多的是在神经网络的在每一层激活函数之前进行数据归一化（学术界中对于在激活函数之前或之后进行归一化存在争议）。 3）batch归一化 （1）公式 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第i层归一化（均值为0，方差为1）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： （2）我们不想让隐藏单元总是均值为0和方差为1，也许隐藏单元有了不同的分布会更有意义，因此：。 γ和β是模型学习参数，可以随意设置分布的平均值和方差 （3）batch归一化的作用是它不只是用于归一化输入层，甚至适用于神经网络的深度隐藏层，但对隐藏层归一化不都是平均值为0和方差为1。 6.将Batch Norm拟合神经网络 1）每个隐藏层的输入前添加batch归一化 2）在tenseflow中只需一行代码实现batch归一化：tf.nn.batch-normalization 3）batch归一化通常和mini-batch梯度下降一起使用 （1）使用当前mini-batch输入层数据计算均值和方差，然后在后续的隐藏层中使用前面计算得到的均值和方差进行归一化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）后续每一个mini-batch都重复上面的流程。 &nbsp; 4）在归一化中由于有β参数存储，所以参数b可以删除，因为两者的作用一样，合并成一个参数 7. Batch Norm为什么奏效 1）如果输入数据分布发生改变，模型无法很好的对数据进行预测，如下图中在黑色猫图片上训练，无法很好的对彩色猫进行预测。 2）在神经网络隐藏层中，隐藏层的输入是由其前面的输入参数决定，学习过程中前面的参数一直在发生改变，所以隐藏层的输入数据分布也是一直在改变，也就是上面讨论到的covariate shift问题。 （1）batch归一化做的就是它减少这些隐藏值分布变化的数量，即使前面层参数的变化，隐藏层输入经过batch归一化后的数据保持均值和方差不变化的分布。 它限制了前面参数变化影响数值分布的程度。 （2）batch归一化减少了输入值改变的问题，让这些值更稳定，神经网络之后的层就会更稳定。即使输入分布改变一点，它会改变得更少。 （3）它使得网络每层都可以自己学习，稍稍独立于其他层，这有助于加速整个网络的学习。 3）batch归一化还有轻微正则化效果 （1）均值和方差都只在当前的mini-batch上计算。当数据中有一些噪声时，归一化的过程也会有一些噪声。 （2）这和dropout相似，它往每个隐藏层的激活值上增加了噪声，它使一个隐藏的单元以一定的概率乘以零。因为隐藏单元添加了噪声，迫使后续单元不过分依赖任何一个隐藏单元。 （3）但使用较大的mini-batch size时，会减少噪声，因此减少了正则化效果。 8.测试时的Batch Norm 1）在测试时需要对每个样本逐一处理，一个样本的均值和方差没有意义，用指数加权平均来估计。 （1）这个平均数和方差覆盖所有mini-batch （2）每一层在所有mini-batch上都计算得到平均值和方差 （3）分别用每层的平均值和方差来对每层数据进行batch归一化 2）也可以使用全量训练数据计算平均值和方差，然后再使用它们来对隐藏层进行batch归一化 9.Softmax回归 1）softmax输出数量与输入值数量（类别数量）一致，输出值代表输入该分类的概率，所有分类的概率总和等于1，适用于多分类。 （1）公式： （2）先对输出值z计算，然后再进行归一化（m为总的类别数） 2）例子：z -&gt; t -&gt; a 3）一个没有隐藏层的神经网络经过softmax后是一个线性多分类模型 10.训练一个Softmax分类器 1）softmax这个名称来源是与hard max对比的，hard max中每个样本只能属于一种分类（是或否），softmax所做的从输入z到这些概率的映射更为温和，给出了属于每种分类的概率（不只是“是”或“否”）。 2）当类别数量等于2时，softmax实际上变回到logistic回归。 3）神经网络损失函数一般使用交叉熵损失函数 11.深度学习框架 1）神经网络框架 Caffe/Caffe2 CNTK DL4J Keras Lasagne Mxnet PaddlePaddle Tensorflow Theano Torch 2）衡量这些框架好坏的一些标准 方便编程 高效运行 是否开放，开放的框架不仅需要开源，而且需要良好的管理 &nbsp; &nbsp;" />
<link rel="canonical" href="https://mlh.app/2019/01/09/5794419bf06c70d0c9cfa647cf28a5ed.html" />
<meta property="og:url" content="https://mlh.app/2019/01/09/5794419bf06c70d0c9cfa647cf28a5ed.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-09T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"作者：jliang https://blog.csdn.net/jliang3 &nbsp; &nbsp; 《深度学习工程师-吴恩达》02改善深层神经网络--超参数优化、batch正则化和程序框架 学习总结 &nbsp; &nbsp; 1.重点归纳 1）经常需要调试的神经网络参数，重要性由高至低罗列 学习率α Momentum算法参数β、mini-batch size、隐藏单元数量 层数、学习率衰减decay rate Adam算法参数β1、β2和ε 2）调参方法 （1）网格搜索法，适用于参数数量较少时 （2）深度学习领域推荐采用随机参数，在参数空间中随机选取各个值，用这些随机取的点试验超参数的效果 （3）由粗糙到精细的策略 步骤 在整个参数取值空间粗略搜索 然后聚焦到更小的方格中搜索参数，更密集地取点 &nbsp;&nbsp;&nbsp; 随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的标尺来探索超参数 把超参数取值分为多个区间，然后在区间中随机取值 例子：学习率，取值范围是0.0001-1。把取值范围内划分为多个区间：0.0001-0.001, 0.001-0.01, 0.01-0.1, 0.1-1，然后在各个区间内分别随机取值。 3）在几个月后数据会逐渐改变，从而导致原有的超参数设定不再适用，也许只是需要重新测试/评估模型的超参数就可以，建议至少每隔几个月更新一次。 4）Batch归一化 （1）Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，归一化后使学习问题的轮廓从长形变成圆形，更易于算法优化。 （2）在神经网络的在每一层激活函数之前进行数据归一化 （3）公式 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第i层归一化（均值为0，方差为1）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 改变均值和方差： （4）有效的原因 如果输入数据分布发生改变，模型无法很好的对数据进行预测。隐藏层的输入是由其前面的输入参数决定，学习过程中前面的参数一直在发生改变，所以隐藏层的输入数据分布也是一直在改变（covariate shift问题）。 batch归一化做的就是它减少这些隐藏值分布变化的数量，即使前面层参数的变化，隐藏层输入经过batch归一化后的数据保持均值和方差不变化的分布。 它限制了前面参数变化影响数值分布的程度。batch归一化减少了输入值改变的问题，让这些值更稳定，神经网络之后的层就会更稳定。即使输入分布改变一点，它会改变得更少。 它使得网络每层都可以自己学习，稍稍独立于其他层，这有助于加速整个网络的学习。 （5）测试时 每一层在所有mini-batch上都计算得到平均值和方差 分别用每层的平均值和方差来对每层数据进行batch归一化 5）softmax输出数量与输入值数量（类别数量）一致，输出值代表输入该分类的概率，所有分类的概率总和等于1，适用于多分类。公式：a[l]=ez[l]i=1mez[l] 6） 2.调试处理 1）经常需要调试的神经网络参数 （1）参数 学习率α Momentum算法参数β Adam算法参数β1、β2和ε 层数 隐藏单元数量 学习率衰减decay rate mini-batch size （2）重要性（从上至下重要性降低） 学习率α Momentum算法参数β、mini-batch size、隐藏单元数量 层数、学习率衰减decay rate Adam算法参数β1、β2和ε 2） 最直接的调参方法就是网格搜索法，适用于参数数量较少时 3）深度学习领域推荐采用随机参数 （1）在参数空间中随机选取各个值，用这些随机取的点试验超参数的效果 （2）对于要解决的问题而言，很难提前知道哪个超参数最重要，一些超参数要比其它的更重要。例如超参数α和ε，如果α和ε都进行了5个值的尝试（共25次），对于重要性很高的α只尝试了5个不同的值。对于随机取值的方法，会尝试25个不同的α值，这样会更容易发现效果最好的值。 4）另一种方法是采用由粗糙到精细的策略 （1）步骤 在整个参数取值空间粗略搜索 然后聚焦到更小的方格中搜索参数，更密集地取点 （2）比如，在二维空间中，你会发现也许某点的效果比周围区域的其它点的效果都要好。如果你怀疑这些超参数这这附近有最优结果，接下来要做的就是放大这块小区域，然后更密集地取值（下面蓝色区域里）。 3.为超参数选择合适的范围 1）随机取值可以提升搜索效率，但随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的标尺来探索超参数 （1）把超参数取值分为多个区间，然后在区间中随机取值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例子1：学习率，取值范围是0.0001-1 把学习率取值范围内划分为多个区间：0.0001-0.001, 0.001-0.01, 0.01-0.1, 0.1-1 然后在各个区间内分别随机取值 例子2：加权移动平均参数Momentum算法参数β，取值范围0.9-0.999 计算1-β，其取值范围是0.1-0.001 划分取值区间：0.1-0.01, 0.01-0.001，对应β取值范围是：0.9-0.99, 0.99-0.999 在各个区间内分别随机取值 注：基于公式1/(1-β)，当β接近1时，β就会对细微的变化变得很敏感，所以在整个取值过程中，需要在接近1的区间内更加密集地取值 2）如果你不知道哪里才是合适的取值区间，如果取值数量较多的话，使用均匀取值也可以得到不错的效果。然后再由粗到细，聚焦到有用的超参数取值范围上。 4.超参数训练的实践 1）深度学习可以被应用到多个领域，某个应用领域的超参数设定可能在另一领域上也通用，可以参考不同领域的文章来获取灵感。 2）在已经训练好的模型中，也许在几个月后数据会逐渐改变，从而导致原有的超参数设定不再适用，也许只是需要重新测试/评估模型的超参数就可以，建议至少每隔几个月更新一次。 5.正则化网络的激活函数 1）Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，超参数的范围会更庞大，工作效果也很好。 （1）公式： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： （2）归一化后使学习问题的轮廓从长形变成圆形，更易于算法优化。 2）在实际应用中更多的是在神经网络的在每一层激活函数之前进行数据归一化（学术界中对于在激活函数之前或之后进行归一化存在争议）。 3）batch归一化 （1）公式 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第i层归一化（均值为0，方差为1）： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差： （2）我们不想让隐藏单元总是均值为0和方差为1，也许隐藏单元有了不同的分布会更有意义，因此：。 γ和β是模型学习参数，可以随意设置分布的平均值和方差 （3）batch归一化的作用是它不只是用于归一化输入层，甚至适用于神经网络的深度隐藏层，但对隐藏层归一化不都是平均值为0和方差为1。 6.将Batch Norm拟合神经网络 1）每个隐藏层的输入前添加batch归一化 2）在tenseflow中只需一行代码实现batch归一化：tf.nn.batch-normalization 3）batch归一化通常和mini-batch梯度下降一起使用 （1）使用当前mini-batch输入层数据计算均值和方差，然后在后续的隐藏层中使用前面计算得到的均值和方差进行归一化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）后续每一个mini-batch都重复上面的流程。 &nbsp; 4）在归一化中由于有β参数存储，所以参数b可以删除，因为两者的作用一样，合并成一个参数 7. Batch Norm为什么奏效 1）如果输入数据分布发生改变，模型无法很好的对数据进行预测，如下图中在黑色猫图片上训练，无法很好的对彩色猫进行预测。 2）在神经网络隐藏层中，隐藏层的输入是由其前面的输入参数决定，学习过程中前面的参数一直在发生改变，所以隐藏层的输入数据分布也是一直在改变，也就是上面讨论到的covariate shift问题。 （1）batch归一化做的就是它减少这些隐藏值分布变化的数量，即使前面层参数的变化，隐藏层输入经过batch归一化后的数据保持均值和方差不变化的分布。 它限制了前面参数变化影响数值分布的程度。 （2）batch归一化减少了输入值改变的问题，让这些值更稳定，神经网络之后的层就会更稳定。即使输入分布改变一点，它会改变得更少。 （3）它使得网络每层都可以自己学习，稍稍独立于其他层，这有助于加速整个网络的学习。 3）batch归一化还有轻微正则化效果 （1）均值和方差都只在当前的mini-batch上计算。当数据中有一些噪声时，归一化的过程也会有一些噪声。 （2）这和dropout相似，它往每个隐藏层的激活值上增加了噪声，它使一个隐藏的单元以一定的概率乘以零。因为隐藏单元添加了噪声，迫使后续单元不过分依赖任何一个隐藏单元。 （3）但使用较大的mini-batch size时，会减少噪声，因此减少了正则化效果。 8.测试时的Batch Norm 1）在测试时需要对每个样本逐一处理，一个样本的均值和方差没有意义，用指数加权平均来估计。 （1）这个平均数和方差覆盖所有mini-batch （2）每一层在所有mini-batch上都计算得到平均值和方差 （3）分别用每层的平均值和方差来对每层数据进行batch归一化 2）也可以使用全量训练数据计算平均值和方差，然后再使用它们来对隐藏层进行batch归一化 9.Softmax回归 1）softmax输出数量与输入值数量（类别数量）一致，输出值代表输入该分类的概率，所有分类的概率总和等于1，适用于多分类。 （1）公式： （2）先对输出值z计算，然后再进行归一化（m为总的类别数） 2）例子：z -&gt; t -&gt; a 3）一个没有隐藏层的神经网络经过softmax后是一个线性多分类模型 10.训练一个Softmax分类器 1）softmax这个名称来源是与hard max对比的，hard max中每个样本只能属于一种分类（是或否），softmax所做的从输入z到这些概率的映射更为温和，给出了属于每种分类的概率（不只是“是”或“否”）。 2）当类别数量等于2时，softmax实际上变回到logistic回归。 3）神经网络损失函数一般使用交叉熵损失函数 11.深度学习框架 1）神经网络框架 Caffe/Caffe2 CNTK DL4J Keras Lasagne Mxnet PaddlePaddle Tensorflow Theano Torch 2）衡量这些框架好坏的一些标准 方便编程 高效运行 是否开放，开放的框架不仅需要开源，而且需要良好的管理 &nbsp; &nbsp;","@type":"BlogPosting","url":"https://mlh.app/2019/01/09/5794419bf06c70d0c9cfa647cf28a5ed.html","headline":"《深度学习工程师-吴恩达》02改善深层神经网络–超参数优化、batch正则化和程序框架 学习笔记","dateModified":"2019-01-09T00:00:00+08:00","datePublished":"2019-01-09T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/01/09/5794419bf06c70d0c9cfa647cf28a5ed.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>《深度学习工程师-吴恩达》02改善深层神经网络--超参数优化、batch正则化和程序框架 学习笔记</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1 id="%E4%BD%9C%E8%80%85%EF%BC%9Ajliang">作者：jliang</h1> 
  <p><a href="https://blog.csdn.net/jliang3" rel="nofollow">https://blog.csdn.net/jliang3</a></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h1 id="%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%B8%88-%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8B02%E6%94%B9%E5%96%84%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C--%E8%B6%85%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E3%80%81batch%E6%AD%A3%E5%88%99%E5%8C%96%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" style="margin-left:0cm;"><span style="color:#731c3f;">《深度学习工程师-吴恩达》02改善深层神经网络--超参数优化、batch正则化和程序框架 学习总结</span></h1> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>1.</strong><strong>重点归纳</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）经常需要调试的神经网络参数，重要性由高至低罗列</span></p> 
  <ul>
   <li> <p style="text-indent:0;"><span style="color:#595959;">学习率α</span></p> </li> 
   <li> <p style="text-indent:0;"><span style="color:#595959;">Momentum算法参数β、mini-batch size、隐藏单元数量</span></p> </li> 
   <li> <p style="text-indent:0;"><span style="color:#595959;">层数、学习率衰减decay rate</span></p> </li> 
   <li> <p style="text-indent:0;"><span style="color:#595959;">Adam算法参数β1、β2和<em>ε</em></span></p> </li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）调参方法</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）网格搜索法，适用于参数数量较少时</span></p> 
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="190" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200458294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="191"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）深度学习领域推荐采用随机参数，在参数空间中随机选取各个值，用这些随机取的点试验超参数的效果</span></p> 
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="193" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200509577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="192"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（3）由粗糙到精细的策略</span></p> 
  <ul>
   <li><span style="color:#595959;">步骤</span> 
    <ul>
     <li><span style="color:#595959;">在整个参数取值空间粗略搜索</span></li> 
     <li><span style="color:#595959;">然后聚焦到更小的方格中搜索参数，更密集地取点</span></li> 
    </ul></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp; </span><img alt="" class="has" height="172" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200536706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="238"></p> 
  <ul>
   <li><span style="color:#595959;">随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的标尺来探索超参数</span> 
    <ul>
     <li><span style="color:#595959;">把超参数取值分为多个区间，然后在区间中随机取值</span></li> 
     <li><span style="color:#595959;">例子：学习率，取值范围是0.0001-1。把取值范围内划分为多个区间：0.0001-0.001, 0.001-0.01, 0.01-0.1, 0.1-1，然后在各个区间内分别随机取值。</span></li> 
    </ul></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">3）在几个月后数据会逐渐改变，从而导致原有的超参数设定不再适用，也许只是需要重新测试/评估模型的超参数就可以，建议至少每隔几个月更新一次。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">4）Batch归一化</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，归一化后使学习问题的轮廓从长形变成圆形，更易于算法优化。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）在神经网络的在每一层激活函数之前进行数据归一化</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（3）公式</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第i层归一化（均值为0，方差为1）：</span><img alt="" class="has" height="37" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200559618.png" width="112"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值：</span><img alt="" class="has" height="39" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200616270.png" width="121"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差：</span><img alt="" class="has" height="43" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200634482.png" width="169"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 改变均值和方差：</span><img alt="" class="has" height="40" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200653578.png" width="168"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（4）有效的原因</span></p> 
  <ul>
   <li><span style="color:#595959;">如果输入数据分布发生改变，模型无法很好的对数据进行预测。隐藏层的输入是由其前面的输入参数决定，学习过程中前面的参数一直在发生改变，所以隐藏层的输入数据分布也是一直在改变（covariate shift问题）。</span></li> 
   <li><span style="color:#595959;">batch归一化做的就是它减少这些隐藏值分布变化的数量，即使前面层参数的变化，隐藏层输入经过batch归一化后的数据保持均值和方差不变化的分布。 它限制了前面参数变化影响数值分布的程度。batch归一化减少了输入值改变的问题，让这些值更稳定，神经网络之后的层就会更稳定。即使输入分布改变一点，它会改变得更少。</span></li> 
   <li><span style="color:#595959;">它使得网络每层都可以自己学习，稍稍独立于其他层，这有助于加速整个网络的学习。</span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（5）测试时</span></p> 
  <ul>
   <li><span style="color:#595959;">每一层在所有mini-batch上都计算得到平均值和方差</span></li> 
   <li><span style="color:#595959;">分别用每层的平均值和方差来对每层数据进行batch归一化</span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">5）softmax输出数量与输入值数量（类别数量）一致，输出值代表输入该分类的概率，所有分类的概率总和等于1，适用于多分类。公式：<em>a</em><em>[l]</em><em>=</em><em>e</em><em>z</em><em>[l]</em><em>i=1</em><em>m</em><em>e</em><em>z</em><em>[l]</em></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">6）</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>2.</strong><strong>调试处理</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）经常需要调试的神经网络参数</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）参数</span></p> 
  <ul>
   <li><span style="color:#595959;">学习率α</span></li> 
   <li><span style="color:#595959;">Momentum算法参数β</span></li> 
   <li><span style="color:#595959;">Adam算法参数β1、β2和ε</span></li> 
   <li><span style="color:#595959;">层数</span></li> 
   <li><span style="color:#595959;">隐藏单元数量</span></li> 
   <li><span style="color:#595959;">学习率衰减decay rate</span></li> 
   <li><span style="color:#595959;">mini-batch size</span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）重要性（从上至下重要性降低）</span></p> 
  <ul>
   <li><span style="color:#595959;">学习率α</span></li> 
   <li><span style="color:#595959;">Momentum算法参数β、mini-batch size、隐藏单元数量</span></li> 
   <li><span style="color:#595959;">层数、学习率衰减decay rate</span></li> 
   <li><span style="color:#595959;">Adam算法参数β1、β2和<em>ε</em></span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2） 最直接的调参方法就是网格搜索法，适用于参数数量较少时</span></p> 
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="215" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200723754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="216"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">3）深度学习领域推荐采用随机参数</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）在参数空间中随机选取各个值，用这些随机取的点试验超参数的效果</span></p> 
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="239" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/2019010920073245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="238"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）对于要解决的问题而言，很难提前知道哪个超参数最重要，一些超参数要比其它的更重要。例如超参数α和<em>ε</em>，如果α和<em>ε</em>都进行了5个值的尝试（共25次），对于重要性很高的α只尝试了5个不同的值。对于随机取值的方法，会尝试25个不同的α值，这样会更容易发现效果最好的值。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">4）另一种方法是采用由粗糙到精细的策略</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）步骤</span></p> 
  <ul>
   <li><span style="color:#595959;">在整个参数取值空间粗略搜索</span></li> 
   <li><span style="color:#595959;">然后聚焦到更小的方格中搜索参数，更密集地取点</span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="236" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109200749980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="326"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）比如，在二维空间中，你会发现也许某点的效果比周围区域的其它点的效果都要好。如果你怀疑这些超参数这这附近有最优结果，接下来要做的就是放大这块小区域，然后更密集地取值（下面蓝色区域里）。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>3.</strong><strong>为超参数选择合适的范围</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）随机取值可以提升搜索效率，但随机取值并不是在有效值范围内的随机均匀取值，而是选择合适的标尺来探索超参数</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）把超参数取值分为多个区间，然后在区间中随机取值</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例子1：学习率，取值范围是0.0001-1</span></p> 
  <ul>
   <li><span style="color:#595959;">把学习率取值范围内划分为多个区间：0.0001-0.001, 0.001-0.01, 0.01-0.1, 0.1-1</span></li> 
   <li><span style="color:#595959;">然后在各个区间内分别随机取值</span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">例子2：加权移动平均参数Momentum算法参数β，取值范围0.9-0.999</span></p> 
  <ul>
   <li><span style="color:#595959;">计算1-β，其取值范围是0.1-0.001</span></li> 
   <li><span style="color:#595959;">划分取值区间：0.1-0.01, 0.01-0.001，对应β取值范围是：0.9-0.99, 0.99-0.999</span></li> 
   <li><span style="color:#595959;">在各个区间内分别随机取值</span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">注：基于公式1/(1-β)，当β接近1时，β就会对细微的变化变得很敏感，所以在整个取值过程中，需要在接近1的区间内更加密集地取值</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）如果你不知道哪里才是合适的取值区间，如果取值数量较多的话，使用均匀取值也可以得到不错的效果。然后再由粗到细，聚焦到有用的超参数取值范围上。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>4.</strong><strong>超参数训练的实践</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）深度学习可以被应用到多个领域，某个应用领域的超参数设定可能在另一领域上也通用，可以参考不同领域的文章来获取灵感。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）在已经训练好的模型中，也许在几个月后数据会逐渐改变，从而导致原有的超参数设定不再适用，也许只是需要重新测试/评估模型的超参数就可以，建议至少每隔几个月更新一次。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>5.</strong><strong>正则化网络的激活函数</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更加稳定，超参数的范围会更庞大，工作效果也很好。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）公式：</span><img alt="" class="has" height="41" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/2019010920101429.png" width="77"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值：</span><img alt="" class="has" height="47" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201033169.png" width="123"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差：</span><img alt="" class="has" height="33" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201048560.png" width="167"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）归一化后使学习问题的轮廓从长形变成圆形，更易于算法优化。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）在实际应用中更多的是在神经网络的在每一层激活函数之前进行数据归一化（学术界中对于在激活函数之前或之后进行归一化存在争议）。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">3）batch归一化</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）公式</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第i层归一化（均值为0，方差为1）：</span><img alt="" class="has" height="42" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201115984.png" width="111"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 均值：</span><img alt="" class="has" height="36" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201131531.png" width="112"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方差：</span><img alt="" class="has" height="52" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201156519.png" width="201"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）我们不想让隐藏单元总是均值为0和方差为1，也许隐藏单元有了不同的分布会更有意义，因此：</span><img alt="" class="has" height="41" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201217793.png" width="174"><span style="color:#595959;">。</span></p> 
  <ul>
   <li><span style="color:#595959;"><em>γ</em>和<em>β</em>是模型学习参数，可以随意设置分布的平均值和方差</span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（3）batch归一化的作用是它不只是用于归一化输入层，甚至适用于神经网络的深度隐藏层，但对隐藏层归一化不都是平均值为0和方差为1。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>6.</strong><strong>将Batch Norm</strong><strong>拟合神经网络</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）每个隐藏层的输入前添加batch归一化</span></p> 
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="206" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201234908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="620"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）在tenseflow中只需一行代码实现batch归一化：tf.nn.batch-normalization</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">3）batch归一化通常和mini-batch梯度下降一起使用</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）使用当前mini-batch输入层数据计算均值和方差，然后在后续的隐藏层中使用前面计算得到的均值和方差进行归一化。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><img alt="" class="has" height="38" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201318608.png" width="577"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）后续每一个mini-batch都重复上面的流程。</span></p> 
  <p style="margin-left:78.3pt;">&nbsp;</p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">4）在归一化中由于有<em>β</em>参数存储，所以参数b可以删除，因为两者的作用一样，合并成一个参数</span></p> 
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="161" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201331309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="716"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>7. Batch Norm</strong><strong>为什么奏效</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）如果输入数据分布发生改变，模型无法很好的对数据进行预测，如下图中在黑色猫图片上训练，无法很好的对彩色猫进行预测。</span></p> 
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="398" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/2019010920134723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="718"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）在神经网络隐藏层中，隐藏层的输入是由其前面的输入参数决定，学习过程中前面的参数一直在发生改变，所以隐藏层的输入数据分布也是一直在改变，也就是上面讨论到的covariate shift问题。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）batch归一化做的就是它减少这些隐藏值分布变化的数量，即使前面层参数的变化，隐藏层输入经过batch归一化后的数据保持均值和方差不变化的分布。 它限制了前面参数变化影响数值分布的程度。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）batch归一化减少了输入值改变的问题，让这些值更稳定，神经网络之后的层就会更稳定。即使输入分布改变一点，它会改变得更少。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（3）它使得网络每层都可以自己学习，稍稍独立于其他层，这有助于加速整个网络的学习。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">3）batch归一化还有轻微正则化效果</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）均值和方差都只在当前的mini-batch上计算。当数据中有一些噪声时，归一化的过程也会有一些噪声。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）这和dropout相似，它往每个隐藏层的激活值上增加了噪声，它使一个隐藏的单元以一定的概率乘以零。因为隐藏单元添加了噪声，迫使后续单元不过分依赖任何一个隐藏单元。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（3）但使用较大的mini-batch size时，会减少噪声，因此减少了正则化效果。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>8.</strong><strong>测试时的Batch Norm</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）在测试时需要对每个样本逐一处理，一个样本的均值和方差没有意义，用指数加权平均来估计。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）这个平均数和方差覆盖所有mini-batch</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）每一层在所有mini-batch上都计算得到平均值和方差</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（3）分别用每层的平均值和方差来对每层数据进行batch归一化</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）也可以使用全量训练数据计算平均值和方差，然后再使用它们来对隐藏层进行batch归一化</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>9.Softmax</strong><strong>回归</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）softmax输出数量与输入值数量（类别数量）一致，输出值代表输入该分类的概率，所有分类的概率总和等于1，适用于多分类。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（1）公式：</span><img alt="" class="has" height="56" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201424352.png" width="117"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">（2）先对输出值z计算</span><img alt="" class="has" height="25" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201444319.png" width="26"><span style="color:#595959;">，然后再进行归一化（m为总的类别数）</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）例子：z -&gt; t -&gt; a</span></p> 
  <p style="margin-left:78.3pt;"><img alt="" class="has" height="419" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201452621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaWFuZzM=,size_16,color_FFFFFF,t_70" width="769"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">3）一个没有隐藏层的神经网络经过softmax后是一个线性多分类模型</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>10.</strong><strong>训练一个Softmax</strong><strong>分类器</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）softmax这个名称来源是与hard max对比的，hard max中每个样本只能属于一种分类（是或否），softmax所做的从输入z到这些概率的映射更为温和，给出了属于每种分类的概率（不只是“是”或“否”）。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）当类别数量等于2时，softmax实际上变回到logistic回归。</span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">3）神经网络损失函数一般使用交叉熵损失函数</span><img alt="" class="has" height="37" src="https://blog.uzzz.org.cn/_p?https://img-blog.csdnimg.cn/20190109201519533.png" width="201"></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;"><strong>11.</strong><strong>深度学习框架</strong></span></p> 
  <p style="margin-left:78.3pt;"><span style="color:#595959;">1）神经网络框架</span></p> 
  <ul>
   <li><span style="color:#595959;">Caffe/Caffe2</span></li> 
   <li><span style="color:#595959;">CNTK</span></li> 
   <li><span style="color:#595959;">DL4J</span></li> 
   <li><span style="color:#595959;">Keras</span></li> 
   <li><span style="color:#595959;">Lasagne</span></li> 
   <li><span style="color:#595959;">Mxnet</span></li> 
   <li><span style="color:#595959;">PaddlePaddle</span></li> 
   <li><span style="color:#595959;">Tensorflow</span></li> 
   <li><span style="color:#595959;">Theano</span></li> 
   <li><span style="color:#595959;">Torch</span></li> 
  </ul>
  <p style="margin-left:78.3pt;"><span style="color:#595959;">2）衡量这些框架好坏的一些标准</span></p> 
  <ul>
   <li><span style="color:#595959;">方便编程</span></li> 
   <li><span style="color:#595959;">高效运行</span></li> 
   <li><span style="color:#595959;">是否开放，开放的框架不仅需要开源，而且需要良好的管理</span></li> 
  </ul>
  <p style="margin-left:78.3pt;">&nbsp;</p> 
  <p style="margin-left:78.3pt;">&nbsp;</p> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
