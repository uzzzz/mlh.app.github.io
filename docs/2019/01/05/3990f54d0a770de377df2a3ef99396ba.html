<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>以太坊源码分析：fetcher模块和区块传播 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="以太坊源码分析：fetcher模块和区块传播" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：版权归lessisbetter.site所有，转载请请声明 https://blog.csdn.net/m0_43499523/article/details/85852204 前言 这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。 当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。 总体过程和传播策略 本节从宏观角度介绍，节点产生区块后，为了传播给远端节点做了啥，远端节点收到区块后又做了什么，每个节点都连接了很多Peer，它传播的策略是什么样的？ 总体流程和策略可以总结为，传播给远端Peer节点，Peer验证区块无误后，加入到本地区块链，继续传播新区块信息。具体过程如下。 先看总体过程。产生区块后，miner模块会发布一个事件NewMinedBlockEvent，订阅事件的协程收到事件后，就会把新区块的消息，广播给它所有的peer，peer收到消息后，会交给自己的fetcher模块处理，fetcher进行基本的验证后，区块没问题，发现这个区块就是本地链需要的下一个区块，则交给blockChain进一步进行完整的验证，这个过程会执行区块所有的交易，无误后把区块加入到本地链，写入数据库，这个过程就是下面的流程图，图1。 总体流程图，能看到有个分叉，是因为节点传播新区块是有策略的。它的传播策略为： 假如节点连接了N个Peer，它只向Peer列表的sqrt(N)个Peer广播完整的区块消息。 向所有的Peer广播只包含区块Hash的消息。 策略图的效果如图2，红色节点将区块传播给黄色节点： 收到区块Hash的节点，需要从发送给它消息的Peer那里获取对应的完整区块，获取区块后就会按照图1的流程，加入到fetcher队列，最终插入本地区块链后，将区块的Hash值广播给和它相连，但还不知道这个区块的Peer。非产生区块节点的策略图，如图3，黄色节点将区块Hash传播给青色节点： 至此，可以看出以太坊采用以石击水的方式，像水纹一样，层层扩散新产生的区块。 Fetcher模块是干啥的 fetcher模块的功能，就是收集其他Peer通知它的区块信息：1）完整的区块2）区块Hash消息。根据通知的消息，获取完整的区块，然后传递给eth模块把区块插入区块链。 如果是完整区块，就可以传递给eth插入区块，如果只有区块Hash，则需要从其他的Peer获取此完整的区块，然后再传递给eth插入区块。 源码解读 本节介绍区块传播和处理的细节东西，方式仍然是先用图解释流程，再是代码流程。 产块节点的传播新区块 节点产生区块后，广播的流程可以表示为图4： 发布事件 事件处理函数选择要广播完整的Peer，然后将区块加入到它们的队列 事件处理函数把区块Hash添加到所有Peer的另外一个通知队列 每个Peer的广播处理函数，会遍历它的待广播区块队列和通知队列，把数据封装成消息，调用P2P接口发送出去 再看下代码上的细节。 worker.wait()函数发布事件NewMinedBlockEvent。 ProtocolManager.minedBroadcastLoop()是事件处理函数。它调用了2次pm.BroadcastBlock()。 // Mined broadcast loop func (pm *ProtocolManager) minedBroadcastLoop() { // automatically stops if unsubscribe for obj := range pm.minedBlockSub.Chan() { switch ev := obj.Data.(type) { case core.NewMinedBlockEvent: pm.BroadcastBlock(ev.Block, true) // First propagate block to peers pm.BroadcastBlock(ev.Block, false) // Only then announce to the rest } } } pm.BroadcastBlock()的入参propagate为真时，向部分Peer广播完整的区块，调用peer.AsyncSendNewBlock()，否则向所有Peer广播区块头，调用peer.AsyncSendNewBlockHash()，这2个函数就是把数据放入队列，此处不再放代码。 // BroadcastBlock will either propagate a block to a subset of it&#39;s peers, or // will only announce it&#39;s availability (depending what&#39;s requested). func (pm *ProtocolManager) BroadcastBlock(block *types.Block, propagate bool) { hash := block.Hash() peers := pm.peers.PeersWithoutBlock(hash) // If propagation is requested, send to a subset of the peer // 这种情况，要把区块广播给部分peer if propagate { // Calculate the TD of the block (it&#39;s not imported yet, so block.Td is not valid) // 计算新的总难度 var td *big.Int if parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()-1); parent != nil { td = new(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()-1)) } else { log.Error(&quot;Propagating dangling block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash) return } // Send the block to a subset of our peers // 广播区块给部分peer transfer := peers[:int(math.Sqrt(float64(len(peers))))] for _, peer := range transfer { peer.AsyncSendNewBlock(block, td) } log.Trace(&quot;Propagated block&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(transfer), &quot;duration&quot;, common.PrettyDuration(time.Since(block.ReceivedAt))) return } // Otherwise if the block is indeed in out own chain, announce it // 把区块hash值广播给所有peer if pm.blockchain.HasBlock(hash, block.NumberU64()) { for _, peer := range peers { peer.AsyncSendNewBlockHash(block) } log.Trace(&quot;Announced block&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(peers), &quot;duration&quot;, common.PrettyDuration(time.Since(block.ReceivedAt))) } } peer.broadcase()是每个Peer连接的广播函数，它只广播3种消息：交易、完整的区块、区块的Hash，这样表明了节点只会主动广播这3中类型的数据，剩余的数据同步，都是通过请求-响应的方式。 // broadcast is a write loop that multiplexes block propagations, announcements // and transaction broadcasts into the remote peer. The goal is to have an async // writer that does not lock up node internals. func (p *peer) broadcast() { for { select { // 广播交易 case txs := &lt;-p.queuedTxs: if err := p.SendTransactions(txs); err != nil { return } p.Log().Trace(&quot;Broadcast transactions&quot;, &quot;count&quot;, len(txs)) // 广播完整的新区块 case prop := &lt;-p.queuedProps: if err := p.SendNewBlock(prop.block, prop.td); err != nil { return } p.Log().Trace(&quot;Propagated block&quot;, &quot;number&quot;, prop.block.Number(), &quot;hash&quot;, prop.block.Hash(), &quot;td&quot;, prop.td) // 广播区块Hash case block := &lt;-p.queuedAnns: if err := p.SendNewBlockHashes([]common.Hash{block.Hash()}, []uint64{block.NumberU64()}); err != nil { return } p.Log().Trace(&quot;Announced block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, block.Hash()) case &lt;-p.term: return } } } Peer节点处理新区块 本节介绍远端节点收到2种区块同步消息的处理，其中NewBlockMsg的处理流程比较清晰，也简洁。NewBlockHashesMsg消息的处理就绕了2绕，从总体流程图1上能看出来，它需要先从给他发送消息Peer那里获取到完整的区块，剩下的流程和NewBlockMsg又一致了。 这部分涉及的模块多，画出来有种眼花缭乱的感觉，但只要抓住上面的主线，代码看起来还是很清晰的。通过图5先看下整体流程。 消息处理的起点是ProtocolManager.handleMsg，NewBlockMsg的处理流程是蓝色标记的区域，红色区域是单独的协程，是fetcher处理队列中区块的流程，如果从队列中取出的区块是当前链需要的，校验后，调用blockchian.InsertChain()把区块插入到区块链，最后写入数据库，这是黄色部分。最后，绿色部分是NewBlockHashesMsg的处理流程，代码流程上是比较复杂的，为了能通过图描述整体流程，我把它简化掉了。 仔细看看这幅图，掌握整体的流程后，接下来看每个步骤的细节。 NewBlockMsg的处理 本节介绍节点收到完整区块的处理，流程如下： 首先进行RLP编解码，然后标记发送消息的Peer已经知道这个区块，这样本节点最后广播这个区块的Hash时，不会再发送给该Peer。 将区块存入到fetcher的队列，调用fetcher.Enqueue。 更新Peer的Head位置，然后判断本地链是否落后于Peer的链，如果是，则通过Peer更新本地链。 只看handle.Msg()的NewBlockMsg相关的部分。 case msg.Code == NewBlockMsg: // Retrieve and decode the propagated block // 收到新区块，解码，赋值接收数据 var request newBlockData if err := msg.Decode(&amp;request); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } request.Block.ReceivedAt = msg.ReceivedAt request.Block.ReceivedFrom = p // Mark the peer as owning the block and schedule it for import // 标记peer知道这个区块 p.MarkBlock(request.Block.Hash()) // 为啥要如队列？已经得到完整的区块了 // 答：存入fetcher的优先级队列，fetcher会从队列中选取当前高度需要的块 pm.fetcher.Enqueue(p.id, request.Block) // Assuming the block is importable by the peer, but possibly not yet done so, // calculate the head hash and TD that the peer truly must have. // 截止到parent区块的头和难度 var ( trueHead = request.Block.ParentHash() trueTD = new(big.Int).Sub(request.TD, request.Block.Difficulty()) ) // Update the peers total difficulty if better than the previous // 如果收到的块的难度大于peer之前的，以及自己本地的，就去和这个peer同步 // 问题：就只用了一下块里的hash指，为啥不直接使用这个块呢，如果这个块不能用，干嘛不少发送些数据，减少网络负载呢。 // 答案：实际上，这个块加入到了优先级队列中，当fetcher的loop检查到当前下一个区块的高度，正是队列中有的，则不再向peer请求 // 该区块，而是直接使用该区块，检查无误后交给block chain执行insertChain if _, td := p.Head(); trueTD.Cmp(td) &gt; 0 { p.SetHead(trueHead, trueTD) // Schedule a sync if above ours. Note, this will not fire a sync for a gap of // a singe block (as the true TD is below the propagated block), however this // scenario should easily be covered by the fetcher. currentBlock := pm.blockchain.CurrentBlock() if trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) &gt; 0 { go pm.synchronise(p) } } //------------------------ 以上 handleMsg // Enqueue tries to fill gaps the the fetcher&#39;s future import queue. // 发给inject通道，当前协程在handleMsg，通过通道发送给fetcher的协程处理 func (f *Fetcher) Enqueue(peer string, block *types.Block) error { op := &amp;inject{ origin: peer, block: block, } select { case f.inject &lt;- op: return nil case &lt;-f.quit: return errTerminated } } //------------------------ 以下 fetcher.loop处理inject部分 case op := &lt;-f.inject: // A direct block insertion was requested, try and fill any pending gaps // 区块加入队列，首先也填入未决的间距 propBroadcastInMeter.Mark(1) f.enqueue(op.origin, op.block) //------------------------ 如队列函数 // enqueue schedules a new future import operation, if the block to be imported // has not yet been seen. // 把导入的新区块放进来 func (f *Fetcher) enqueue(peer string, block *types.Block) { hash := block.Hash() // Ensure the peer isn&#39;t DOSing us // 防止peer的DOS攻击 count := f.queues[peer] + 1 if count &gt; blockLimit { log.Debug(&quot;Discarded propagated block, exceeded allowance&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;limit&quot;, blockLimit) propBroadcastDOSMeter.Mark(1) f.forgetHash(hash) return } // Discard any past or too distant blocks // 高度检查：未来太远的块丢弃 if dist := int64(block.NumberU64()) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist { log.Debug(&quot;Discarded propagated block, too far away&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;distance&quot;, dist) propBroadcastDropMeter.Mark(1) f.forgetHash(hash) return } // Schedule the block for future importing // 块先加入优先级队列，加入链之前，还有很多要做 if _, ok := f.queued[hash]; !ok { op := &amp;inject{ origin: peer, block: block, } f.queues[peer] = count f.queued[hash] = op f.queue.Push(op, -float32(block.NumberU64())) if f.queueChangeHook != nil { f.queueChangeHook(op.block.Hash(), true) } log.Debug(&quot;Queued propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;queued&quot;, f.queue.Size()) } } fetcher队列处理 本节我们看看，区块加入队列后，fetcher如何处理区块，为何不直接校验区块，插入到本地链？ 由于以太坊又Uncle的机制，节点可能收到老一点的一些区块。另外，节点可能由于网络原因，落后了几个区块，所以可能收到“未来”的一些区块，这些区块都不能直接插入到本地链。 区块入的队列是一个优先级队列，高度低的区块会被优先取出来。fetcher.loop是单独协程，不断运转，清理fecther中的事务和事件。首先会清理正在fetching的区块，但已经超时。然后处理优先级队列中的区块，判断高度是否是下一个区块，如果是则调用f.insert()函数，校验后调用BlockChain.InsertChain()，成功插入后，广播新区块的Hash。 // Loop is the main fetcher loop, checking and processing various notification // events. func (f *Fetcher) loop() { // Iterate the block fetching until a quit is requested fetchTimer := time.NewTimer(0) completeTimer := time.NewTimer(0) for { // Clean up any expired block fetches // 清理过期的区块 for hash, announce := range f.fetching { if time.Since(announce.time) &gt; fetchTimeout { f.forgetHash(hash) } } // Import any queued blocks that could potentially fit // 导入队列中合适的块 height := f.chainHeight() for !f.queue.Empty() { op := f.queue.PopItem().(*inject) hash := op.block.Hash() if f.queueChangeHook != nil { f.queueChangeHook(hash, false) } // If too high up the chain or phase, continue later // 块不是链需要的下一个块，再入优先级队列，停止循环 number := op.block.NumberU64() if number &gt; height+1 { f.queue.Push(op, -float32(number)) if f.queueChangeHook != nil { f.queueChangeHook(hash, true) } break } // Otherwise if fresh and still unknown, try and import // 高度正好是我们想要的，并且链上也没有这个块 if number+maxUncleDist &lt; height || f.getBlock(hash) != nil { f.forgetBlock(hash) continue } // 那么，块插入链 f.insert(op.origin, op.block) } //省略 } } func (f *Fetcher) insert(peer string, block *types.Block) { hash := block.Hash() // Run the import on a new thread log.Debug(&quot;Importing propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash) go func() { defer func() { f.done &lt;- hash }() // If the parent&#39;s unknown, abort insertion parent := f.getBlock(block.ParentHash()) if parent == nil { log.Debug(&quot;Unknown parent of propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;parent&quot;, block.ParentHash()) return } // Quickly validate the header and propagate the block if it passes // 验证区块头，成功后广播区块 switch err := f.verifyHeader(block.Header()); err { case nil: // All ok, quickly propagate to our peers propBroadcastOutTimer.UpdateSince(block.ReceivedAt) go f.broadcastBlock(block, true) case consensus.ErrFutureBlock: // Weird future block, don&#39;t fail, but neither propagate default: // Something went very wrong, drop the peer log.Debug(&quot;Propagated block verification failed&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;err&quot;, err) f.dropPeer(peer) return } // Run the actual import and log any issues // 调用回调函数，实际是blockChain.insertChain if _, err := f.insertChain(types.Blocks{block}); err != nil { log.Debug(&quot;Propagated block import failed&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;err&quot;, err) return } // If import succeeded, broadcast the block propAnnounceOutTimer.UpdateSince(block.ReceivedAt) go f.broadcastBlock(block, false) // Invoke the testing hook if needed if f.importedHook != nil { f.importedHook(block) } }() } NewBlockHashesMsg的处理 本节介绍NewBlockHashesMsg的处理，其实，消息处理是简单的，而复杂一点的是从Peer哪获取完整的区块，下节再看。 流程如下: 对消息进行RLP解码，然后标记Peer已经知道此区块。 寻找出本地区块链不存在的区块Hash值，把这些未知的Hash通知给fetcher。 fetcher.Notify记录好通知信息，塞入notify通道，以便交给fetcher的协程。 fetcher.loop()会对notify中的消息进行处理，确认区块并非DOS攻击，然后检查区块的高度，判断该区块是否已经在fetching或者comleting(代表已经下载区块头，在下载body)，如果都没有，则加入到announced中，触发0s定时器，进行处理。 关于announced下节再介绍。 // handleMsg()部分 case msg.Code == NewBlockHashesMsg: var announces newBlockHashesData if err := msg.Decode(&amp;announces); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } // Mark the hashes as present at the remote node for _, block := range announces { p.MarkBlock(block.Hash) } // Schedule all the unknown hashes for retrieval // 把本地链没有的块hash找出来，交给fetcher去下载 unknown := make(newBlockHashesData, 0, len(announces)) for _, block := range announces { if !pm.blockchain.HasBlock(block.Hash, block.Number) { unknown = append(unknown, block) } } for _, block := range unknown { pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies) } // Notify announces the fetcher of the potential availability of a new block in // the network. // 通知fetcher（自己）有新块产生，没有块实体，有hash、高度等信息 func (f *Fetcher) Notify(peer string, hash common.Hash, number uint64, time time.Time, headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn) error { block := &amp;announce{ hash: hash, number: number, time: time, origin: peer, fetchHeader: headerFetcher, fetchBodies: bodyFetcher, } select { case f.notify &lt;- block: return nil case &lt;-f.quit: return errTerminated } } // fetcher.loop()的notify通道消息处理 case notification := &lt;-f.notify: // A block was announced, make sure the peer isn&#39;t DOSing us propAnnounceInMeter.Mark(1) count := f.announces[notification.origin] + 1 if count &gt; hashLimit { log.Debug(&quot;Peer exceeded outstanding announces&quot;, &quot;peer&quot;, notification.origin, &quot;limit&quot;, hashLimit) propAnnounceDOSMeter.Mark(1) break } // If we have a valid block number, check that it&#39;s potentially useful // 高度检查 if notification.number &gt; 0 { if dist := int64(notification.number) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist { log.Debug(&quot;Peer discarded announcement&quot;, &quot;peer&quot;, notification.origin, &quot;number&quot;, notification.number, &quot;hash&quot;, notification.hash, &quot;distance&quot;, dist) propAnnounceDropMeter.Mark(1) break } } // All is well, schedule the announce if block&#39;s not yet downloading // 检查是否已经在下载，已下载则忽略 if _, ok := f.fetching[notification.hash]; ok { break } if _, ok := f.completing[notification.hash]; ok { break } // 更新peer已经通知给我们的区块数量 f.announces[notification.origin] = count // 把通知信息加入到announced，供调度 f.announced[notification.hash] = append(f.announced[notification.hash], notification) if f.announceChangeHook != nil &amp;&amp; len(f.announced[notification.hash]) == 1 { f.announceChangeHook(notification.hash, true) } if len(f.announced) == 1 { // 有通知放入到announced，则重设0s定时器，loop的另外一个分支会处理这些通知 f.rescheduleFetch(fetchTimer) } fetcher获取完整区块 本节介绍fetcher获取完整区块的过程，这也是fetcher最重要的功能，会涉及到fetcher至少80%的代码。单独拉放一大节吧。 Fetcher的大头 Fetcher最主要的功能就是获取完整的区块，然后在合适的实际交给InsertChain去验证和插入到本地区块链。我们还是从宏观入手，看Fetcher是如何工作的，一定要先掌握好宏观，因为代码层面上没有这么清晰。 宏观 首先，看两个节点是如何交互，获取完整区块，使用时序图的方式看一下，见图6，流程很清晰不再文字介绍。 再看下获取区块过程中，fetcher内部的状态转移，它使用状态来记录，要获取的区块在什么阶段，见图7。我稍微解释一下： 收到NewBlockHashesMsg后，相关信息会记录到announced，进入announced状态，代表了本节点接收了消息。 announced由fetcher协程处理，经过校验后，会向给他发送消息的Peer发送请求，请求该区块的区块头，然后进入fetching状态。 获取区块头后，如果区块头表示没有交易和uncle，则转移到completing状态，并且使用区块头合成完整的区块，加入到queued优先级队列。 获取区块头后，如果区块头表示该区块有交易和uncle，则转移到fetched状态，然后发送请求，请求交易和uncle，然后转移到completing状态。 收到交易和uncle后，使用头、交易、uncle这3个信息，生成完整的区块，加入到队列queued。 微观 接下来就是从代码角度看如何获取完整区块的流程了，有点多，看不懂的时候，再回顾下上面宏观的介绍图。 首先看Fetcher的定义，它存放了通信数据和状态管理，捡加注释的看，上文提到的状态，里面都有。 // Fetcher is responsible for accumulating block announcements from various peers // and scheduling them for retrieval. // 积累块通知，然后调度获取这些块 type Fetcher struct { // Various event channels // 收到区块hash值的通道 notify chan *announce // 收到完整区块的通道 inject chan *inject blockFilter chan chan []*types.Block // 过滤header的通道的通道 headerFilter chan chan *headerFilterTask // 过滤body的通道的通道 bodyFilter chan chan *bodyFilterTask done chan common.Hash quit chan struct{} // Announce states // Peer已经给了本节点多少区块头通知 announces map[string]int // Per peer announce counts to prevent memory exhaustion // 已经announced的区块列表 announced map[common.Hash][]*announce // Announced blocks, scheduled for fetching // 正在fetching区块头的请求 fetching map[common.Hash]*announce // Announced blocks, currently fetching // 已经fetch到区块头，还差body的请求，用来获取body fetched map[common.Hash][]*announce // Blocks with headers fetched, scheduled for body retrieval // 已经得到区块头的 completing map[common.Hash]*announce // Blocks with headers, currently body-completing // Block cache // queue，优先级队列，高度做优先级 // queues，统计peer通告了多少块 // queued，代表这个块如队列了， queue *prque.Prque // Queue containing the import operations (block number sorted) queues map[string]int // Per peer block counts to prevent memory exhaustion queued map[common.Hash]*inject // Set of already queued blocks (to dedupe imports) // Callbacks getBlock blockRetrievalFn // Retrieves a block from the local chain verifyHeader headerVerifierFn // Checks if a block&#39;s headers have a valid proof of work，验证区块头，包含了PoW验证 broadcastBlock blockBroadcasterFn // Broadcasts a block to connected peers，广播给peer chainHeight chainHeightFn // Retrieves the current chain&#39;s height insertChain chainInsertFn // Injects a batch of blocks into the chain，插入区块到链的函数 dropPeer peerDropFn // Drops a peer for misbehaving // Testing hooks announceChangeHook func(common.Hash, bool) // Method to call upon adding or deleting a hash from the announce list queueChangeHook func(common.Hash, bool) // Method to call upon adding or deleting a block from the import queue fetchingHook func([]common.Hash) // Method to call upon starting a block (eth/61) or header (eth/62) fetch completingHook func([]common.Hash) // Method to call upon starting a block body fetch (eth/62) importedHook func(*types.Block) // Method to call upon successful block import (both eth/61 and eth/62) } NewBlockHashesMsg消息的处理前面的小节已经讲过了，不记得可向前翻看。这里从announced的状态处理说起。loop()中，fetchTimer超时后，代表了收到了消息通知，需要处理，会从announced中选择出需要处理的通知，然后创建请求，请求区块头，由于可能有很多节点都通知了它某个区块的Hash，所以随机的从这些发送消息的Peer中选择一个Peer，发送请求的时候，为每个Peer都创建了单独的协程。 case &lt;-fetchTimer.C: // At least one block&#39;s timer ran out, check for needing retrieval // 有区块通知，去处理 request := make(map[string][]common.Hash) for hash, announces := range f.announced { if time.Since(announces[0].time) &gt; arriveTimeout-gatherSlack { // Pick a random peer to retrieve from, reset all others // 可能有很多peer都发送了这个区块的hash值，随机选择一个peer announce := announces[rand.Intn(len(announces))] f.forgetHash(hash) // If the block still didn&#39;t arrive, queue for fetching // 本地还没有这个区块，创建获取区块的请求 if f.getBlock(hash) == nil { request[announce.origin] = append(request[announce.origin], hash) f.fetching[hash] = announce } } } // Send out all block header requests // 把所有的request发送出去 // 为每一个peer都创建一个协程，然后请求所有需要从该peer获取的请求 for peer, hashes := range request { log.Trace(&quot;Fetching scheduled headers&quot;, &quot;peer&quot;, peer, &quot;list&quot;, hashes) // Create a closure of the fetch and schedule in on a new thread fetchHeader, hashes := f.fetching[hashes[0]].fetchHeader, hashes go func() { if f.fetchingHook != nil { f.fetchingHook(hashes) } for _, hash := range hashes { headerFetchMeter.Mark(1) fetchHeader(hash) // Suboptimal, but protocol doesn&#39;t allow batch header retrievals } }() } // Schedule the next fetch if blocks are still pending f.rescheduleFetch(fetchTimer) 从Notify的调用中，可以看出，fetcherHeader()的实际函数是RequestOneHeader()，该函数使用的消息是GetBlockHeadersMsg，可以用来请求多个区块头，不过fetcher只请求一个。 pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies) // RequestOneHeader is a wrapper around the header query functions to fetch a // single header. It is used solely by the fetcher. func (p *peer) RequestOneHeader(hash common.Hash) error { p.Log().Debug(&quot;Fetching single header&quot;, &quot;hash&quot;, hash) return p2p.Send(p.rw, GetBlockHeadersMsg, &amp;getBlockHeadersData{Origin: hashOrNumber{Hash: hash}, Amount: uint64(1), Skip: uint64(0), Reverse: false}) } GetBlockHeadersMsg的处理如下：因为它是获取多个区块头的，所以处理起来比较“麻烦”，还好，fetcher只获取一个区块头，其处理在20行~33行，获取下一个区块头的处理逻辑，这里就不看了，最后调用SendBlockHeaders()将区块头发送给请求的节点，消息是BlockHeadersMsg。 // handleMsg() // Block header query, collect the requested headers and reply case msg.Code == GetBlockHeadersMsg: // Decode the complex header query var query getBlockHeadersData if err := msg.Decode(&amp;query); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } hashMode := query.Origin.Hash != (common.Hash{}) // Gather headers until the fetch or network limits is reached // 收集区块头，直到达到限制 var ( bytes common.StorageSize headers []*types.Header unknown bool ) // 自己已知区块 &amp;&amp; 少于查询的数量 &amp;&amp; 大小小于2MB &amp;&amp; 小于能下载的最大数量 for !unknown &amp;&amp; len(headers) &lt; int(query.Amount) &amp;&amp; bytes &lt; softResponseLimit &amp;&amp; len(headers) &lt; downloader.MaxHeaderFetch { // Retrieve the next header satisfying the query // 获取区块头 var origin *types.Header if hashMode { // fetcher 使用的模式 origin = pm.blockchain.GetHeaderByHash(query.Origin.Hash) } else { origin = pm.blockchain.GetHeaderByNumber(query.Origin.Number) } if origin == nil { break } number := origin.Number.Uint64() headers = append(headers, origin) bytes += estHeaderRlpSize // Advance to the next header of the query // 下一个区块头的获取，不同策略，方式不同 switch { case query.Origin.Hash != (common.Hash{}) &amp;&amp; query.Reverse: // ... } } return p.SendBlockHeaders(headers) BlockHeadersMsg的处理很有意思，因为GetBlockHeadersMsg并不是fetcher独占的消息，downloader也可以调用，所以，响应消息的处理需要分辨出是fetcher请求的，还是downloader请求的。它的处理逻辑是：fetcher先过滤收到的区块头，如果fetcher不要的，那就是downloader的，在调用fetcher.FilterHeaders的时候，fetcher就将自己要的区块头拿走了。 // handleMsg() case msg.Code == BlockHeadersMsg: // A batch of headers arrived to one of our previous requests var headers []*types.Header if err := msg.Decode(&amp;headers); err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // If no headers were received, but we&#39;re expending a DAO fork check, maybe it&#39;s that // 检查是不是当前DAO的硬分叉 if len(headers) == 0 &amp;&amp; p.forkDrop != nil { // Possibly an empty reply to the fork header checks, sanity check TDs verifyDAO := true // If we already have a DAO header, we can check the peer&#39;s TD against it. If // the peer&#39;s ahead of this, it too must have a reply to the DAO check if daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != nil { if _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= 0 { verifyDAO = false } } // If we&#39;re seemingly on the same chain, disable the drop timer if verifyDAO { p.Log().Debug(&quot;Seems to be on the same side of the DAO fork&quot;) p.forkDrop.Stop() p.forkDrop = nil return nil } } // Filter out any explicitly requested headers, deliver the rest to the downloader // 过滤是不是fetcher请求的区块头，去掉fetcher请求的区块头再交给downloader filter := len(headers) == 1 if filter { // If it&#39;s a potential DAO fork check, validate against the rules // 检查是否硬分叉 if p.forkDrop != nil &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[0].Number) == 0 { // Disable the fork drop timer p.forkDrop.Stop() p.forkDrop = nil // Validate the header and either drop the peer or continue if err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[0]); err != nil { p.Log().Debug(&quot;Verified to be on the other side of the DAO fork, dropping&quot;) return err } p.Log().Debug(&quot;Verified to be on the same side of the DAO fork&quot;) return nil } // Irrelevant of the fork checks, send the header to the fetcher just in case // 使用fetcher过滤区块头 headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now()) } // 剩下的区块头交给downloader if len(headers) &gt; 0 || !filter { err := pm.downloader.DeliverHeaders(p.id, headers) if err != nil { log.Debug(&quot;Failed to deliver headers&quot;, &quot;err&quot;, err) } } FilterHeaders()是一个很有大智慧的函数，看起来耐人寻味，但实在妙。它要把所有的区块头，都传递给fetcher协程，还要获取fetcher协程处理后的结果。fetcher.headerFilter是存放通道的通道，而filter是存放包含区块头过滤任务的通道。它先把filter传递给了headerFilter，这样fetcher协程就在另外一段等待了，而后将headerFilterTask传入filter，fetcher就能读到数据了，处理后，再将数据写回filter而刚好被FilterHeaders函数处理了，该函数实际运行在handleMsg()的协程中。 每个Peer都会分配一个ProtocolManager然后处理该Peer的消息，但fetcher只有一个事件处理协程，如果不创建一个filter，fetcher哪知道是谁发给它的区块头呢？过滤之后，该如何发回去呢？ // FilterHeaders extracts all the headers that were explicitly requested by the fetcher, // returning those that should be handled differently. // 寻找出fetcher请求的区块头 func (f *Fetcher) FilterHeaders(peer string, headers []*types.Header, time time.Time) []*types.Header { log.Trace(&quot;Filtering headers&quot;, &quot;peer&quot;, peer, &quot;headers&quot;, len(headers)) // Send the filter channel to the fetcher // 任务通道 filter := make(chan *headerFilterTask) select { // 任务通道发送到这个通道 case f.headerFilter &lt;- filter: case &lt;-f.quit: return nil } // Request the filtering of the header list // 创建过滤任务，发送到任务通道 select { case filter &lt;- &amp;headerFilterTask{peer: peer, headers: headers, time: time}: case &lt;-f.quit: return nil } // Retrieve the headers remaining after filtering // 从任务通道，获取过滤的结果并返回 select { case task := &lt;-filter: return task.headers case &lt;-f.quit: return nil } } 接下来要看f.headerFilter的处理，这段代码有90行，它做了一下几件事： 从f.headerFilter取出filter，然后取出过滤任务task。 它把区块头分成3类：unknown这不是分是要返回给调用者的，即handleMsg(), incomplete存放还需要获取body的区块头，complete存放只包含区块头的区块。遍历所有的区块头，填到到对应的分类中，具体的判断可看18行的注释，记住宏观中将的状态转移图。 把unknonw中的区块返回给handleMsg()。 把 incomplete的区块头获取状态移动到fetched状态，然后触发定时器，以便去处理complete的区块。 把compelete的区块加入到queued。 // fetcher.loop() case filter := &lt;-f.headerFilter: // Headers arrived from a remote peer. Extract those that were explicitly // requested by the fetcher, and return everything else so it&#39;s delivered // to other parts of the system. // 收到从远端节点发送的区块头，过滤出fetcher请求的 // 从任务通道获取过滤任务 var task *headerFilterTask select { case task = &lt;-filter: case &lt;-f.quit: return } headerFilterInMeter.Mark(int64(len(task.headers))) // Split the batch of headers into unknown ones (to return to the caller), // known incomplete ones (requiring body retrievals) and completed blocks. // unknown的不是fetcher请求的，complete放没有交易和uncle的区块，有头就够了，incomplete放 // 还需要获取uncle和交易的区块 unknown, incomplete, complete := []*types.Header{}, []*announce{}, []*types.Block{} // 遍历所有收到的header for _, header := range task.headers { hash := header.Hash() // Filter fetcher-requested headers from other synchronisation algorithms // 是正在获取的hash，并且对应请求的peer，并且未fetched，未completing，未queued if announce := f.fetching[hash]; announce != nil &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == nil &amp;&amp; f.completing[hash] == nil &amp;&amp; f.queued[hash] == nil { // If the delivered header does not match the promised number, drop the announcer // 高度校验，竟然不匹配，扰乱秩序，peer肯定是坏蛋。 if header.Number.Uint64() != announce.number { log.Trace(&quot;Invalid block number fetched&quot;, &quot;peer&quot;, announce.origin, &quot;hash&quot;, header.Hash(), &quot;announced&quot;, announce.number, &quot;provided&quot;, header.Number) f.dropPeer(announce.origin) f.forgetHash(hash) continue } // Only keep if not imported by other means // 本地链没有当前区块 if f.getBlock(hash) == nil { announce.header = header announce.time = task.time // If the block is empty (header only), short circuit into the final import queue // 如果区块没有交易和uncle，加入到complete if header.TxHash == types.DeriveSha(types.Transactions{}) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header{}) { log.Trace(&quot;Block empty, skipping body retrieval&quot;, &quot;peer&quot;, announce.origin, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash()) block := types.NewBlockWithHeader(header) block.ReceivedAt = task.time complete = append(complete, block) f.completing[hash] = announce continue } // Otherwise add to the list of blocks needing completion // 否则就是不完整的区块 incomplete = append(incomplete, announce) } else { log.Trace(&quot;Block already imported, discarding header&quot;, &quot;peer&quot;, announce.origin, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash()) f.forgetHash(hash) } } else { // Fetcher doesn&#39;t know about it, add to the return list // 没请求过的header unknown = append(unknown, header) } } // 把未知的区块头，再传递会filter headerFilterOutMeter.Mark(int64(len(unknown))) select { case filter &lt;- &amp;headerFilterTask{headers: unknown, time: task.time}: case &lt;-f.quit: return } // Schedule the retrieved headers for body completion // 把未完整的区块加入到fetched，跳过已经在completeing中的，然后触发completeTimer定时器 for _, announce := range incomplete { hash := announce.header.Hash() if _, ok := f.completing[hash]; ok { continue } f.fetched[hash] = append(f.fetched[hash], announce) if len(f.fetched) == 1 { f.rescheduleComplete(completeTimer) } } // Schedule the header-only blocks for import // 把只有头的区块入队列 for _, block := range complete { if announce := f.completing[block.Hash()]; announce != nil { f.enqueue(announce.origin, block) } } 跟随状态图的转义，剩下的工作是fetched转移到completing，上面的流程已经触发了completeTimer定时器，超时后就会处理，流程与请求Header类似，不再赘述，此时发送的请求消息是GetBlockBodiesMsg，实际调的函数是RequestBodies。 // fetcher.loop() case &lt;-completeTimer.C: // At least one header&#39;s timer ran out, retrieve everything // 至少有1个header已经获取完了 request := make(map[string][]common.Hash) // 遍历所有待获取body的announce for hash, announces := range f.fetched { // Pick a random peer to retrieve from, reset all others // 随机选一个Peer发送请求，因为可能已经有很多Peer通知它这个区块了 announce := announces[rand.Intn(len(announces))] f.forgetHash(hash) // If the block still didn&#39;t arrive, queue for completion // 如果本地没有这个区块，则放入到completing，创建请求 if f.getBlock(hash) == nil { request[announce.origin] = append(request[announce.origin], hash) f.completing[hash] = announce } } // Send out all block body requests // 发送所有的请求，获取body，依然是每个peer一个单独协程 for peer, hashes := range request { log.Trace(&quot;Fetching scheduled bodies&quot;, &quot;peer&quot;, peer, &quot;list&quot;, hashes) // Create a closure of the fetch and schedule in on a new thread if f.completingHook != nil { f.completingHook(hashes) } bodyFetchMeter.Mark(int64(len(hashes))) go f.completing[hashes[0]].fetchBodies(hashes) } // Schedule the next fetch if blocks are still pending f.rescheduleComplete(completeTimer) handleMsg()处理该消息也是干净利落，直接获取RLP格式的body，然后发送响应消息。 // handleMsg() case msg.Code == GetBlockBodiesMsg: // Decode the retrieval message msgStream := rlp.NewStream(msg.Payload, uint64(msg.Size)) if _, err := msgStream.List(); err != nil { return err } // Gather blocks until the fetch or network limits is reached var ( hash common.Hash bytes int bodies []rlp.RawValue ) // 遍历所有请求 for bytes &lt; softResponseLimit &amp;&amp; len(bodies) &lt; downloader.MaxBlockFetch { // Retrieve the hash of the next block if err := msgStream.Decode(&amp;hash); err == rlp.EOL { break } else if err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // Retrieve the requested block body, stopping if enough was found // 获取body，RLP格式 if data := pm.blockchain.GetBodyRLP(hash); len(data) != 0 { bodies = append(bodies, data) bytes += len(data) } } return p.SendBlockBodiesRLP(bodies) 响应消息BlockBodiesMsg的处理与处理获取header的处理原理相同，先交给fetcher过滤，然后剩下的才是downloader的。需要注意一点，响应消息里只包含交易列表和叔块列表。 // handleMsg() case msg.Code == BlockBodiesMsg: // A batch of block bodies arrived to one of our previous requests var request blockBodiesData if err := msg.Decode(&amp;request); err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // Deliver them all to the downloader for queuing // 传递给downloader去处理 transactions := make([][]*types.Transaction, len(request)) uncles := make([][]*types.Header, len(request)) for i, body := range request { transactions[i] = body.Transactions uncles[i] = body.Uncles } // Filter out any explicitly requested bodies, deliver the rest to the downloader // 先让fetcher过滤去fetcher请求的body，剩下的给downloader filter := len(transactions) &gt; 0 || len(uncles) &gt; 0 if filter { transactions, uncles = pm.fetcher.FilterBodies(p.id, transactions, uncles, time.Now()) } // 剩下的body交给downloader if len(transactions) &gt; 0 || len(uncles) &gt; 0 || !filter { err := pm.downloader.DeliverBodies(p.id, transactions, uncles) if err != nil { log.Debug(&quot;Failed to deliver bodies&quot;, &quot;err&quot;, err) } } 过滤函数的原理也与Header相同。 // FilterBodies extracts all the block bodies that were explicitly requested by // the fetcher, returning those that should be handled differently. // 过去出fetcher请求的body，返回它没有处理的，过程类型header的处理 func (f *Fetcher) FilterBodies(peer string, transactions [][]*types.Transaction, uncles [][]*types.Header, time time.Time) ([][]*types.Transaction, [][]*types.Header) { log.Trace(&quot;Filtering bodies&quot;, &quot;peer&quot;, peer, &quot;txs&quot;, len(transactions), &quot;uncles&quot;, len(uncles)) // Send the filter channel to the fetcher filter := make(chan *bodyFilterTask) select { case f.bodyFilter &lt;- filter: case &lt;-f.quit: return nil, nil } // Request the filtering of the body list select { case filter &lt;- &amp;bodyFilterTask{peer: peer, transactions: transactions, uncles: uncles, time: time}: case &lt;-f.quit: return nil, nil } // Retrieve the bodies remaining after filtering select { case task := &lt;-filter: return task.transactions, task.uncles case &lt;-f.quit: return nil, nil } } 实际过滤body的处理瞧一下，这和Header的处理是不同的。直接看不点： 它要的区块，单独取出来存到blocks中，它不要的继续留在task中。 判断是不是fetcher请求的方法：如果交易列表和叔块列表计算出的hash值与区块头中的一样，并且消息来自请求的Peer，则就是fetcher请求的。 将blocks中的区块加入到queued，终结。 case filter := &lt;-f.bodyFilter: // Block bodies arrived, extract any explicitly requested blocks, return the rest var task *bodyFilterTask select { case task = &lt;-filter: case &lt;-f.quit: return } bodyFilterInMeter.Mark(int64(len(task.transactions))) blocks := []*types.Block{} // 获取的每个body的txs列表和uncle列表 // 遍历每个区块的txs列表和uncle列表，计算hash后判断是否是当前fetcher请求的body for i := 0; i &lt; len(task.transactions) &amp;&amp; i &lt; len(task.uncles); i++ { // Match up a body to any possible completion request matched := false // 遍历所有保存的请求，因为tx和uncle，不知道它是属于哪个区块的，只能去遍历所有的请求，通常量不大，所以遍历没有性能影响 for hash, announce := range f.completing { if f.queued[hash] == nil { // 把传入的每个块的hash和unclehash和它请求出去的记录进行对比，匹配则说明是fetcher请求的区块body txnHash := types.DeriveSha(types.Transactions(task.transactions[i])) uncleHash := types.CalcUncleHash(task.uncles[i]) if txnHash == announce.header.TxHash &amp;&amp; uncleHash == announce.header.UncleHash &amp;&amp; announce.origin == task.peer { // Mark the body matched, reassemble if still unknown matched = true // 如果当前链还没有这个区块，则收集这个区块，合并成新区块 if f.getBlock(hash) == nil { block := types.NewBlockWithHeader(announce.header).WithBody(task.transactions[i], task.uncles[i]) block.ReceivedAt = task.time blocks = append(blocks, block) } else { f.forgetHash(hash) } } } } // 从task中移除fetcher请求的数据 if matched { task.transactions = append(task.transactions[:i], task.transactions[i+1:]...) task.uncles = append(task.uncles[:i], task.uncles[i+1:]...) i-- continue } } // 将剩余的数据返回 bodyFilterOutMeter.Mark(int64(len(task.transactions))) select { case filter &lt;- task: case &lt;-f.quit: return } // Schedule the retrieved blocks for ordered import // 把收集的区块加入到队列 for _, block := range blocks { if announce := f.completing[block.Hash()]; announce != nil { f.enqueue(announce.origin, block) } } } 至此，fetcher获取完整区块的流程讲完了，fetcher模块中80%的代码也都贴出来了，还有2个值得看看的函数： forgetHash(hash common.Hash)：用于清空指定hash指的记/状态录信息。 forgetBlock(hash common.Hash)：用于从队列中移除一个区块。 最后了，再回到开始看看fetcher模块和新区块的传播流程，有没有豁然开朗。 如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。 本文作者：大彬 如果喜欢本文，随意转载，但请保留此原文链接：http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/" />
<meta property="og:description" content="版权声明：版权归lessisbetter.site所有，转载请请声明 https://blog.csdn.net/m0_43499523/article/details/85852204 前言 这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。 当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。 总体过程和传播策略 本节从宏观角度介绍，节点产生区块后，为了传播给远端节点做了啥，远端节点收到区块后又做了什么，每个节点都连接了很多Peer，它传播的策略是什么样的？ 总体流程和策略可以总结为，传播给远端Peer节点，Peer验证区块无误后，加入到本地区块链，继续传播新区块信息。具体过程如下。 先看总体过程。产生区块后，miner模块会发布一个事件NewMinedBlockEvent，订阅事件的协程收到事件后，就会把新区块的消息，广播给它所有的peer，peer收到消息后，会交给自己的fetcher模块处理，fetcher进行基本的验证后，区块没问题，发现这个区块就是本地链需要的下一个区块，则交给blockChain进一步进行完整的验证，这个过程会执行区块所有的交易，无误后把区块加入到本地链，写入数据库，这个过程就是下面的流程图，图1。 总体流程图，能看到有个分叉，是因为节点传播新区块是有策略的。它的传播策略为： 假如节点连接了N个Peer，它只向Peer列表的sqrt(N)个Peer广播完整的区块消息。 向所有的Peer广播只包含区块Hash的消息。 策略图的效果如图2，红色节点将区块传播给黄色节点： 收到区块Hash的节点，需要从发送给它消息的Peer那里获取对应的完整区块，获取区块后就会按照图1的流程，加入到fetcher队列，最终插入本地区块链后，将区块的Hash值广播给和它相连，但还不知道这个区块的Peer。非产生区块节点的策略图，如图3，黄色节点将区块Hash传播给青色节点： 至此，可以看出以太坊采用以石击水的方式，像水纹一样，层层扩散新产生的区块。 Fetcher模块是干啥的 fetcher模块的功能，就是收集其他Peer通知它的区块信息：1）完整的区块2）区块Hash消息。根据通知的消息，获取完整的区块，然后传递给eth模块把区块插入区块链。 如果是完整区块，就可以传递给eth插入区块，如果只有区块Hash，则需要从其他的Peer获取此完整的区块，然后再传递给eth插入区块。 源码解读 本节介绍区块传播和处理的细节东西，方式仍然是先用图解释流程，再是代码流程。 产块节点的传播新区块 节点产生区块后，广播的流程可以表示为图4： 发布事件 事件处理函数选择要广播完整的Peer，然后将区块加入到它们的队列 事件处理函数把区块Hash添加到所有Peer的另外一个通知队列 每个Peer的广播处理函数，会遍历它的待广播区块队列和通知队列，把数据封装成消息，调用P2P接口发送出去 再看下代码上的细节。 worker.wait()函数发布事件NewMinedBlockEvent。 ProtocolManager.minedBroadcastLoop()是事件处理函数。它调用了2次pm.BroadcastBlock()。 // Mined broadcast loop func (pm *ProtocolManager) minedBroadcastLoop() { // automatically stops if unsubscribe for obj := range pm.minedBlockSub.Chan() { switch ev := obj.Data.(type) { case core.NewMinedBlockEvent: pm.BroadcastBlock(ev.Block, true) // First propagate block to peers pm.BroadcastBlock(ev.Block, false) // Only then announce to the rest } } } pm.BroadcastBlock()的入参propagate为真时，向部分Peer广播完整的区块，调用peer.AsyncSendNewBlock()，否则向所有Peer广播区块头，调用peer.AsyncSendNewBlockHash()，这2个函数就是把数据放入队列，此处不再放代码。 // BroadcastBlock will either propagate a block to a subset of it&#39;s peers, or // will only announce it&#39;s availability (depending what&#39;s requested). func (pm *ProtocolManager) BroadcastBlock(block *types.Block, propagate bool) { hash := block.Hash() peers := pm.peers.PeersWithoutBlock(hash) // If propagation is requested, send to a subset of the peer // 这种情况，要把区块广播给部分peer if propagate { // Calculate the TD of the block (it&#39;s not imported yet, so block.Td is not valid) // 计算新的总难度 var td *big.Int if parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()-1); parent != nil { td = new(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()-1)) } else { log.Error(&quot;Propagating dangling block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash) return } // Send the block to a subset of our peers // 广播区块给部分peer transfer := peers[:int(math.Sqrt(float64(len(peers))))] for _, peer := range transfer { peer.AsyncSendNewBlock(block, td) } log.Trace(&quot;Propagated block&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(transfer), &quot;duration&quot;, common.PrettyDuration(time.Since(block.ReceivedAt))) return } // Otherwise if the block is indeed in out own chain, announce it // 把区块hash值广播给所有peer if pm.blockchain.HasBlock(hash, block.NumberU64()) { for _, peer := range peers { peer.AsyncSendNewBlockHash(block) } log.Trace(&quot;Announced block&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(peers), &quot;duration&quot;, common.PrettyDuration(time.Since(block.ReceivedAt))) } } peer.broadcase()是每个Peer连接的广播函数，它只广播3种消息：交易、完整的区块、区块的Hash，这样表明了节点只会主动广播这3中类型的数据，剩余的数据同步，都是通过请求-响应的方式。 // broadcast is a write loop that multiplexes block propagations, announcements // and transaction broadcasts into the remote peer. The goal is to have an async // writer that does not lock up node internals. func (p *peer) broadcast() { for { select { // 广播交易 case txs := &lt;-p.queuedTxs: if err := p.SendTransactions(txs); err != nil { return } p.Log().Trace(&quot;Broadcast transactions&quot;, &quot;count&quot;, len(txs)) // 广播完整的新区块 case prop := &lt;-p.queuedProps: if err := p.SendNewBlock(prop.block, prop.td); err != nil { return } p.Log().Trace(&quot;Propagated block&quot;, &quot;number&quot;, prop.block.Number(), &quot;hash&quot;, prop.block.Hash(), &quot;td&quot;, prop.td) // 广播区块Hash case block := &lt;-p.queuedAnns: if err := p.SendNewBlockHashes([]common.Hash{block.Hash()}, []uint64{block.NumberU64()}); err != nil { return } p.Log().Trace(&quot;Announced block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, block.Hash()) case &lt;-p.term: return } } } Peer节点处理新区块 本节介绍远端节点收到2种区块同步消息的处理，其中NewBlockMsg的处理流程比较清晰，也简洁。NewBlockHashesMsg消息的处理就绕了2绕，从总体流程图1上能看出来，它需要先从给他发送消息Peer那里获取到完整的区块，剩下的流程和NewBlockMsg又一致了。 这部分涉及的模块多，画出来有种眼花缭乱的感觉，但只要抓住上面的主线，代码看起来还是很清晰的。通过图5先看下整体流程。 消息处理的起点是ProtocolManager.handleMsg，NewBlockMsg的处理流程是蓝色标记的区域，红色区域是单独的协程，是fetcher处理队列中区块的流程，如果从队列中取出的区块是当前链需要的，校验后，调用blockchian.InsertChain()把区块插入到区块链，最后写入数据库，这是黄色部分。最后，绿色部分是NewBlockHashesMsg的处理流程，代码流程上是比较复杂的，为了能通过图描述整体流程，我把它简化掉了。 仔细看看这幅图，掌握整体的流程后，接下来看每个步骤的细节。 NewBlockMsg的处理 本节介绍节点收到完整区块的处理，流程如下： 首先进行RLP编解码，然后标记发送消息的Peer已经知道这个区块，这样本节点最后广播这个区块的Hash时，不会再发送给该Peer。 将区块存入到fetcher的队列，调用fetcher.Enqueue。 更新Peer的Head位置，然后判断本地链是否落后于Peer的链，如果是，则通过Peer更新本地链。 只看handle.Msg()的NewBlockMsg相关的部分。 case msg.Code == NewBlockMsg: // Retrieve and decode the propagated block // 收到新区块，解码，赋值接收数据 var request newBlockData if err := msg.Decode(&amp;request); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } request.Block.ReceivedAt = msg.ReceivedAt request.Block.ReceivedFrom = p // Mark the peer as owning the block and schedule it for import // 标记peer知道这个区块 p.MarkBlock(request.Block.Hash()) // 为啥要如队列？已经得到完整的区块了 // 答：存入fetcher的优先级队列，fetcher会从队列中选取当前高度需要的块 pm.fetcher.Enqueue(p.id, request.Block) // Assuming the block is importable by the peer, but possibly not yet done so, // calculate the head hash and TD that the peer truly must have. // 截止到parent区块的头和难度 var ( trueHead = request.Block.ParentHash() trueTD = new(big.Int).Sub(request.TD, request.Block.Difficulty()) ) // Update the peers total difficulty if better than the previous // 如果收到的块的难度大于peer之前的，以及自己本地的，就去和这个peer同步 // 问题：就只用了一下块里的hash指，为啥不直接使用这个块呢，如果这个块不能用，干嘛不少发送些数据，减少网络负载呢。 // 答案：实际上，这个块加入到了优先级队列中，当fetcher的loop检查到当前下一个区块的高度，正是队列中有的，则不再向peer请求 // 该区块，而是直接使用该区块，检查无误后交给block chain执行insertChain if _, td := p.Head(); trueTD.Cmp(td) &gt; 0 { p.SetHead(trueHead, trueTD) // Schedule a sync if above ours. Note, this will not fire a sync for a gap of // a singe block (as the true TD is below the propagated block), however this // scenario should easily be covered by the fetcher. currentBlock := pm.blockchain.CurrentBlock() if trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) &gt; 0 { go pm.synchronise(p) } } //------------------------ 以上 handleMsg // Enqueue tries to fill gaps the the fetcher&#39;s future import queue. // 发给inject通道，当前协程在handleMsg，通过通道发送给fetcher的协程处理 func (f *Fetcher) Enqueue(peer string, block *types.Block) error { op := &amp;inject{ origin: peer, block: block, } select { case f.inject &lt;- op: return nil case &lt;-f.quit: return errTerminated } } //------------------------ 以下 fetcher.loop处理inject部分 case op := &lt;-f.inject: // A direct block insertion was requested, try and fill any pending gaps // 区块加入队列，首先也填入未决的间距 propBroadcastInMeter.Mark(1) f.enqueue(op.origin, op.block) //------------------------ 如队列函数 // enqueue schedules a new future import operation, if the block to be imported // has not yet been seen. // 把导入的新区块放进来 func (f *Fetcher) enqueue(peer string, block *types.Block) { hash := block.Hash() // Ensure the peer isn&#39;t DOSing us // 防止peer的DOS攻击 count := f.queues[peer] + 1 if count &gt; blockLimit { log.Debug(&quot;Discarded propagated block, exceeded allowance&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;limit&quot;, blockLimit) propBroadcastDOSMeter.Mark(1) f.forgetHash(hash) return } // Discard any past or too distant blocks // 高度检查：未来太远的块丢弃 if dist := int64(block.NumberU64()) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist { log.Debug(&quot;Discarded propagated block, too far away&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;distance&quot;, dist) propBroadcastDropMeter.Mark(1) f.forgetHash(hash) return } // Schedule the block for future importing // 块先加入优先级队列，加入链之前，还有很多要做 if _, ok := f.queued[hash]; !ok { op := &amp;inject{ origin: peer, block: block, } f.queues[peer] = count f.queued[hash] = op f.queue.Push(op, -float32(block.NumberU64())) if f.queueChangeHook != nil { f.queueChangeHook(op.block.Hash(), true) } log.Debug(&quot;Queued propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;queued&quot;, f.queue.Size()) } } fetcher队列处理 本节我们看看，区块加入队列后，fetcher如何处理区块，为何不直接校验区块，插入到本地链？ 由于以太坊又Uncle的机制，节点可能收到老一点的一些区块。另外，节点可能由于网络原因，落后了几个区块，所以可能收到“未来”的一些区块，这些区块都不能直接插入到本地链。 区块入的队列是一个优先级队列，高度低的区块会被优先取出来。fetcher.loop是单独协程，不断运转，清理fecther中的事务和事件。首先会清理正在fetching的区块，但已经超时。然后处理优先级队列中的区块，判断高度是否是下一个区块，如果是则调用f.insert()函数，校验后调用BlockChain.InsertChain()，成功插入后，广播新区块的Hash。 // Loop is the main fetcher loop, checking and processing various notification // events. func (f *Fetcher) loop() { // Iterate the block fetching until a quit is requested fetchTimer := time.NewTimer(0) completeTimer := time.NewTimer(0) for { // Clean up any expired block fetches // 清理过期的区块 for hash, announce := range f.fetching { if time.Since(announce.time) &gt; fetchTimeout { f.forgetHash(hash) } } // Import any queued blocks that could potentially fit // 导入队列中合适的块 height := f.chainHeight() for !f.queue.Empty() { op := f.queue.PopItem().(*inject) hash := op.block.Hash() if f.queueChangeHook != nil { f.queueChangeHook(hash, false) } // If too high up the chain or phase, continue later // 块不是链需要的下一个块，再入优先级队列，停止循环 number := op.block.NumberU64() if number &gt; height+1 { f.queue.Push(op, -float32(number)) if f.queueChangeHook != nil { f.queueChangeHook(hash, true) } break } // Otherwise if fresh and still unknown, try and import // 高度正好是我们想要的，并且链上也没有这个块 if number+maxUncleDist &lt; height || f.getBlock(hash) != nil { f.forgetBlock(hash) continue } // 那么，块插入链 f.insert(op.origin, op.block) } //省略 } } func (f *Fetcher) insert(peer string, block *types.Block) { hash := block.Hash() // Run the import on a new thread log.Debug(&quot;Importing propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash) go func() { defer func() { f.done &lt;- hash }() // If the parent&#39;s unknown, abort insertion parent := f.getBlock(block.ParentHash()) if parent == nil { log.Debug(&quot;Unknown parent of propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;parent&quot;, block.ParentHash()) return } // Quickly validate the header and propagate the block if it passes // 验证区块头，成功后广播区块 switch err := f.verifyHeader(block.Header()); err { case nil: // All ok, quickly propagate to our peers propBroadcastOutTimer.UpdateSince(block.ReceivedAt) go f.broadcastBlock(block, true) case consensus.ErrFutureBlock: // Weird future block, don&#39;t fail, but neither propagate default: // Something went very wrong, drop the peer log.Debug(&quot;Propagated block verification failed&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;err&quot;, err) f.dropPeer(peer) return } // Run the actual import and log any issues // 调用回调函数，实际是blockChain.insertChain if _, err := f.insertChain(types.Blocks{block}); err != nil { log.Debug(&quot;Propagated block import failed&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;err&quot;, err) return } // If import succeeded, broadcast the block propAnnounceOutTimer.UpdateSince(block.ReceivedAt) go f.broadcastBlock(block, false) // Invoke the testing hook if needed if f.importedHook != nil { f.importedHook(block) } }() } NewBlockHashesMsg的处理 本节介绍NewBlockHashesMsg的处理，其实，消息处理是简单的，而复杂一点的是从Peer哪获取完整的区块，下节再看。 流程如下: 对消息进行RLP解码，然后标记Peer已经知道此区块。 寻找出本地区块链不存在的区块Hash值，把这些未知的Hash通知给fetcher。 fetcher.Notify记录好通知信息，塞入notify通道，以便交给fetcher的协程。 fetcher.loop()会对notify中的消息进行处理，确认区块并非DOS攻击，然后检查区块的高度，判断该区块是否已经在fetching或者comleting(代表已经下载区块头，在下载body)，如果都没有，则加入到announced中，触发0s定时器，进行处理。 关于announced下节再介绍。 // handleMsg()部分 case msg.Code == NewBlockHashesMsg: var announces newBlockHashesData if err := msg.Decode(&amp;announces); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } // Mark the hashes as present at the remote node for _, block := range announces { p.MarkBlock(block.Hash) } // Schedule all the unknown hashes for retrieval // 把本地链没有的块hash找出来，交给fetcher去下载 unknown := make(newBlockHashesData, 0, len(announces)) for _, block := range announces { if !pm.blockchain.HasBlock(block.Hash, block.Number) { unknown = append(unknown, block) } } for _, block := range unknown { pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies) } // Notify announces the fetcher of the potential availability of a new block in // the network. // 通知fetcher（自己）有新块产生，没有块实体，有hash、高度等信息 func (f *Fetcher) Notify(peer string, hash common.Hash, number uint64, time time.Time, headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn) error { block := &amp;announce{ hash: hash, number: number, time: time, origin: peer, fetchHeader: headerFetcher, fetchBodies: bodyFetcher, } select { case f.notify &lt;- block: return nil case &lt;-f.quit: return errTerminated } } // fetcher.loop()的notify通道消息处理 case notification := &lt;-f.notify: // A block was announced, make sure the peer isn&#39;t DOSing us propAnnounceInMeter.Mark(1) count := f.announces[notification.origin] + 1 if count &gt; hashLimit { log.Debug(&quot;Peer exceeded outstanding announces&quot;, &quot;peer&quot;, notification.origin, &quot;limit&quot;, hashLimit) propAnnounceDOSMeter.Mark(1) break } // If we have a valid block number, check that it&#39;s potentially useful // 高度检查 if notification.number &gt; 0 { if dist := int64(notification.number) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist { log.Debug(&quot;Peer discarded announcement&quot;, &quot;peer&quot;, notification.origin, &quot;number&quot;, notification.number, &quot;hash&quot;, notification.hash, &quot;distance&quot;, dist) propAnnounceDropMeter.Mark(1) break } } // All is well, schedule the announce if block&#39;s not yet downloading // 检查是否已经在下载，已下载则忽略 if _, ok := f.fetching[notification.hash]; ok { break } if _, ok := f.completing[notification.hash]; ok { break } // 更新peer已经通知给我们的区块数量 f.announces[notification.origin] = count // 把通知信息加入到announced，供调度 f.announced[notification.hash] = append(f.announced[notification.hash], notification) if f.announceChangeHook != nil &amp;&amp; len(f.announced[notification.hash]) == 1 { f.announceChangeHook(notification.hash, true) } if len(f.announced) == 1 { // 有通知放入到announced，则重设0s定时器，loop的另外一个分支会处理这些通知 f.rescheduleFetch(fetchTimer) } fetcher获取完整区块 本节介绍fetcher获取完整区块的过程，这也是fetcher最重要的功能，会涉及到fetcher至少80%的代码。单独拉放一大节吧。 Fetcher的大头 Fetcher最主要的功能就是获取完整的区块，然后在合适的实际交给InsertChain去验证和插入到本地区块链。我们还是从宏观入手，看Fetcher是如何工作的，一定要先掌握好宏观，因为代码层面上没有这么清晰。 宏观 首先，看两个节点是如何交互，获取完整区块，使用时序图的方式看一下，见图6，流程很清晰不再文字介绍。 再看下获取区块过程中，fetcher内部的状态转移，它使用状态来记录，要获取的区块在什么阶段，见图7。我稍微解释一下： 收到NewBlockHashesMsg后，相关信息会记录到announced，进入announced状态，代表了本节点接收了消息。 announced由fetcher协程处理，经过校验后，会向给他发送消息的Peer发送请求，请求该区块的区块头，然后进入fetching状态。 获取区块头后，如果区块头表示没有交易和uncle，则转移到completing状态，并且使用区块头合成完整的区块，加入到queued优先级队列。 获取区块头后，如果区块头表示该区块有交易和uncle，则转移到fetched状态，然后发送请求，请求交易和uncle，然后转移到completing状态。 收到交易和uncle后，使用头、交易、uncle这3个信息，生成完整的区块，加入到队列queued。 微观 接下来就是从代码角度看如何获取完整区块的流程了，有点多，看不懂的时候，再回顾下上面宏观的介绍图。 首先看Fetcher的定义，它存放了通信数据和状态管理，捡加注释的看，上文提到的状态，里面都有。 // Fetcher is responsible for accumulating block announcements from various peers // and scheduling them for retrieval. // 积累块通知，然后调度获取这些块 type Fetcher struct { // Various event channels // 收到区块hash值的通道 notify chan *announce // 收到完整区块的通道 inject chan *inject blockFilter chan chan []*types.Block // 过滤header的通道的通道 headerFilter chan chan *headerFilterTask // 过滤body的通道的通道 bodyFilter chan chan *bodyFilterTask done chan common.Hash quit chan struct{} // Announce states // Peer已经给了本节点多少区块头通知 announces map[string]int // Per peer announce counts to prevent memory exhaustion // 已经announced的区块列表 announced map[common.Hash][]*announce // Announced blocks, scheduled for fetching // 正在fetching区块头的请求 fetching map[common.Hash]*announce // Announced blocks, currently fetching // 已经fetch到区块头，还差body的请求，用来获取body fetched map[common.Hash][]*announce // Blocks with headers fetched, scheduled for body retrieval // 已经得到区块头的 completing map[common.Hash]*announce // Blocks with headers, currently body-completing // Block cache // queue，优先级队列，高度做优先级 // queues，统计peer通告了多少块 // queued，代表这个块如队列了， queue *prque.Prque // Queue containing the import operations (block number sorted) queues map[string]int // Per peer block counts to prevent memory exhaustion queued map[common.Hash]*inject // Set of already queued blocks (to dedupe imports) // Callbacks getBlock blockRetrievalFn // Retrieves a block from the local chain verifyHeader headerVerifierFn // Checks if a block&#39;s headers have a valid proof of work，验证区块头，包含了PoW验证 broadcastBlock blockBroadcasterFn // Broadcasts a block to connected peers，广播给peer chainHeight chainHeightFn // Retrieves the current chain&#39;s height insertChain chainInsertFn // Injects a batch of blocks into the chain，插入区块到链的函数 dropPeer peerDropFn // Drops a peer for misbehaving // Testing hooks announceChangeHook func(common.Hash, bool) // Method to call upon adding or deleting a hash from the announce list queueChangeHook func(common.Hash, bool) // Method to call upon adding or deleting a block from the import queue fetchingHook func([]common.Hash) // Method to call upon starting a block (eth/61) or header (eth/62) fetch completingHook func([]common.Hash) // Method to call upon starting a block body fetch (eth/62) importedHook func(*types.Block) // Method to call upon successful block import (both eth/61 and eth/62) } NewBlockHashesMsg消息的处理前面的小节已经讲过了，不记得可向前翻看。这里从announced的状态处理说起。loop()中，fetchTimer超时后，代表了收到了消息通知，需要处理，会从announced中选择出需要处理的通知，然后创建请求，请求区块头，由于可能有很多节点都通知了它某个区块的Hash，所以随机的从这些发送消息的Peer中选择一个Peer，发送请求的时候，为每个Peer都创建了单独的协程。 case &lt;-fetchTimer.C: // At least one block&#39;s timer ran out, check for needing retrieval // 有区块通知，去处理 request := make(map[string][]common.Hash) for hash, announces := range f.announced { if time.Since(announces[0].time) &gt; arriveTimeout-gatherSlack { // Pick a random peer to retrieve from, reset all others // 可能有很多peer都发送了这个区块的hash值，随机选择一个peer announce := announces[rand.Intn(len(announces))] f.forgetHash(hash) // If the block still didn&#39;t arrive, queue for fetching // 本地还没有这个区块，创建获取区块的请求 if f.getBlock(hash) == nil { request[announce.origin] = append(request[announce.origin], hash) f.fetching[hash] = announce } } } // Send out all block header requests // 把所有的request发送出去 // 为每一个peer都创建一个协程，然后请求所有需要从该peer获取的请求 for peer, hashes := range request { log.Trace(&quot;Fetching scheduled headers&quot;, &quot;peer&quot;, peer, &quot;list&quot;, hashes) // Create a closure of the fetch and schedule in on a new thread fetchHeader, hashes := f.fetching[hashes[0]].fetchHeader, hashes go func() { if f.fetchingHook != nil { f.fetchingHook(hashes) } for _, hash := range hashes { headerFetchMeter.Mark(1) fetchHeader(hash) // Suboptimal, but protocol doesn&#39;t allow batch header retrievals } }() } // Schedule the next fetch if blocks are still pending f.rescheduleFetch(fetchTimer) 从Notify的调用中，可以看出，fetcherHeader()的实际函数是RequestOneHeader()，该函数使用的消息是GetBlockHeadersMsg，可以用来请求多个区块头，不过fetcher只请求一个。 pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies) // RequestOneHeader is a wrapper around the header query functions to fetch a // single header. It is used solely by the fetcher. func (p *peer) RequestOneHeader(hash common.Hash) error { p.Log().Debug(&quot;Fetching single header&quot;, &quot;hash&quot;, hash) return p2p.Send(p.rw, GetBlockHeadersMsg, &amp;getBlockHeadersData{Origin: hashOrNumber{Hash: hash}, Amount: uint64(1), Skip: uint64(0), Reverse: false}) } GetBlockHeadersMsg的处理如下：因为它是获取多个区块头的，所以处理起来比较“麻烦”，还好，fetcher只获取一个区块头，其处理在20行~33行，获取下一个区块头的处理逻辑，这里就不看了，最后调用SendBlockHeaders()将区块头发送给请求的节点，消息是BlockHeadersMsg。 // handleMsg() // Block header query, collect the requested headers and reply case msg.Code == GetBlockHeadersMsg: // Decode the complex header query var query getBlockHeadersData if err := msg.Decode(&amp;query); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } hashMode := query.Origin.Hash != (common.Hash{}) // Gather headers until the fetch or network limits is reached // 收集区块头，直到达到限制 var ( bytes common.StorageSize headers []*types.Header unknown bool ) // 自己已知区块 &amp;&amp; 少于查询的数量 &amp;&amp; 大小小于2MB &amp;&amp; 小于能下载的最大数量 for !unknown &amp;&amp; len(headers) &lt; int(query.Amount) &amp;&amp; bytes &lt; softResponseLimit &amp;&amp; len(headers) &lt; downloader.MaxHeaderFetch { // Retrieve the next header satisfying the query // 获取区块头 var origin *types.Header if hashMode { // fetcher 使用的模式 origin = pm.blockchain.GetHeaderByHash(query.Origin.Hash) } else { origin = pm.blockchain.GetHeaderByNumber(query.Origin.Number) } if origin == nil { break } number := origin.Number.Uint64() headers = append(headers, origin) bytes += estHeaderRlpSize // Advance to the next header of the query // 下一个区块头的获取，不同策略，方式不同 switch { case query.Origin.Hash != (common.Hash{}) &amp;&amp; query.Reverse: // ... } } return p.SendBlockHeaders(headers) BlockHeadersMsg的处理很有意思，因为GetBlockHeadersMsg并不是fetcher独占的消息，downloader也可以调用，所以，响应消息的处理需要分辨出是fetcher请求的，还是downloader请求的。它的处理逻辑是：fetcher先过滤收到的区块头，如果fetcher不要的，那就是downloader的，在调用fetcher.FilterHeaders的时候，fetcher就将自己要的区块头拿走了。 // handleMsg() case msg.Code == BlockHeadersMsg: // A batch of headers arrived to one of our previous requests var headers []*types.Header if err := msg.Decode(&amp;headers); err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // If no headers were received, but we&#39;re expending a DAO fork check, maybe it&#39;s that // 检查是不是当前DAO的硬分叉 if len(headers) == 0 &amp;&amp; p.forkDrop != nil { // Possibly an empty reply to the fork header checks, sanity check TDs verifyDAO := true // If we already have a DAO header, we can check the peer&#39;s TD against it. If // the peer&#39;s ahead of this, it too must have a reply to the DAO check if daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != nil { if _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= 0 { verifyDAO = false } } // If we&#39;re seemingly on the same chain, disable the drop timer if verifyDAO { p.Log().Debug(&quot;Seems to be on the same side of the DAO fork&quot;) p.forkDrop.Stop() p.forkDrop = nil return nil } } // Filter out any explicitly requested headers, deliver the rest to the downloader // 过滤是不是fetcher请求的区块头，去掉fetcher请求的区块头再交给downloader filter := len(headers) == 1 if filter { // If it&#39;s a potential DAO fork check, validate against the rules // 检查是否硬分叉 if p.forkDrop != nil &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[0].Number) == 0 { // Disable the fork drop timer p.forkDrop.Stop() p.forkDrop = nil // Validate the header and either drop the peer or continue if err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[0]); err != nil { p.Log().Debug(&quot;Verified to be on the other side of the DAO fork, dropping&quot;) return err } p.Log().Debug(&quot;Verified to be on the same side of the DAO fork&quot;) return nil } // Irrelevant of the fork checks, send the header to the fetcher just in case // 使用fetcher过滤区块头 headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now()) } // 剩下的区块头交给downloader if len(headers) &gt; 0 || !filter { err := pm.downloader.DeliverHeaders(p.id, headers) if err != nil { log.Debug(&quot;Failed to deliver headers&quot;, &quot;err&quot;, err) } } FilterHeaders()是一个很有大智慧的函数，看起来耐人寻味，但实在妙。它要把所有的区块头，都传递给fetcher协程，还要获取fetcher协程处理后的结果。fetcher.headerFilter是存放通道的通道，而filter是存放包含区块头过滤任务的通道。它先把filter传递给了headerFilter，这样fetcher协程就在另外一段等待了，而后将headerFilterTask传入filter，fetcher就能读到数据了，处理后，再将数据写回filter而刚好被FilterHeaders函数处理了，该函数实际运行在handleMsg()的协程中。 每个Peer都会分配一个ProtocolManager然后处理该Peer的消息，但fetcher只有一个事件处理协程，如果不创建一个filter，fetcher哪知道是谁发给它的区块头呢？过滤之后，该如何发回去呢？ // FilterHeaders extracts all the headers that were explicitly requested by the fetcher, // returning those that should be handled differently. // 寻找出fetcher请求的区块头 func (f *Fetcher) FilterHeaders(peer string, headers []*types.Header, time time.Time) []*types.Header { log.Trace(&quot;Filtering headers&quot;, &quot;peer&quot;, peer, &quot;headers&quot;, len(headers)) // Send the filter channel to the fetcher // 任务通道 filter := make(chan *headerFilterTask) select { // 任务通道发送到这个通道 case f.headerFilter &lt;- filter: case &lt;-f.quit: return nil } // Request the filtering of the header list // 创建过滤任务，发送到任务通道 select { case filter &lt;- &amp;headerFilterTask{peer: peer, headers: headers, time: time}: case &lt;-f.quit: return nil } // Retrieve the headers remaining after filtering // 从任务通道，获取过滤的结果并返回 select { case task := &lt;-filter: return task.headers case &lt;-f.quit: return nil } } 接下来要看f.headerFilter的处理，这段代码有90行，它做了一下几件事： 从f.headerFilter取出filter，然后取出过滤任务task。 它把区块头分成3类：unknown这不是分是要返回给调用者的，即handleMsg(), incomplete存放还需要获取body的区块头，complete存放只包含区块头的区块。遍历所有的区块头，填到到对应的分类中，具体的判断可看18行的注释，记住宏观中将的状态转移图。 把unknonw中的区块返回给handleMsg()。 把 incomplete的区块头获取状态移动到fetched状态，然后触发定时器，以便去处理complete的区块。 把compelete的区块加入到queued。 // fetcher.loop() case filter := &lt;-f.headerFilter: // Headers arrived from a remote peer. Extract those that were explicitly // requested by the fetcher, and return everything else so it&#39;s delivered // to other parts of the system. // 收到从远端节点发送的区块头，过滤出fetcher请求的 // 从任务通道获取过滤任务 var task *headerFilterTask select { case task = &lt;-filter: case &lt;-f.quit: return } headerFilterInMeter.Mark(int64(len(task.headers))) // Split the batch of headers into unknown ones (to return to the caller), // known incomplete ones (requiring body retrievals) and completed blocks. // unknown的不是fetcher请求的，complete放没有交易和uncle的区块，有头就够了，incomplete放 // 还需要获取uncle和交易的区块 unknown, incomplete, complete := []*types.Header{}, []*announce{}, []*types.Block{} // 遍历所有收到的header for _, header := range task.headers { hash := header.Hash() // Filter fetcher-requested headers from other synchronisation algorithms // 是正在获取的hash，并且对应请求的peer，并且未fetched，未completing，未queued if announce := f.fetching[hash]; announce != nil &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == nil &amp;&amp; f.completing[hash] == nil &amp;&amp; f.queued[hash] == nil { // If the delivered header does not match the promised number, drop the announcer // 高度校验，竟然不匹配，扰乱秩序，peer肯定是坏蛋。 if header.Number.Uint64() != announce.number { log.Trace(&quot;Invalid block number fetched&quot;, &quot;peer&quot;, announce.origin, &quot;hash&quot;, header.Hash(), &quot;announced&quot;, announce.number, &quot;provided&quot;, header.Number) f.dropPeer(announce.origin) f.forgetHash(hash) continue } // Only keep if not imported by other means // 本地链没有当前区块 if f.getBlock(hash) == nil { announce.header = header announce.time = task.time // If the block is empty (header only), short circuit into the final import queue // 如果区块没有交易和uncle，加入到complete if header.TxHash == types.DeriveSha(types.Transactions{}) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header{}) { log.Trace(&quot;Block empty, skipping body retrieval&quot;, &quot;peer&quot;, announce.origin, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash()) block := types.NewBlockWithHeader(header) block.ReceivedAt = task.time complete = append(complete, block) f.completing[hash] = announce continue } // Otherwise add to the list of blocks needing completion // 否则就是不完整的区块 incomplete = append(incomplete, announce) } else { log.Trace(&quot;Block already imported, discarding header&quot;, &quot;peer&quot;, announce.origin, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash()) f.forgetHash(hash) } } else { // Fetcher doesn&#39;t know about it, add to the return list // 没请求过的header unknown = append(unknown, header) } } // 把未知的区块头，再传递会filter headerFilterOutMeter.Mark(int64(len(unknown))) select { case filter &lt;- &amp;headerFilterTask{headers: unknown, time: task.time}: case &lt;-f.quit: return } // Schedule the retrieved headers for body completion // 把未完整的区块加入到fetched，跳过已经在completeing中的，然后触发completeTimer定时器 for _, announce := range incomplete { hash := announce.header.Hash() if _, ok := f.completing[hash]; ok { continue } f.fetched[hash] = append(f.fetched[hash], announce) if len(f.fetched) == 1 { f.rescheduleComplete(completeTimer) } } // Schedule the header-only blocks for import // 把只有头的区块入队列 for _, block := range complete { if announce := f.completing[block.Hash()]; announce != nil { f.enqueue(announce.origin, block) } } 跟随状态图的转义，剩下的工作是fetched转移到completing，上面的流程已经触发了completeTimer定时器，超时后就会处理，流程与请求Header类似，不再赘述，此时发送的请求消息是GetBlockBodiesMsg，实际调的函数是RequestBodies。 // fetcher.loop() case &lt;-completeTimer.C: // At least one header&#39;s timer ran out, retrieve everything // 至少有1个header已经获取完了 request := make(map[string][]common.Hash) // 遍历所有待获取body的announce for hash, announces := range f.fetched { // Pick a random peer to retrieve from, reset all others // 随机选一个Peer发送请求，因为可能已经有很多Peer通知它这个区块了 announce := announces[rand.Intn(len(announces))] f.forgetHash(hash) // If the block still didn&#39;t arrive, queue for completion // 如果本地没有这个区块，则放入到completing，创建请求 if f.getBlock(hash) == nil { request[announce.origin] = append(request[announce.origin], hash) f.completing[hash] = announce } } // Send out all block body requests // 发送所有的请求，获取body，依然是每个peer一个单独协程 for peer, hashes := range request { log.Trace(&quot;Fetching scheduled bodies&quot;, &quot;peer&quot;, peer, &quot;list&quot;, hashes) // Create a closure of the fetch and schedule in on a new thread if f.completingHook != nil { f.completingHook(hashes) } bodyFetchMeter.Mark(int64(len(hashes))) go f.completing[hashes[0]].fetchBodies(hashes) } // Schedule the next fetch if blocks are still pending f.rescheduleComplete(completeTimer) handleMsg()处理该消息也是干净利落，直接获取RLP格式的body，然后发送响应消息。 // handleMsg() case msg.Code == GetBlockBodiesMsg: // Decode the retrieval message msgStream := rlp.NewStream(msg.Payload, uint64(msg.Size)) if _, err := msgStream.List(); err != nil { return err } // Gather blocks until the fetch or network limits is reached var ( hash common.Hash bytes int bodies []rlp.RawValue ) // 遍历所有请求 for bytes &lt; softResponseLimit &amp;&amp; len(bodies) &lt; downloader.MaxBlockFetch { // Retrieve the hash of the next block if err := msgStream.Decode(&amp;hash); err == rlp.EOL { break } else if err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // Retrieve the requested block body, stopping if enough was found // 获取body，RLP格式 if data := pm.blockchain.GetBodyRLP(hash); len(data) != 0 { bodies = append(bodies, data) bytes += len(data) } } return p.SendBlockBodiesRLP(bodies) 响应消息BlockBodiesMsg的处理与处理获取header的处理原理相同，先交给fetcher过滤，然后剩下的才是downloader的。需要注意一点，响应消息里只包含交易列表和叔块列表。 // handleMsg() case msg.Code == BlockBodiesMsg: // A batch of block bodies arrived to one of our previous requests var request blockBodiesData if err := msg.Decode(&amp;request); err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // Deliver them all to the downloader for queuing // 传递给downloader去处理 transactions := make([][]*types.Transaction, len(request)) uncles := make([][]*types.Header, len(request)) for i, body := range request { transactions[i] = body.Transactions uncles[i] = body.Uncles } // Filter out any explicitly requested bodies, deliver the rest to the downloader // 先让fetcher过滤去fetcher请求的body，剩下的给downloader filter := len(transactions) &gt; 0 || len(uncles) &gt; 0 if filter { transactions, uncles = pm.fetcher.FilterBodies(p.id, transactions, uncles, time.Now()) } // 剩下的body交给downloader if len(transactions) &gt; 0 || len(uncles) &gt; 0 || !filter { err := pm.downloader.DeliverBodies(p.id, transactions, uncles) if err != nil { log.Debug(&quot;Failed to deliver bodies&quot;, &quot;err&quot;, err) } } 过滤函数的原理也与Header相同。 // FilterBodies extracts all the block bodies that were explicitly requested by // the fetcher, returning those that should be handled differently. // 过去出fetcher请求的body，返回它没有处理的，过程类型header的处理 func (f *Fetcher) FilterBodies(peer string, transactions [][]*types.Transaction, uncles [][]*types.Header, time time.Time) ([][]*types.Transaction, [][]*types.Header) { log.Trace(&quot;Filtering bodies&quot;, &quot;peer&quot;, peer, &quot;txs&quot;, len(transactions), &quot;uncles&quot;, len(uncles)) // Send the filter channel to the fetcher filter := make(chan *bodyFilterTask) select { case f.bodyFilter &lt;- filter: case &lt;-f.quit: return nil, nil } // Request the filtering of the body list select { case filter &lt;- &amp;bodyFilterTask{peer: peer, transactions: transactions, uncles: uncles, time: time}: case &lt;-f.quit: return nil, nil } // Retrieve the bodies remaining after filtering select { case task := &lt;-filter: return task.transactions, task.uncles case &lt;-f.quit: return nil, nil } } 实际过滤body的处理瞧一下，这和Header的处理是不同的。直接看不点： 它要的区块，单独取出来存到blocks中，它不要的继续留在task中。 判断是不是fetcher请求的方法：如果交易列表和叔块列表计算出的hash值与区块头中的一样，并且消息来自请求的Peer，则就是fetcher请求的。 将blocks中的区块加入到queued，终结。 case filter := &lt;-f.bodyFilter: // Block bodies arrived, extract any explicitly requested blocks, return the rest var task *bodyFilterTask select { case task = &lt;-filter: case &lt;-f.quit: return } bodyFilterInMeter.Mark(int64(len(task.transactions))) blocks := []*types.Block{} // 获取的每个body的txs列表和uncle列表 // 遍历每个区块的txs列表和uncle列表，计算hash后判断是否是当前fetcher请求的body for i := 0; i &lt; len(task.transactions) &amp;&amp; i &lt; len(task.uncles); i++ { // Match up a body to any possible completion request matched := false // 遍历所有保存的请求，因为tx和uncle，不知道它是属于哪个区块的，只能去遍历所有的请求，通常量不大，所以遍历没有性能影响 for hash, announce := range f.completing { if f.queued[hash] == nil { // 把传入的每个块的hash和unclehash和它请求出去的记录进行对比，匹配则说明是fetcher请求的区块body txnHash := types.DeriveSha(types.Transactions(task.transactions[i])) uncleHash := types.CalcUncleHash(task.uncles[i]) if txnHash == announce.header.TxHash &amp;&amp; uncleHash == announce.header.UncleHash &amp;&amp; announce.origin == task.peer { // Mark the body matched, reassemble if still unknown matched = true // 如果当前链还没有这个区块，则收集这个区块，合并成新区块 if f.getBlock(hash) == nil { block := types.NewBlockWithHeader(announce.header).WithBody(task.transactions[i], task.uncles[i]) block.ReceivedAt = task.time blocks = append(blocks, block) } else { f.forgetHash(hash) } } } } // 从task中移除fetcher请求的数据 if matched { task.transactions = append(task.transactions[:i], task.transactions[i+1:]...) task.uncles = append(task.uncles[:i], task.uncles[i+1:]...) i-- continue } } // 将剩余的数据返回 bodyFilterOutMeter.Mark(int64(len(task.transactions))) select { case filter &lt;- task: case &lt;-f.quit: return } // Schedule the retrieved blocks for ordered import // 把收集的区块加入到队列 for _, block := range blocks { if announce := f.completing[block.Hash()]; announce != nil { f.enqueue(announce.origin, block) } } } 至此，fetcher获取完整区块的流程讲完了，fetcher模块中80%的代码也都贴出来了，还有2个值得看看的函数： forgetHash(hash common.Hash)：用于清空指定hash指的记/状态录信息。 forgetBlock(hash common.Hash)：用于从队列中移除一个区块。 最后了，再回到开始看看fetcher模块和新区块的传播流程，有没有豁然开朗。 如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。 本文作者：大彬 如果喜欢本文，随意转载，但请保留此原文链接：http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-05T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：版权归lessisbetter.site所有，转载请请声明 https://blog.csdn.net/m0_43499523/article/details/85852204 前言 这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。 当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。 总体过程和传播策略 本节从宏观角度介绍，节点产生区块后，为了传播给远端节点做了啥，远端节点收到区块后又做了什么，每个节点都连接了很多Peer，它传播的策略是什么样的？ 总体流程和策略可以总结为，传播给远端Peer节点，Peer验证区块无误后，加入到本地区块链，继续传播新区块信息。具体过程如下。 先看总体过程。产生区块后，miner模块会发布一个事件NewMinedBlockEvent，订阅事件的协程收到事件后，就会把新区块的消息，广播给它所有的peer，peer收到消息后，会交给自己的fetcher模块处理，fetcher进行基本的验证后，区块没问题，发现这个区块就是本地链需要的下一个区块，则交给blockChain进一步进行完整的验证，这个过程会执行区块所有的交易，无误后把区块加入到本地链，写入数据库，这个过程就是下面的流程图，图1。 总体流程图，能看到有个分叉，是因为节点传播新区块是有策略的。它的传播策略为： 假如节点连接了N个Peer，它只向Peer列表的sqrt(N)个Peer广播完整的区块消息。 向所有的Peer广播只包含区块Hash的消息。 策略图的效果如图2，红色节点将区块传播给黄色节点： 收到区块Hash的节点，需要从发送给它消息的Peer那里获取对应的完整区块，获取区块后就会按照图1的流程，加入到fetcher队列，最终插入本地区块链后，将区块的Hash值广播给和它相连，但还不知道这个区块的Peer。非产生区块节点的策略图，如图3，黄色节点将区块Hash传播给青色节点： 至此，可以看出以太坊采用以石击水的方式，像水纹一样，层层扩散新产生的区块。 Fetcher模块是干啥的 fetcher模块的功能，就是收集其他Peer通知它的区块信息：1）完整的区块2）区块Hash消息。根据通知的消息，获取完整的区块，然后传递给eth模块把区块插入区块链。 如果是完整区块，就可以传递给eth插入区块，如果只有区块Hash，则需要从其他的Peer获取此完整的区块，然后再传递给eth插入区块。 源码解读 本节介绍区块传播和处理的细节东西，方式仍然是先用图解释流程，再是代码流程。 产块节点的传播新区块 节点产生区块后，广播的流程可以表示为图4： 发布事件 事件处理函数选择要广播完整的Peer，然后将区块加入到它们的队列 事件处理函数把区块Hash添加到所有Peer的另外一个通知队列 每个Peer的广播处理函数，会遍历它的待广播区块队列和通知队列，把数据封装成消息，调用P2P接口发送出去 再看下代码上的细节。 worker.wait()函数发布事件NewMinedBlockEvent。 ProtocolManager.minedBroadcastLoop()是事件处理函数。它调用了2次pm.BroadcastBlock()。 // Mined broadcast loop func (pm *ProtocolManager) minedBroadcastLoop() { // automatically stops if unsubscribe for obj := range pm.minedBlockSub.Chan() { switch ev := obj.Data.(type) { case core.NewMinedBlockEvent: pm.BroadcastBlock(ev.Block, true) // First propagate block to peers pm.BroadcastBlock(ev.Block, false) // Only then announce to the rest } } } pm.BroadcastBlock()的入参propagate为真时，向部分Peer广播完整的区块，调用peer.AsyncSendNewBlock()，否则向所有Peer广播区块头，调用peer.AsyncSendNewBlockHash()，这2个函数就是把数据放入队列，此处不再放代码。 // BroadcastBlock will either propagate a block to a subset of it&#39;s peers, or // will only announce it&#39;s availability (depending what&#39;s requested). func (pm *ProtocolManager) BroadcastBlock(block *types.Block, propagate bool) { hash := block.Hash() peers := pm.peers.PeersWithoutBlock(hash) // If propagation is requested, send to a subset of the peer // 这种情况，要把区块广播给部分peer if propagate { // Calculate the TD of the block (it&#39;s not imported yet, so block.Td is not valid) // 计算新的总难度 var td *big.Int if parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()-1); parent != nil { td = new(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()-1)) } else { log.Error(&quot;Propagating dangling block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash) return } // Send the block to a subset of our peers // 广播区块给部分peer transfer := peers[:int(math.Sqrt(float64(len(peers))))] for _, peer := range transfer { peer.AsyncSendNewBlock(block, td) } log.Trace(&quot;Propagated block&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(transfer), &quot;duration&quot;, common.PrettyDuration(time.Since(block.ReceivedAt))) return } // Otherwise if the block is indeed in out own chain, announce it // 把区块hash值广播给所有peer if pm.blockchain.HasBlock(hash, block.NumberU64()) { for _, peer := range peers { peer.AsyncSendNewBlockHash(block) } log.Trace(&quot;Announced block&quot;, &quot;hash&quot;, hash, &quot;recipients&quot;, len(peers), &quot;duration&quot;, common.PrettyDuration(time.Since(block.ReceivedAt))) } } peer.broadcase()是每个Peer连接的广播函数，它只广播3种消息：交易、完整的区块、区块的Hash，这样表明了节点只会主动广播这3中类型的数据，剩余的数据同步，都是通过请求-响应的方式。 // broadcast is a write loop that multiplexes block propagations, announcements // and transaction broadcasts into the remote peer. The goal is to have an async // writer that does not lock up node internals. func (p *peer) broadcast() { for { select { // 广播交易 case txs := &lt;-p.queuedTxs: if err := p.SendTransactions(txs); err != nil { return } p.Log().Trace(&quot;Broadcast transactions&quot;, &quot;count&quot;, len(txs)) // 广播完整的新区块 case prop := &lt;-p.queuedProps: if err := p.SendNewBlock(prop.block, prop.td); err != nil { return } p.Log().Trace(&quot;Propagated block&quot;, &quot;number&quot;, prop.block.Number(), &quot;hash&quot;, prop.block.Hash(), &quot;td&quot;, prop.td) // 广播区块Hash case block := &lt;-p.queuedAnns: if err := p.SendNewBlockHashes([]common.Hash{block.Hash()}, []uint64{block.NumberU64()}); err != nil { return } p.Log().Trace(&quot;Announced block&quot;, &quot;number&quot;, block.Number(), &quot;hash&quot;, block.Hash()) case &lt;-p.term: return } } } Peer节点处理新区块 本节介绍远端节点收到2种区块同步消息的处理，其中NewBlockMsg的处理流程比较清晰，也简洁。NewBlockHashesMsg消息的处理就绕了2绕，从总体流程图1上能看出来，它需要先从给他发送消息Peer那里获取到完整的区块，剩下的流程和NewBlockMsg又一致了。 这部分涉及的模块多，画出来有种眼花缭乱的感觉，但只要抓住上面的主线，代码看起来还是很清晰的。通过图5先看下整体流程。 消息处理的起点是ProtocolManager.handleMsg，NewBlockMsg的处理流程是蓝色标记的区域，红色区域是单独的协程，是fetcher处理队列中区块的流程，如果从队列中取出的区块是当前链需要的，校验后，调用blockchian.InsertChain()把区块插入到区块链，最后写入数据库，这是黄色部分。最后，绿色部分是NewBlockHashesMsg的处理流程，代码流程上是比较复杂的，为了能通过图描述整体流程，我把它简化掉了。 仔细看看这幅图，掌握整体的流程后，接下来看每个步骤的细节。 NewBlockMsg的处理 本节介绍节点收到完整区块的处理，流程如下： 首先进行RLP编解码，然后标记发送消息的Peer已经知道这个区块，这样本节点最后广播这个区块的Hash时，不会再发送给该Peer。 将区块存入到fetcher的队列，调用fetcher.Enqueue。 更新Peer的Head位置，然后判断本地链是否落后于Peer的链，如果是，则通过Peer更新本地链。 只看handle.Msg()的NewBlockMsg相关的部分。 case msg.Code == NewBlockMsg: // Retrieve and decode the propagated block // 收到新区块，解码，赋值接收数据 var request newBlockData if err := msg.Decode(&amp;request); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } request.Block.ReceivedAt = msg.ReceivedAt request.Block.ReceivedFrom = p // Mark the peer as owning the block and schedule it for import // 标记peer知道这个区块 p.MarkBlock(request.Block.Hash()) // 为啥要如队列？已经得到完整的区块了 // 答：存入fetcher的优先级队列，fetcher会从队列中选取当前高度需要的块 pm.fetcher.Enqueue(p.id, request.Block) // Assuming the block is importable by the peer, but possibly not yet done so, // calculate the head hash and TD that the peer truly must have. // 截止到parent区块的头和难度 var ( trueHead = request.Block.ParentHash() trueTD = new(big.Int).Sub(request.TD, request.Block.Difficulty()) ) // Update the peers total difficulty if better than the previous // 如果收到的块的难度大于peer之前的，以及自己本地的，就去和这个peer同步 // 问题：就只用了一下块里的hash指，为啥不直接使用这个块呢，如果这个块不能用，干嘛不少发送些数据，减少网络负载呢。 // 答案：实际上，这个块加入到了优先级队列中，当fetcher的loop检查到当前下一个区块的高度，正是队列中有的，则不再向peer请求 // 该区块，而是直接使用该区块，检查无误后交给block chain执行insertChain if _, td := p.Head(); trueTD.Cmp(td) &gt; 0 { p.SetHead(trueHead, trueTD) // Schedule a sync if above ours. Note, this will not fire a sync for a gap of // a singe block (as the true TD is below the propagated block), however this // scenario should easily be covered by the fetcher. currentBlock := pm.blockchain.CurrentBlock() if trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) &gt; 0 { go pm.synchronise(p) } } //------------------------ 以上 handleMsg // Enqueue tries to fill gaps the the fetcher&#39;s future import queue. // 发给inject通道，当前协程在handleMsg，通过通道发送给fetcher的协程处理 func (f *Fetcher) Enqueue(peer string, block *types.Block) error { op := &amp;inject{ origin: peer, block: block, } select { case f.inject &lt;- op: return nil case &lt;-f.quit: return errTerminated } } //------------------------ 以下 fetcher.loop处理inject部分 case op := &lt;-f.inject: // A direct block insertion was requested, try and fill any pending gaps // 区块加入队列，首先也填入未决的间距 propBroadcastInMeter.Mark(1) f.enqueue(op.origin, op.block) //------------------------ 如队列函数 // enqueue schedules a new future import operation, if the block to be imported // has not yet been seen. // 把导入的新区块放进来 func (f *Fetcher) enqueue(peer string, block *types.Block) { hash := block.Hash() // Ensure the peer isn&#39;t DOSing us // 防止peer的DOS攻击 count := f.queues[peer] + 1 if count &gt; blockLimit { log.Debug(&quot;Discarded propagated block, exceeded allowance&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;limit&quot;, blockLimit) propBroadcastDOSMeter.Mark(1) f.forgetHash(hash) return } // Discard any past or too distant blocks // 高度检查：未来太远的块丢弃 if dist := int64(block.NumberU64()) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist { log.Debug(&quot;Discarded propagated block, too far away&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;distance&quot;, dist) propBroadcastDropMeter.Mark(1) f.forgetHash(hash) return } // Schedule the block for future importing // 块先加入优先级队列，加入链之前，还有很多要做 if _, ok := f.queued[hash]; !ok { op := &amp;inject{ origin: peer, block: block, } f.queues[peer] = count f.queued[hash] = op f.queue.Push(op, -float32(block.NumberU64())) if f.queueChangeHook != nil { f.queueChangeHook(op.block.Hash(), true) } log.Debug(&quot;Queued propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;queued&quot;, f.queue.Size()) } } fetcher队列处理 本节我们看看，区块加入队列后，fetcher如何处理区块，为何不直接校验区块，插入到本地链？ 由于以太坊又Uncle的机制，节点可能收到老一点的一些区块。另外，节点可能由于网络原因，落后了几个区块，所以可能收到“未来”的一些区块，这些区块都不能直接插入到本地链。 区块入的队列是一个优先级队列，高度低的区块会被优先取出来。fetcher.loop是单独协程，不断运转，清理fecther中的事务和事件。首先会清理正在fetching的区块，但已经超时。然后处理优先级队列中的区块，判断高度是否是下一个区块，如果是则调用f.insert()函数，校验后调用BlockChain.InsertChain()，成功插入后，广播新区块的Hash。 // Loop is the main fetcher loop, checking and processing various notification // events. func (f *Fetcher) loop() { // Iterate the block fetching until a quit is requested fetchTimer := time.NewTimer(0) completeTimer := time.NewTimer(0) for { // Clean up any expired block fetches // 清理过期的区块 for hash, announce := range f.fetching { if time.Since(announce.time) &gt; fetchTimeout { f.forgetHash(hash) } } // Import any queued blocks that could potentially fit // 导入队列中合适的块 height := f.chainHeight() for !f.queue.Empty() { op := f.queue.PopItem().(*inject) hash := op.block.Hash() if f.queueChangeHook != nil { f.queueChangeHook(hash, false) } // If too high up the chain or phase, continue later // 块不是链需要的下一个块，再入优先级队列，停止循环 number := op.block.NumberU64() if number &gt; height+1 { f.queue.Push(op, -float32(number)) if f.queueChangeHook != nil { f.queueChangeHook(hash, true) } break } // Otherwise if fresh and still unknown, try and import // 高度正好是我们想要的，并且链上也没有这个块 if number+maxUncleDist &lt; height || f.getBlock(hash) != nil { f.forgetBlock(hash) continue } // 那么，块插入链 f.insert(op.origin, op.block) } //省略 } } func (f *Fetcher) insert(peer string, block *types.Block) { hash := block.Hash() // Run the import on a new thread log.Debug(&quot;Importing propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash) go func() { defer func() { f.done &lt;- hash }() // If the parent&#39;s unknown, abort insertion parent := f.getBlock(block.ParentHash()) if parent == nil { log.Debug(&quot;Unknown parent of propagated block&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;parent&quot;, block.ParentHash()) return } // Quickly validate the header and propagate the block if it passes // 验证区块头，成功后广播区块 switch err := f.verifyHeader(block.Header()); err { case nil: // All ok, quickly propagate to our peers propBroadcastOutTimer.UpdateSince(block.ReceivedAt) go f.broadcastBlock(block, true) case consensus.ErrFutureBlock: // Weird future block, don&#39;t fail, but neither propagate default: // Something went very wrong, drop the peer log.Debug(&quot;Propagated block verification failed&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;err&quot;, err) f.dropPeer(peer) return } // Run the actual import and log any issues // 调用回调函数，实际是blockChain.insertChain if _, err := f.insertChain(types.Blocks{block}); err != nil { log.Debug(&quot;Propagated block import failed&quot;, &quot;peer&quot;, peer, &quot;number&quot;, block.Number(), &quot;hash&quot;, hash, &quot;err&quot;, err) return } // If import succeeded, broadcast the block propAnnounceOutTimer.UpdateSince(block.ReceivedAt) go f.broadcastBlock(block, false) // Invoke the testing hook if needed if f.importedHook != nil { f.importedHook(block) } }() } NewBlockHashesMsg的处理 本节介绍NewBlockHashesMsg的处理，其实，消息处理是简单的，而复杂一点的是从Peer哪获取完整的区块，下节再看。 流程如下: 对消息进行RLP解码，然后标记Peer已经知道此区块。 寻找出本地区块链不存在的区块Hash值，把这些未知的Hash通知给fetcher。 fetcher.Notify记录好通知信息，塞入notify通道，以便交给fetcher的协程。 fetcher.loop()会对notify中的消息进行处理，确认区块并非DOS攻击，然后检查区块的高度，判断该区块是否已经在fetching或者comleting(代表已经下载区块头，在下载body)，如果都没有，则加入到announced中，触发0s定时器，进行处理。 关于announced下节再介绍。 // handleMsg()部分 case msg.Code == NewBlockHashesMsg: var announces newBlockHashesData if err := msg.Decode(&amp;announces); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } // Mark the hashes as present at the remote node for _, block := range announces { p.MarkBlock(block.Hash) } // Schedule all the unknown hashes for retrieval // 把本地链没有的块hash找出来，交给fetcher去下载 unknown := make(newBlockHashesData, 0, len(announces)) for _, block := range announces { if !pm.blockchain.HasBlock(block.Hash, block.Number) { unknown = append(unknown, block) } } for _, block := range unknown { pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies) } // Notify announces the fetcher of the potential availability of a new block in // the network. // 通知fetcher（自己）有新块产生，没有块实体，有hash、高度等信息 func (f *Fetcher) Notify(peer string, hash common.Hash, number uint64, time time.Time, headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn) error { block := &amp;announce{ hash: hash, number: number, time: time, origin: peer, fetchHeader: headerFetcher, fetchBodies: bodyFetcher, } select { case f.notify &lt;- block: return nil case &lt;-f.quit: return errTerminated } } // fetcher.loop()的notify通道消息处理 case notification := &lt;-f.notify: // A block was announced, make sure the peer isn&#39;t DOSing us propAnnounceInMeter.Mark(1) count := f.announces[notification.origin] + 1 if count &gt; hashLimit { log.Debug(&quot;Peer exceeded outstanding announces&quot;, &quot;peer&quot;, notification.origin, &quot;limit&quot;, hashLimit) propAnnounceDOSMeter.Mark(1) break } // If we have a valid block number, check that it&#39;s potentially useful // 高度检查 if notification.number &gt; 0 { if dist := int64(notification.number) - int64(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist { log.Debug(&quot;Peer discarded announcement&quot;, &quot;peer&quot;, notification.origin, &quot;number&quot;, notification.number, &quot;hash&quot;, notification.hash, &quot;distance&quot;, dist) propAnnounceDropMeter.Mark(1) break } } // All is well, schedule the announce if block&#39;s not yet downloading // 检查是否已经在下载，已下载则忽略 if _, ok := f.fetching[notification.hash]; ok { break } if _, ok := f.completing[notification.hash]; ok { break } // 更新peer已经通知给我们的区块数量 f.announces[notification.origin] = count // 把通知信息加入到announced，供调度 f.announced[notification.hash] = append(f.announced[notification.hash], notification) if f.announceChangeHook != nil &amp;&amp; len(f.announced[notification.hash]) == 1 { f.announceChangeHook(notification.hash, true) } if len(f.announced) == 1 { // 有通知放入到announced，则重设0s定时器，loop的另外一个分支会处理这些通知 f.rescheduleFetch(fetchTimer) } fetcher获取完整区块 本节介绍fetcher获取完整区块的过程，这也是fetcher最重要的功能，会涉及到fetcher至少80%的代码。单独拉放一大节吧。 Fetcher的大头 Fetcher最主要的功能就是获取完整的区块，然后在合适的实际交给InsertChain去验证和插入到本地区块链。我们还是从宏观入手，看Fetcher是如何工作的，一定要先掌握好宏观，因为代码层面上没有这么清晰。 宏观 首先，看两个节点是如何交互，获取完整区块，使用时序图的方式看一下，见图6，流程很清晰不再文字介绍。 再看下获取区块过程中，fetcher内部的状态转移，它使用状态来记录，要获取的区块在什么阶段，见图7。我稍微解释一下： 收到NewBlockHashesMsg后，相关信息会记录到announced，进入announced状态，代表了本节点接收了消息。 announced由fetcher协程处理，经过校验后，会向给他发送消息的Peer发送请求，请求该区块的区块头，然后进入fetching状态。 获取区块头后，如果区块头表示没有交易和uncle，则转移到completing状态，并且使用区块头合成完整的区块，加入到queued优先级队列。 获取区块头后，如果区块头表示该区块有交易和uncle，则转移到fetched状态，然后发送请求，请求交易和uncle，然后转移到completing状态。 收到交易和uncle后，使用头、交易、uncle这3个信息，生成完整的区块，加入到队列queued。 微观 接下来就是从代码角度看如何获取完整区块的流程了，有点多，看不懂的时候，再回顾下上面宏观的介绍图。 首先看Fetcher的定义，它存放了通信数据和状态管理，捡加注释的看，上文提到的状态，里面都有。 // Fetcher is responsible for accumulating block announcements from various peers // and scheduling them for retrieval. // 积累块通知，然后调度获取这些块 type Fetcher struct { // Various event channels // 收到区块hash值的通道 notify chan *announce // 收到完整区块的通道 inject chan *inject blockFilter chan chan []*types.Block // 过滤header的通道的通道 headerFilter chan chan *headerFilterTask // 过滤body的通道的通道 bodyFilter chan chan *bodyFilterTask done chan common.Hash quit chan struct{} // Announce states // Peer已经给了本节点多少区块头通知 announces map[string]int // Per peer announce counts to prevent memory exhaustion // 已经announced的区块列表 announced map[common.Hash][]*announce // Announced blocks, scheduled for fetching // 正在fetching区块头的请求 fetching map[common.Hash]*announce // Announced blocks, currently fetching // 已经fetch到区块头，还差body的请求，用来获取body fetched map[common.Hash][]*announce // Blocks with headers fetched, scheduled for body retrieval // 已经得到区块头的 completing map[common.Hash]*announce // Blocks with headers, currently body-completing // Block cache // queue，优先级队列，高度做优先级 // queues，统计peer通告了多少块 // queued，代表这个块如队列了， queue *prque.Prque // Queue containing the import operations (block number sorted) queues map[string]int // Per peer block counts to prevent memory exhaustion queued map[common.Hash]*inject // Set of already queued blocks (to dedupe imports) // Callbacks getBlock blockRetrievalFn // Retrieves a block from the local chain verifyHeader headerVerifierFn // Checks if a block&#39;s headers have a valid proof of work，验证区块头，包含了PoW验证 broadcastBlock blockBroadcasterFn // Broadcasts a block to connected peers，广播给peer chainHeight chainHeightFn // Retrieves the current chain&#39;s height insertChain chainInsertFn // Injects a batch of blocks into the chain，插入区块到链的函数 dropPeer peerDropFn // Drops a peer for misbehaving // Testing hooks announceChangeHook func(common.Hash, bool) // Method to call upon adding or deleting a hash from the announce list queueChangeHook func(common.Hash, bool) // Method to call upon adding or deleting a block from the import queue fetchingHook func([]common.Hash) // Method to call upon starting a block (eth/61) or header (eth/62) fetch completingHook func([]common.Hash) // Method to call upon starting a block body fetch (eth/62) importedHook func(*types.Block) // Method to call upon successful block import (both eth/61 and eth/62) } NewBlockHashesMsg消息的处理前面的小节已经讲过了，不记得可向前翻看。这里从announced的状态处理说起。loop()中，fetchTimer超时后，代表了收到了消息通知，需要处理，会从announced中选择出需要处理的通知，然后创建请求，请求区块头，由于可能有很多节点都通知了它某个区块的Hash，所以随机的从这些发送消息的Peer中选择一个Peer，发送请求的时候，为每个Peer都创建了单独的协程。 case &lt;-fetchTimer.C: // At least one block&#39;s timer ran out, check for needing retrieval // 有区块通知，去处理 request := make(map[string][]common.Hash) for hash, announces := range f.announced { if time.Since(announces[0].time) &gt; arriveTimeout-gatherSlack { // Pick a random peer to retrieve from, reset all others // 可能有很多peer都发送了这个区块的hash值，随机选择一个peer announce := announces[rand.Intn(len(announces))] f.forgetHash(hash) // If the block still didn&#39;t arrive, queue for fetching // 本地还没有这个区块，创建获取区块的请求 if f.getBlock(hash) == nil { request[announce.origin] = append(request[announce.origin], hash) f.fetching[hash] = announce } } } // Send out all block header requests // 把所有的request发送出去 // 为每一个peer都创建一个协程，然后请求所有需要从该peer获取的请求 for peer, hashes := range request { log.Trace(&quot;Fetching scheduled headers&quot;, &quot;peer&quot;, peer, &quot;list&quot;, hashes) // Create a closure of the fetch and schedule in on a new thread fetchHeader, hashes := f.fetching[hashes[0]].fetchHeader, hashes go func() { if f.fetchingHook != nil { f.fetchingHook(hashes) } for _, hash := range hashes { headerFetchMeter.Mark(1) fetchHeader(hash) // Suboptimal, but protocol doesn&#39;t allow batch header retrievals } }() } // Schedule the next fetch if blocks are still pending f.rescheduleFetch(fetchTimer) 从Notify的调用中，可以看出，fetcherHeader()的实际函数是RequestOneHeader()，该函数使用的消息是GetBlockHeadersMsg，可以用来请求多个区块头，不过fetcher只请求一个。 pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies) // RequestOneHeader is a wrapper around the header query functions to fetch a // single header. It is used solely by the fetcher. func (p *peer) RequestOneHeader(hash common.Hash) error { p.Log().Debug(&quot;Fetching single header&quot;, &quot;hash&quot;, hash) return p2p.Send(p.rw, GetBlockHeadersMsg, &amp;getBlockHeadersData{Origin: hashOrNumber{Hash: hash}, Amount: uint64(1), Skip: uint64(0), Reverse: false}) } GetBlockHeadersMsg的处理如下：因为它是获取多个区块头的，所以处理起来比较“麻烦”，还好，fetcher只获取一个区块头，其处理在20行~33行，获取下一个区块头的处理逻辑，这里就不看了，最后调用SendBlockHeaders()将区块头发送给请求的节点，消息是BlockHeadersMsg。 // handleMsg() // Block header query, collect the requested headers and reply case msg.Code == GetBlockHeadersMsg: // Decode the complex header query var query getBlockHeadersData if err := msg.Decode(&amp;query); err != nil { return errResp(ErrDecode, &quot;%v: %v&quot;, msg, err) } hashMode := query.Origin.Hash != (common.Hash{}) // Gather headers until the fetch or network limits is reached // 收集区块头，直到达到限制 var ( bytes common.StorageSize headers []*types.Header unknown bool ) // 自己已知区块 &amp;&amp; 少于查询的数量 &amp;&amp; 大小小于2MB &amp;&amp; 小于能下载的最大数量 for !unknown &amp;&amp; len(headers) &lt; int(query.Amount) &amp;&amp; bytes &lt; softResponseLimit &amp;&amp; len(headers) &lt; downloader.MaxHeaderFetch { // Retrieve the next header satisfying the query // 获取区块头 var origin *types.Header if hashMode { // fetcher 使用的模式 origin = pm.blockchain.GetHeaderByHash(query.Origin.Hash) } else { origin = pm.blockchain.GetHeaderByNumber(query.Origin.Number) } if origin == nil { break } number := origin.Number.Uint64() headers = append(headers, origin) bytes += estHeaderRlpSize // Advance to the next header of the query // 下一个区块头的获取，不同策略，方式不同 switch { case query.Origin.Hash != (common.Hash{}) &amp;&amp; query.Reverse: // ... } } return p.SendBlockHeaders(headers) BlockHeadersMsg的处理很有意思，因为GetBlockHeadersMsg并不是fetcher独占的消息，downloader也可以调用，所以，响应消息的处理需要分辨出是fetcher请求的，还是downloader请求的。它的处理逻辑是：fetcher先过滤收到的区块头，如果fetcher不要的，那就是downloader的，在调用fetcher.FilterHeaders的时候，fetcher就将自己要的区块头拿走了。 // handleMsg() case msg.Code == BlockHeadersMsg: // A batch of headers arrived to one of our previous requests var headers []*types.Header if err := msg.Decode(&amp;headers); err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // If no headers were received, but we&#39;re expending a DAO fork check, maybe it&#39;s that // 检查是不是当前DAO的硬分叉 if len(headers) == 0 &amp;&amp; p.forkDrop != nil { // Possibly an empty reply to the fork header checks, sanity check TDs verifyDAO := true // If we already have a DAO header, we can check the peer&#39;s TD against it. If // the peer&#39;s ahead of this, it too must have a reply to the DAO check if daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != nil { if _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= 0 { verifyDAO = false } } // If we&#39;re seemingly on the same chain, disable the drop timer if verifyDAO { p.Log().Debug(&quot;Seems to be on the same side of the DAO fork&quot;) p.forkDrop.Stop() p.forkDrop = nil return nil } } // Filter out any explicitly requested headers, deliver the rest to the downloader // 过滤是不是fetcher请求的区块头，去掉fetcher请求的区块头再交给downloader filter := len(headers) == 1 if filter { // If it&#39;s a potential DAO fork check, validate against the rules // 检查是否硬分叉 if p.forkDrop != nil &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[0].Number) == 0 { // Disable the fork drop timer p.forkDrop.Stop() p.forkDrop = nil // Validate the header and either drop the peer or continue if err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[0]); err != nil { p.Log().Debug(&quot;Verified to be on the other side of the DAO fork, dropping&quot;) return err } p.Log().Debug(&quot;Verified to be on the same side of the DAO fork&quot;) return nil } // Irrelevant of the fork checks, send the header to the fetcher just in case // 使用fetcher过滤区块头 headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now()) } // 剩下的区块头交给downloader if len(headers) &gt; 0 || !filter { err := pm.downloader.DeliverHeaders(p.id, headers) if err != nil { log.Debug(&quot;Failed to deliver headers&quot;, &quot;err&quot;, err) } } FilterHeaders()是一个很有大智慧的函数，看起来耐人寻味，但实在妙。它要把所有的区块头，都传递给fetcher协程，还要获取fetcher协程处理后的结果。fetcher.headerFilter是存放通道的通道，而filter是存放包含区块头过滤任务的通道。它先把filter传递给了headerFilter，这样fetcher协程就在另外一段等待了，而后将headerFilterTask传入filter，fetcher就能读到数据了，处理后，再将数据写回filter而刚好被FilterHeaders函数处理了，该函数实际运行在handleMsg()的协程中。 每个Peer都会分配一个ProtocolManager然后处理该Peer的消息，但fetcher只有一个事件处理协程，如果不创建一个filter，fetcher哪知道是谁发给它的区块头呢？过滤之后，该如何发回去呢？ // FilterHeaders extracts all the headers that were explicitly requested by the fetcher, // returning those that should be handled differently. // 寻找出fetcher请求的区块头 func (f *Fetcher) FilterHeaders(peer string, headers []*types.Header, time time.Time) []*types.Header { log.Trace(&quot;Filtering headers&quot;, &quot;peer&quot;, peer, &quot;headers&quot;, len(headers)) // Send the filter channel to the fetcher // 任务通道 filter := make(chan *headerFilterTask) select { // 任务通道发送到这个通道 case f.headerFilter &lt;- filter: case &lt;-f.quit: return nil } // Request the filtering of the header list // 创建过滤任务，发送到任务通道 select { case filter &lt;- &amp;headerFilterTask{peer: peer, headers: headers, time: time}: case &lt;-f.quit: return nil } // Retrieve the headers remaining after filtering // 从任务通道，获取过滤的结果并返回 select { case task := &lt;-filter: return task.headers case &lt;-f.quit: return nil } } 接下来要看f.headerFilter的处理，这段代码有90行，它做了一下几件事： 从f.headerFilter取出filter，然后取出过滤任务task。 它把区块头分成3类：unknown这不是分是要返回给调用者的，即handleMsg(), incomplete存放还需要获取body的区块头，complete存放只包含区块头的区块。遍历所有的区块头，填到到对应的分类中，具体的判断可看18行的注释，记住宏观中将的状态转移图。 把unknonw中的区块返回给handleMsg()。 把 incomplete的区块头获取状态移动到fetched状态，然后触发定时器，以便去处理complete的区块。 把compelete的区块加入到queued。 // fetcher.loop() case filter := &lt;-f.headerFilter: // Headers arrived from a remote peer. Extract those that were explicitly // requested by the fetcher, and return everything else so it&#39;s delivered // to other parts of the system. // 收到从远端节点发送的区块头，过滤出fetcher请求的 // 从任务通道获取过滤任务 var task *headerFilterTask select { case task = &lt;-filter: case &lt;-f.quit: return } headerFilterInMeter.Mark(int64(len(task.headers))) // Split the batch of headers into unknown ones (to return to the caller), // known incomplete ones (requiring body retrievals) and completed blocks. // unknown的不是fetcher请求的，complete放没有交易和uncle的区块，有头就够了，incomplete放 // 还需要获取uncle和交易的区块 unknown, incomplete, complete := []*types.Header{}, []*announce{}, []*types.Block{} // 遍历所有收到的header for _, header := range task.headers { hash := header.Hash() // Filter fetcher-requested headers from other synchronisation algorithms // 是正在获取的hash，并且对应请求的peer，并且未fetched，未completing，未queued if announce := f.fetching[hash]; announce != nil &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == nil &amp;&amp; f.completing[hash] == nil &amp;&amp; f.queued[hash] == nil { // If the delivered header does not match the promised number, drop the announcer // 高度校验，竟然不匹配，扰乱秩序，peer肯定是坏蛋。 if header.Number.Uint64() != announce.number { log.Trace(&quot;Invalid block number fetched&quot;, &quot;peer&quot;, announce.origin, &quot;hash&quot;, header.Hash(), &quot;announced&quot;, announce.number, &quot;provided&quot;, header.Number) f.dropPeer(announce.origin) f.forgetHash(hash) continue } // Only keep if not imported by other means // 本地链没有当前区块 if f.getBlock(hash) == nil { announce.header = header announce.time = task.time // If the block is empty (header only), short circuit into the final import queue // 如果区块没有交易和uncle，加入到complete if header.TxHash == types.DeriveSha(types.Transactions{}) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header{}) { log.Trace(&quot;Block empty, skipping body retrieval&quot;, &quot;peer&quot;, announce.origin, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash()) block := types.NewBlockWithHeader(header) block.ReceivedAt = task.time complete = append(complete, block) f.completing[hash] = announce continue } // Otherwise add to the list of blocks needing completion // 否则就是不完整的区块 incomplete = append(incomplete, announce) } else { log.Trace(&quot;Block already imported, discarding header&quot;, &quot;peer&quot;, announce.origin, &quot;number&quot;, header.Number, &quot;hash&quot;, header.Hash()) f.forgetHash(hash) } } else { // Fetcher doesn&#39;t know about it, add to the return list // 没请求过的header unknown = append(unknown, header) } } // 把未知的区块头，再传递会filter headerFilterOutMeter.Mark(int64(len(unknown))) select { case filter &lt;- &amp;headerFilterTask{headers: unknown, time: task.time}: case &lt;-f.quit: return } // Schedule the retrieved headers for body completion // 把未完整的区块加入到fetched，跳过已经在completeing中的，然后触发completeTimer定时器 for _, announce := range incomplete { hash := announce.header.Hash() if _, ok := f.completing[hash]; ok { continue } f.fetched[hash] = append(f.fetched[hash], announce) if len(f.fetched) == 1 { f.rescheduleComplete(completeTimer) } } // Schedule the header-only blocks for import // 把只有头的区块入队列 for _, block := range complete { if announce := f.completing[block.Hash()]; announce != nil { f.enqueue(announce.origin, block) } } 跟随状态图的转义，剩下的工作是fetched转移到completing，上面的流程已经触发了completeTimer定时器，超时后就会处理，流程与请求Header类似，不再赘述，此时发送的请求消息是GetBlockBodiesMsg，实际调的函数是RequestBodies。 // fetcher.loop() case &lt;-completeTimer.C: // At least one header&#39;s timer ran out, retrieve everything // 至少有1个header已经获取完了 request := make(map[string][]common.Hash) // 遍历所有待获取body的announce for hash, announces := range f.fetched { // Pick a random peer to retrieve from, reset all others // 随机选一个Peer发送请求，因为可能已经有很多Peer通知它这个区块了 announce := announces[rand.Intn(len(announces))] f.forgetHash(hash) // If the block still didn&#39;t arrive, queue for completion // 如果本地没有这个区块，则放入到completing，创建请求 if f.getBlock(hash) == nil { request[announce.origin] = append(request[announce.origin], hash) f.completing[hash] = announce } } // Send out all block body requests // 发送所有的请求，获取body，依然是每个peer一个单独协程 for peer, hashes := range request { log.Trace(&quot;Fetching scheduled bodies&quot;, &quot;peer&quot;, peer, &quot;list&quot;, hashes) // Create a closure of the fetch and schedule in on a new thread if f.completingHook != nil { f.completingHook(hashes) } bodyFetchMeter.Mark(int64(len(hashes))) go f.completing[hashes[0]].fetchBodies(hashes) } // Schedule the next fetch if blocks are still pending f.rescheduleComplete(completeTimer) handleMsg()处理该消息也是干净利落，直接获取RLP格式的body，然后发送响应消息。 // handleMsg() case msg.Code == GetBlockBodiesMsg: // Decode the retrieval message msgStream := rlp.NewStream(msg.Payload, uint64(msg.Size)) if _, err := msgStream.List(); err != nil { return err } // Gather blocks until the fetch or network limits is reached var ( hash common.Hash bytes int bodies []rlp.RawValue ) // 遍历所有请求 for bytes &lt; softResponseLimit &amp;&amp; len(bodies) &lt; downloader.MaxBlockFetch { // Retrieve the hash of the next block if err := msgStream.Decode(&amp;hash); err == rlp.EOL { break } else if err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // Retrieve the requested block body, stopping if enough was found // 获取body，RLP格式 if data := pm.blockchain.GetBodyRLP(hash); len(data) != 0 { bodies = append(bodies, data) bytes += len(data) } } return p.SendBlockBodiesRLP(bodies) 响应消息BlockBodiesMsg的处理与处理获取header的处理原理相同，先交给fetcher过滤，然后剩下的才是downloader的。需要注意一点，响应消息里只包含交易列表和叔块列表。 // handleMsg() case msg.Code == BlockBodiesMsg: // A batch of block bodies arrived to one of our previous requests var request blockBodiesData if err := msg.Decode(&amp;request); err != nil { return errResp(ErrDecode, &quot;msg %v: %v&quot;, msg, err) } // Deliver them all to the downloader for queuing // 传递给downloader去处理 transactions := make([][]*types.Transaction, len(request)) uncles := make([][]*types.Header, len(request)) for i, body := range request { transactions[i] = body.Transactions uncles[i] = body.Uncles } // Filter out any explicitly requested bodies, deliver the rest to the downloader // 先让fetcher过滤去fetcher请求的body，剩下的给downloader filter := len(transactions) &gt; 0 || len(uncles) &gt; 0 if filter { transactions, uncles = pm.fetcher.FilterBodies(p.id, transactions, uncles, time.Now()) } // 剩下的body交给downloader if len(transactions) &gt; 0 || len(uncles) &gt; 0 || !filter { err := pm.downloader.DeliverBodies(p.id, transactions, uncles) if err != nil { log.Debug(&quot;Failed to deliver bodies&quot;, &quot;err&quot;, err) } } 过滤函数的原理也与Header相同。 // FilterBodies extracts all the block bodies that were explicitly requested by // the fetcher, returning those that should be handled differently. // 过去出fetcher请求的body，返回它没有处理的，过程类型header的处理 func (f *Fetcher) FilterBodies(peer string, transactions [][]*types.Transaction, uncles [][]*types.Header, time time.Time) ([][]*types.Transaction, [][]*types.Header) { log.Trace(&quot;Filtering bodies&quot;, &quot;peer&quot;, peer, &quot;txs&quot;, len(transactions), &quot;uncles&quot;, len(uncles)) // Send the filter channel to the fetcher filter := make(chan *bodyFilterTask) select { case f.bodyFilter &lt;- filter: case &lt;-f.quit: return nil, nil } // Request the filtering of the body list select { case filter &lt;- &amp;bodyFilterTask{peer: peer, transactions: transactions, uncles: uncles, time: time}: case &lt;-f.quit: return nil, nil } // Retrieve the bodies remaining after filtering select { case task := &lt;-filter: return task.transactions, task.uncles case &lt;-f.quit: return nil, nil } } 实际过滤body的处理瞧一下，这和Header的处理是不同的。直接看不点： 它要的区块，单独取出来存到blocks中，它不要的继续留在task中。 判断是不是fetcher请求的方法：如果交易列表和叔块列表计算出的hash值与区块头中的一样，并且消息来自请求的Peer，则就是fetcher请求的。 将blocks中的区块加入到queued，终结。 case filter := &lt;-f.bodyFilter: // Block bodies arrived, extract any explicitly requested blocks, return the rest var task *bodyFilterTask select { case task = &lt;-filter: case &lt;-f.quit: return } bodyFilterInMeter.Mark(int64(len(task.transactions))) blocks := []*types.Block{} // 获取的每个body的txs列表和uncle列表 // 遍历每个区块的txs列表和uncle列表，计算hash后判断是否是当前fetcher请求的body for i := 0; i &lt; len(task.transactions) &amp;&amp; i &lt; len(task.uncles); i++ { // Match up a body to any possible completion request matched := false // 遍历所有保存的请求，因为tx和uncle，不知道它是属于哪个区块的，只能去遍历所有的请求，通常量不大，所以遍历没有性能影响 for hash, announce := range f.completing { if f.queued[hash] == nil { // 把传入的每个块的hash和unclehash和它请求出去的记录进行对比，匹配则说明是fetcher请求的区块body txnHash := types.DeriveSha(types.Transactions(task.transactions[i])) uncleHash := types.CalcUncleHash(task.uncles[i]) if txnHash == announce.header.TxHash &amp;&amp; uncleHash == announce.header.UncleHash &amp;&amp; announce.origin == task.peer { // Mark the body matched, reassemble if still unknown matched = true // 如果当前链还没有这个区块，则收集这个区块，合并成新区块 if f.getBlock(hash) == nil { block := types.NewBlockWithHeader(announce.header).WithBody(task.transactions[i], task.uncles[i]) block.ReceivedAt = task.time blocks = append(blocks, block) } else { f.forgetHash(hash) } } } } // 从task中移除fetcher请求的数据 if matched { task.transactions = append(task.transactions[:i], task.transactions[i+1:]...) task.uncles = append(task.uncles[:i], task.uncles[i+1:]...) i-- continue } } // 将剩余的数据返回 bodyFilterOutMeter.Mark(int64(len(task.transactions))) select { case filter &lt;- task: case &lt;-f.quit: return } // Schedule the retrieved blocks for ordered import // 把收集的区块加入到队列 for _, block := range blocks { if announce := f.completing[block.Hash()]; announce != nil { f.enqueue(announce.origin, block) } } } 至此，fetcher获取完整区块的流程讲完了，fetcher模块中80%的代码也都贴出来了，还有2个值得看看的函数： forgetHash(hash common.Hash)：用于清空指定hash指的记/状态录信息。 forgetBlock(hash common.Hash)：用于从队列中移除一个区块。 最后了，再回到开始看看fetcher模块和新区块的传播流程，有没有豁然开朗。 如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。 本文作者：大彬 如果喜欢本文，随意转载，但请保留此原文链接：http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/","@type":"BlogPosting","url":"/2019/01/05/3990f54d0a770de377df2a3ef99396ba.html","headline":"以太坊源码分析：fetcher模块和区块传播","dateModified":"2019-01-05T00:00:00+08:00","datePublished":"2019-01-05T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/01/05/3990f54d0a770de377df2a3ef99396ba.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>以太坊源码分析：fetcher模块和区块传播</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright"> 
  <svg class="icon" title="CSDN认证原创" aria-hidden="true" style="width:53px; height: 18px; vertical-align: -4px;"> 
   <use xlink:href="#CSDN_Cert"></use> 
  </svg> 版权声明：版权归lessisbetter.site所有，转载请请声明 https://blog.csdn.net/m0_43499523/article/details/85852204 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="_3"></a>前言</h1> 
  <p>这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。</p> 
  <p>当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。</p> 
  <!--more--> 
  <h1><a id="_11"></a>总体过程和传播策略</h1> 
  <p>本节从宏观角度介绍，节点产生区块后，为了传播给远端节点做了啥，远端节点收到区块后又做了什么，每个节点都连接了很多Peer，它传播的策略是什么样的？</p> 
  <p>总体流程和策略可以总结为，传播给远端Peer节点，Peer验证区块无误后，加入到本地区块链，继续传播新区块信息。具体过程如下。</p> 
  <p>先看总体过程。产生区块后，<code>miner</code>模块会发布一个事件<code>NewMinedBlockEvent</code>，订阅事件的协程收到事件后，就会把新区块的消息，广播给它所有的peer，peer收到消息后，会交给自己的fetcher模块处理，fetcher进行基本的验证后，区块没问题，发现这个区块就是本地链需要的下一个区块，则交给<code>blockChain</code>进一步进行完整的验证，这个过程会执行区块所有的交易，无误后把区块加入到本地链，写入数据库，这个过程就是下面的流程图，图1。</p> 
  <p><img src="http://cdn.lessisbetter.site/image-20180821115214521.png-own" alt="图1：新区块传播总体流程图"></p> 
  <p>总体流程图，能看到有个分叉，是因为节点传播新区块是有策略的。它的传播策略为：</p> 
  <ol> 
   <li>假如节点连接了<code>N</code>个Peer，它只向Peer列表的<code>sqrt(N)</code>个Peer广播<strong>完整的区块</strong>消息。</li> 
   <li>向所有的Peer广播<strong>只包含区块Hash</strong>的消息。</li> 
  </ol> 
  <p>策略图的效果如图2，红色节点将区块传播给黄色节点：<img src="http://cdn.lessisbetter.site/image-20180821114210114.png-own" alt="图2：产生区块后传播给相邻节点"></p> 
  <p>收到区块Hash的节点，需要从发送给它消息的Peer那里获取对应的完整区块，获取区块后就会按照图1的流程，加入到fetcher队列，最终插入本地区块链后，<strong>将区块的Hash值广播给和它相连，但还不知道这个区块的Peer</strong>。非产生区块节点的策略图，如图3，黄色节点将区块Hash传播给青色节点：<img src="http://cdn.lessisbetter.site/image-20180821114756055.png-own" alt="图3：非产块节点传播新区块"></p> 
  <p>至此，可以看出<strong>以太坊采用以石击水的方式，像水纹一样，层层扩散新产生的区块</strong>。</p> 
  <h1><a id="Fetcher_32"></a>Fetcher模块是干啥的</h1> 
  <p>fetcher模块的功能，就是收集其他Peer通知它的区块信息：1）完整的区块2）区块Hash消息。根据通知的消息，获取完整的区块，然后传递给<code>eth</code>模块把区块插入区块链。</p> 
  <p>如果是完整区块，就可以传递给eth插入区块，如果只有区块Hash，则需要从其他的Peer获取此完整的区块，然后再传递给eth插入区块。</p> 
  <p><img src="http://cdn.lessisbetter.site/image-20180821175330370.png-own" alt="fetcher功能抽象"></p> 
  <h1><a id="_40"></a>源码解读</h1> 
  <p>本节介绍区块传播和处理的细节东西，方式仍然是先用图解释流程，再是代码流程。</p> 
  <h2><a id="_44"></a>产块节点的传播新区块</h2> 
  <p>节点产生区块后，广播的流程可以表示为图4：</p> 
  <ol> 
   <li>发布事件</li> 
   <li>事件处理函数选择要广播完整的Peer，然后将区块加入到它们的队列</li> 
   <li>事件处理函数把区块Hash添加到所有Peer的另外一个通知队列</li> 
   <li>每个Peer的广播处理函数，会遍历它的待广播区块队列和通知队列，把数据封装成消息，调用P2P接口发送出去</li> 
  </ol> 
  <p><img src="http://cdn.lessisbetter.site/image-20180821115537184.png-own" alt="图4：产块节点的传播图"></p> 
  <p>再看下代码上的细节。</p> 
  <ol> 
   <li><code>worker.wait()</code>函数发布事件<code>NewMinedBlockEvent</code>。</li> 
   <li><code>ProtocolManager.minedBroadcastLoop()</code>是事件处理函数。它调用了2次<code>pm.BroadcastBlock()</code>。</li> 
  </ol> 
  <pre><code class="prism language-go"><span class="token comment">// Mined broadcast loop</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>pm <span class="token operator">*</span>ProtocolManager<span class="token punctuation">)</span> <span class="token function">minedBroadcastLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// automatically stops if unsubscribe</span>
	<span class="token keyword">for</span> obj <span class="token operator">:=</span> <span class="token keyword">range</span> pm<span class="token punctuation">.</span>minedBlockSub<span class="token punctuation">.</span><span class="token function">Chan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">switch</span> ev <span class="token operator">:=</span> obj<span class="token punctuation">.</span>Data<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> core<span class="token punctuation">.</span>NewMinedBlockEvent<span class="token punctuation">:</span>
			pm<span class="token punctuation">.</span><span class="token function">BroadcastBlock</span><span class="token punctuation">(</span>ev<span class="token punctuation">.</span>Block<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment">// First propagate block to peers</span>
			pm<span class="token punctuation">.</span><span class="token function">BroadcastBlock</span><span class="token punctuation">(</span>ev<span class="token punctuation">.</span>Block<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// Only then announce to the rest</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <ol> 
   <li><code>pm.BroadcastBlock()</code>的入参<code>propagate</code>为真时，向部分Peer广播完整的区块，调用<code>peer.AsyncSendNewBlock()</code>，否则向所有Peer广播区块头，调用<code>peer.AsyncSendNewBlockHash()</code>，这2个函数就是把数据放入队列，此处不再放代码。</li> 
  </ol> 
  <pre><code class="prism language-go"><span class="token comment">// BroadcastBlock will either propagate a block to a subset of it's peers, or</span>
<span class="token comment">// will only announce it's availability (depending what's requested).</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>pm <span class="token operator">*</span>ProtocolManager<span class="token punctuation">)</span> <span class="token function">BroadcastBlock</span><span class="token punctuation">(</span>block <span class="token operator">*</span>types<span class="token punctuation">.</span>Block<span class="token punctuation">,</span> propagate <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	hash <span class="token operator">:=</span> block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	peers <span class="token operator">:=</span> pm<span class="token punctuation">.</span>peers<span class="token punctuation">.</span><span class="token function">PeersWithoutBlock</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>

	<span class="token comment">// If propagation is requested, send to a subset of the peer</span>
	<span class="token comment">// 这种情况，要把区块广播给部分peer</span>
	<span class="token keyword">if</span> propagate <span class="token punctuation">{</span>
		<span class="token comment">// Calculate the TD of the block (it's not imported yet, so block.Td is not valid)</span>
		<span class="token comment">// 计算新的总难度</span>
		<span class="token keyword">var</span> td <span class="token operator">*</span>big<span class="token punctuation">.</span>Int
		<span class="token keyword">if</span> parent <span class="token operator">:=</span> pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">GetBlock</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span><span class="token function">ParentHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">NumberU64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> parent <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			td <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span><span class="token function">Difficulty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">GetTd</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span><span class="token function">ParentHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">NumberU64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Propagating dangling block"</span><span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Send the block to a subset of our peers</span>
		<span class="token comment">// 广播区块给部分peer</span>
		transfer <span class="token operator">:=</span> peers<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>peers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
		<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> peer <span class="token operator">:=</span> <span class="token keyword">range</span> transfer <span class="token punctuation">{</span>
			peer<span class="token punctuation">.</span><span class="token function">AsyncSendNewBlock</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> td<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Propagated block"</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">"recipients"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>transfer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"duration"</span><span class="token punctuation">,</span> common<span class="token punctuation">.</span><span class="token function">PrettyDuration</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span>ReceivedAt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Otherwise if the block is indeed in out own chain, announce it</span>
	<span class="token comment">// 把区块hash值广播给所有peer</span>
	<span class="token keyword">if</span> pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">HasBlock</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">NumberU64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> peer <span class="token operator">:=</span> <span class="token keyword">range</span> peers <span class="token punctuation">{</span>
			peer<span class="token punctuation">.</span><span class="token function">AsyncSendNewBlockHash</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Announced block"</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">"recipients"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>peers<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"duration"</span><span class="token punctuation">,</span> common<span class="token punctuation">.</span><span class="token function">PrettyDuration</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span>ReceivedAt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <ol> 
   <li> <p><code>peer.broadcase()</code>是每个Peer连接的广播函数，它只广播3种消息：交易、完整的区块、区块的Hash，这样表明了节点只会主动广播这3中类型的数据，剩余的数据同步，都是通过<strong>请求-响应</strong>的方式。</p> <pre><code class="prism language-go"><span class="token comment">// broadcast is a write loop that multiplexes block propagations, announcements</span>
<span class="token comment">// and transaction broadcasts into the remote peer. The goal is to have an async</span>
<span class="token comment">// writer that does not lock up node internals.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>peer<span class="token punctuation">)</span> <span class="token function">broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token keyword">select</span> <span class="token punctuation">{</span>
		<span class="token comment">// 广播交易</span>
		<span class="token keyword">case</span> txs <span class="token operator">:=</span> <span class="token operator">&lt;-</span>p<span class="token punctuation">.</span>queuedTxs<span class="token punctuation">:</span>
			<span class="token keyword">if</span> err <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token function">SendTransactions</span><span class="token punctuation">(</span>txs<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				<span class="token keyword">return</span>
			<span class="token punctuation">}</span>
			p<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Broadcast transactions"</span><span class="token punctuation">,</span> <span class="token string">"count"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>txs<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token comment">// 广播完整的新区块</span>
		<span class="token keyword">case</span> prop <span class="token operator">:=</span> <span class="token operator">&lt;-</span>p<span class="token punctuation">.</span>queuedProps<span class="token punctuation">:</span>
			<span class="token keyword">if</span> err <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token function">SendNewBlock</span><span class="token punctuation">(</span>prop<span class="token punctuation">.</span>block<span class="token punctuation">,</span> prop<span class="token punctuation">.</span>td<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				<span class="token keyword">return</span>
			<span class="token punctuation">}</span>
			p<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Propagated block"</span><span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> prop<span class="token punctuation">.</span>block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> prop<span class="token punctuation">.</span>block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"td"</span><span class="token punctuation">,</span> prop<span class="token punctuation">.</span>td<span class="token punctuation">)</span>

		<span class="token comment">// 广播区块Hash</span>
		<span class="token keyword">case</span> block <span class="token operator">:=</span> <span class="token operator">&lt;-</span>p<span class="token punctuation">.</span>queuedAnns<span class="token punctuation">:</span>
			<span class="token keyword">if</span> err <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token function">SendNewBlockHashes</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">{</span>block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">uint64</span><span class="token punctuation">{</span>block<span class="token punctuation">.</span><span class="token function">NumberU64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				<span class="token keyword">return</span>
			<span class="token punctuation">}</span>
			p<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Announced block"</span><span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>p<span class="token punctuation">.</span>term<span class="token punctuation">:</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li> 
  </ol> 
  <h2><a id="Peer_153"></a>Peer节点处理新区块</h2> 
  <p>本节介绍远端节点收到2种区块同步消息的处理，其中<code>NewBlockMsg</code>的处理流程比较清晰，也简洁。<code>NewBlockHashesMsg</code>消息的处理就绕了2绕，从总体流程图1上能看出来，它需要先从给他发送消息Peer那里获取到完整的区块，剩下的流程和<code>NewBlockMsg</code>又一致了。</p> 
  <p>这部分涉及的模块多，画出来有种眼花缭乱的感觉，但只要抓住上面的主线，代码看起来还是很清晰的。通过图5先看下整体流程。</p> 
  <p>消息处理的起点是<code>ProtocolManager.handleMsg</code>，<code>NewBlockMsg</code>的处理流程是蓝色标记的区域，红色区域是单独的协程，是fetcher处理队列中区块的流程，如果从队列中取出的区块是当前链需要的，校验后，调用<code>blockchian.InsertChain()</code>把区块插入到区块链，最后写入数据库，这是黄色部分。最后，绿色部分是<code>NewBlockHashesMsg</code>的处理流程，代码流程上是比较复杂的，为了能通过图描述整体流程，我把它简化掉了。</p> 
  <p><img src="http://cdn.lessisbetter.site/image-20180821143403650.png-own" alt="图5：远端节点处理新区块"></p> 
  <p>仔细看看这幅图，掌握整体的流程后，接下来看每个步骤的细节。</p> 
  <h3><a id="NewBlockMsg_165"></a>NewBlockMsg的处理</h3> 
  <p>本节介绍节点收到完整区块的处理，流程如下：</p> 
  <ol> 
   <li>首先进行RLP编解码，然后标记发送消息的Peer已经知道这个区块，这样本节点最后广播这个区块的Hash时，不会再发送给该Peer。</li> 
   <li>将区块存入到fetcher的队列，<code>调用fetcher.Enqueue</code>。</li> 
   <li>更新Peer的Head位置，然后判断本地链是否落后于Peer的链，如果是，则通过Peer更新本地链。</li> 
  </ol> 
  <p>只看<code>handle.Msg()</code>的<code>NewBlockMsg</code>相关的部分。</p> 
  <pre><code class="prism language-go"><span class="token keyword">case</span> msg<span class="token punctuation">.</span>Code <span class="token operator">==</span> NewBlockMsg<span class="token punctuation">:</span>
	<span class="token comment">// Retrieve and decode the propagated block</span>
	<span class="token comment">// 收到新区块，解码，赋值接收数据</span>
	<span class="token keyword">var</span> request newBlockData
	<span class="token keyword">if</span> err <span class="token operator">:=</span> msg<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">errResp</span><span class="token punctuation">(</span>ErrDecode<span class="token punctuation">,</span> <span class="token string">"%v: %v"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	request<span class="token punctuation">.</span>Block<span class="token punctuation">.</span>ReceivedAt <span class="token operator">=</span> msg<span class="token punctuation">.</span>ReceivedAt
	request<span class="token punctuation">.</span>Block<span class="token punctuation">.</span>ReceivedFrom <span class="token operator">=</span> p

	<span class="token comment">// Mark the peer as owning the block and schedule it for import</span>
	<span class="token comment">// 标记peer知道这个区块</span>
	p<span class="token punctuation">.</span><span class="token function">MarkBlock</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// 为啥要如队列？已经得到完整的区块了</span>
	<span class="token comment">// 答：存入fetcher的优先级队列，fetcher会从队列中选取当前高度需要的块</span>
	pm<span class="token punctuation">.</span>fetcher<span class="token punctuation">.</span><span class="token function">Enqueue</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> request<span class="token punctuation">.</span>Block<span class="token punctuation">)</span>

	<span class="token comment">// Assuming the block is importable by the peer, but possibly not yet done so,</span>
	<span class="token comment">// calculate the head hash and TD that the peer truly must have.</span>
	<span class="token comment">// 截止到parent区块的头和难度</span>
	<span class="token keyword">var</span> <span class="token punctuation">(</span>
		trueHead <span class="token operator">=</span> request<span class="token punctuation">.</span>Block<span class="token punctuation">.</span><span class="token function">ParentHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		trueTD   <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>TD<span class="token punctuation">,</span> request<span class="token punctuation">.</span>Block<span class="token punctuation">.</span><span class="token function">Difficulty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">)</span>
	<span class="token comment">// Update the peers total difficulty if better than the previous</span>
	<span class="token comment">// 如果收到的块的难度大于peer之前的，以及自己本地的，就去和这个peer同步</span>
	<span class="token comment">// 问题：就只用了一下块里的hash指，为啥不直接使用这个块呢，如果这个块不能用，干嘛不少发送些数据，减少网络负载呢。</span>
	<span class="token comment">// 答案：实际上，这个块加入到了优先级队列中，当fetcher的loop检查到当前下一个区块的高度，正是队列中有的，则不再向peer请求</span>
	<span class="token comment">// 该区块，而是直接使用该区块，检查无误后交给block chain执行insertChain</span>
	<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> td <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token function">Head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> trueTD<span class="token punctuation">.</span><span class="token function">Cmp</span><span class="token punctuation">(</span>td<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		p<span class="token punctuation">.</span><span class="token function">SetHead</span><span class="token punctuation">(</span>trueHead<span class="token punctuation">,</span> trueTD<span class="token punctuation">)</span>

		<span class="token comment">// Schedule a sync if above ours. Note, this will not fire a sync for a gap of</span>
		<span class="token comment">// a singe block (as the true TD is below the propagated block), however this</span>
		<span class="token comment">// scenario should easily be covered by the fetcher.</span>
		currentBlock <span class="token operator">:=</span> pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">CurrentBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> trueTD<span class="token punctuation">.</span><span class="token function">Cmp</span><span class="token punctuation">(</span>pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">GetTd</span><span class="token punctuation">(</span>currentBlock<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> currentBlock<span class="token punctuation">.</span><span class="token function">NumberU64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token keyword">go</span> pm<span class="token punctuation">.</span><span class="token function">synchronise</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token comment">//------------------------ 以上 handleMsg</span>

<span class="token comment">// Enqueue tries to fill gaps the the fetcher's future import queue.</span>
<span class="token comment">// 发给inject通道，当前协程在handleMsg，通过通道发送给fetcher的协程处理</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Fetcher<span class="token punctuation">)</span> <span class="token function">Enqueue</span><span class="token punctuation">(</span>peer <span class="token builtin">string</span><span class="token punctuation">,</span> block <span class="token operator">*</span>types<span class="token punctuation">.</span>Block<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	op <span class="token operator">:=</span> <span class="token operator">&amp;</span>inject<span class="token punctuation">{</span>
		origin<span class="token punctuation">:</span> peer<span class="token punctuation">,</span>
		block<span class="token punctuation">:</span>  block<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> f<span class="token punctuation">.</span>inject <span class="token operator">&lt;-</span> op<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span> errTerminated
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//------------------------ 以下 fetcher.loop处理inject部分</span>
<span class="token keyword">case</span> op <span class="token operator">:=</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>inject<span class="token punctuation">:</span>
	<span class="token comment">// A direct block insertion was requested, try and fill any pending gaps</span>
	<span class="token comment">// 区块加入队列，首先也填入未决的间距</span>
	propBroadcastInMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	f<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>op<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> op<span class="token punctuation">.</span>block<span class="token punctuation">)</span>

<span class="token comment">//------------------------ 如队列函数</span>

<span class="token comment">// enqueue schedules a new future import operation, if the block to be imported</span>
<span class="token comment">// has not yet been seen.</span>
<span class="token comment">// 把导入的新区块放进来</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Fetcher<span class="token punctuation">)</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>peer <span class="token builtin">string</span><span class="token punctuation">,</span> block <span class="token operator">*</span>types<span class="token punctuation">.</span>Block<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	hash <span class="token operator">:=</span> block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// Ensure the peer isn't DOSing us</span>
	<span class="token comment">// 防止peer的DOS攻击</span>
	count <span class="token operator">:=</span> f<span class="token punctuation">.</span>queues<span class="token punctuation">[</span>peer<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
	<span class="token keyword">if</span> count <span class="token operator">&gt;</span> blockLimit <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Discarded propagated block, exceeded allowance"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">"limit"</span><span class="token punctuation">,</span> blockLimit<span class="token punctuation">)</span>
		propBroadcastDOSMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		f<span class="token punctuation">.</span><span class="token function">forgetHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Discard any past or too distant blocks</span>
	<span class="token comment">// 高度检查：未来太远的块丢弃</span>
	<span class="token keyword">if</span> dist <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span><span class="token function">NumberU64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">int64</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">chainHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> dist <span class="token operator">&lt;</span> <span class="token operator">-</span>maxUncleDist <span class="token operator">||</span> dist <span class="token operator">&gt;</span> maxQueueDist <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Discarded propagated block, too far away"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">"distance"</span><span class="token punctuation">,</span> dist<span class="token punctuation">)</span>
		propBroadcastDropMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		f<span class="token punctuation">.</span><span class="token function">forgetHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Schedule the block for future importing</span>
	<span class="token comment">// 块先加入优先级队列，加入链之前，还有很多要做</span>
	<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> f<span class="token punctuation">.</span>queued<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
		op <span class="token operator">:=</span> <span class="token operator">&amp;</span>inject<span class="token punctuation">{</span>
			origin<span class="token punctuation">:</span> peer<span class="token punctuation">,</span>
			block<span class="token punctuation">:</span>  block<span class="token punctuation">,</span>
		<span class="token punctuation">}</span>
		f<span class="token punctuation">.</span>queues<span class="token punctuation">[</span>peer<span class="token punctuation">]</span> <span class="token operator">=</span> count
		f<span class="token punctuation">.</span>queued<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">=</span> op
		f<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token function">float32</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span><span class="token function">NumberU64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> f<span class="token punctuation">.</span>queueChangeHook <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			f<span class="token punctuation">.</span><span class="token function">queueChangeHook</span><span class="token punctuation">(</span>op<span class="token punctuation">.</span>block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Queued propagated block"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">"queued"</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <h3><a id="fetcher_283"></a>fetcher队列处理</h3> 
  <p>本节我们看看，区块加入队列后，fetcher如何处理区块，为何不直接校验区块，插入到本地链？</p> 
  <p>由于以太坊又Uncle的机制，节点可能收到老一点的一些区块。另外，节点可能由于网络原因，落后了几个区块，所以可能收到“未来”的一些区块，这些区块都不能直接插入到本地链。</p> 
  <p>区块入的队列是一个优先级队列，高度低的区块会被优先取出来。<code>fetcher.loop</code>是单独协程，不断运转，清理fecther中的事务和事件。首先会清理正在<code>fetching</code>的区块，但已经超时。然后处理优先级队列中的区块，判断高度是否是下一个区块，如果是则调用<code>f.insert()</code>函数，校验后调用<code>BlockChain.InsertChain()</code>，成功插入后，<strong>广播新区块的Hash</strong>。</p> 
  <pre><code class="prism language-go"><span class="token comment">// Loop is the main fetcher loop, checking and processing various notification</span>
<span class="token comment">// events.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Fetcher<span class="token punctuation">)</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// Iterate the block fetching until a quit is requested</span>
	fetchTimer <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	completeTimer <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token comment">// Clean up any expired block fetches</span>
		<span class="token comment">// 清理过期的区块</span>
		<span class="token keyword">for</span> hash<span class="token punctuation">,</span> announce <span class="token operator">:=</span> <span class="token keyword">range</span> f<span class="token punctuation">.</span>fetching <span class="token punctuation">{</span>
			<span class="token keyword">if</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>announce<span class="token punctuation">.</span>time<span class="token punctuation">)</span> <span class="token operator">&gt;</span> fetchTimeout <span class="token punctuation">{</span>
				f<span class="token punctuation">.</span><span class="token function">forgetHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Import any queued blocks that could potentially fit</span>
		<span class="token comment">// 导入队列中合适的块</span>
		height <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">chainHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> <span class="token operator">!</span>f<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			op <span class="token operator">:=</span> f<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">PopItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>inject<span class="token punctuation">)</span>
			hash <span class="token operator">:=</span> op<span class="token punctuation">.</span>block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> f<span class="token punctuation">.</span>queueChangeHook <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				f<span class="token punctuation">.</span><span class="token function">queueChangeHook</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// If too high up the chain or phase, continue later</span>
			<span class="token comment">// 块不是链需要的下一个块，再入优先级队列，停止循环</span>
			number <span class="token operator">:=</span> op<span class="token punctuation">.</span>block<span class="token punctuation">.</span><span class="token function">NumberU64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> number <span class="token operator">&gt;</span> height<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span>
				f<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token function">float32</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">if</span> f<span class="token punctuation">.</span>queueChangeHook <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
					f<span class="token punctuation">.</span><span class="token function">queueChangeHook</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">break</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// Otherwise if fresh and still unknown, try and import</span>
			<span class="token comment">// 高度正好是我们想要的，并且链上也没有这个块</span>
			<span class="token keyword">if</span> number<span class="token operator">+</span>maxUncleDist <span class="token operator">&lt;</span> height <span class="token operator">||</span> f<span class="token punctuation">.</span><span class="token function">getBlock</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				f<span class="token punctuation">.</span><span class="token function">forgetBlock</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 那么，块插入链</span>
			f<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>op<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> op<span class="token punctuation">.</span>block<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
        
        <span class="token comment">//省略</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Fetcher<span class="token punctuation">)</span> <span class="token function">insert</span><span class="token punctuation">(</span>peer <span class="token builtin">string</span><span class="token punctuation">,</span> block <span class="token operator">*</span>types<span class="token punctuation">.</span>Block<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	hash <span class="token operator">:=</span> block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// Run the import on a new thread</span>
	log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Importing propagated block"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> f<span class="token punctuation">.</span>done <span class="token operator">&lt;-</span> hash <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

		<span class="token comment">// If the parent's unknown, abort insertion</span>
		parent <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">getBlock</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span><span class="token function">ParentHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> parent <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Unknown parent of propagated block"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">"parent"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">ParentHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Quickly validate the header and propagate the block if it passes</span>
		<span class="token comment">// 验证区块头，成功后广播区块</span>
		<span class="token keyword">switch</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">verifyHeader</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token punctuation">{</span>
		<span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span>
			<span class="token comment">// All ok, quickly propagate to our peers</span>
			propBroadcastOutTimer<span class="token punctuation">.</span><span class="token function">UpdateSince</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span>ReceivedAt<span class="token punctuation">)</span>
			<span class="token keyword">go</span> f<span class="token punctuation">.</span><span class="token function">broadcastBlock</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

		<span class="token keyword">case</span> consensus<span class="token punctuation">.</span>ErrFutureBlock<span class="token punctuation">:</span>
			<span class="token comment">// Weird future block, don't fail, but neither propagate</span>

		<span class="token keyword">default</span><span class="token punctuation">:</span>
			<span class="token comment">// Something went very wrong, drop the peer</span>
			log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Propagated block verification failed"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">"err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
			f<span class="token punctuation">.</span><span class="token function">dropPeer</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Run the actual import and log any issues</span>
		<span class="token comment">// 调用回调函数，实际是blockChain.insertChain</span>
		<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">insertChain</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span>Blocks<span class="token punctuation">{</span>block<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Propagated block import failed"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> block<span class="token punctuation">.</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">"err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// If import succeeded, broadcast the block</span>
		propAnnounceOutTimer<span class="token punctuation">.</span><span class="token function">UpdateSince</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span>ReceivedAt<span class="token punctuation">)</span>
		<span class="token keyword">go</span> f<span class="token punctuation">.</span><span class="token function">broadcastBlock</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>

		<span class="token comment">// Invoke the testing hook if needed</span>
		<span class="token keyword">if</span> f<span class="token punctuation">.</span>importedHook <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			f<span class="token punctuation">.</span><span class="token function">importedHook</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
  <h3><a id="NewBlockHashesMsg_393"></a>NewBlockHashesMsg的处理</h3> 
  <p>本节介绍NewBlockHashesMsg的处理，其实，消息处理是简单的，而复杂一点的是从Peer哪获取完整的区块，下节再看。</p> 
  <p>流程如下:</p> 
  <ol> 
   <li>对消息进行RLP解码，然后标记Peer已经知道此区块。</li> 
   <li>寻找出本地区块链不存在的区块Hash值，把这些未知的Hash通知给fetcher。</li> 
   <li><code>fetcher.Notify</code>记录好通知信息，塞入<code>notify</code>通道，以便交给fetcher的协程。</li> 
   <li><code>fetcher.loop()</code>会对<code>notify</code>中的消息进行处理，确认区块并非DOS攻击，然后检查区块的高度，判断该区块是否已经在<code>fetching</code>或者<code>comleting(代表已经下载区块头，在下载body)</code>，如果都没有，则加入到<code>announced</code>中，触发0s定时器，进行处理。</li> 
  </ol> 
  <p>关于<code>announced</code>下节再介绍。</p> 
  <pre><code class="prism language-go"><span class="token comment">// handleMsg()部分</span>
<span class="token keyword">case</span> msg<span class="token punctuation">.</span>Code <span class="token operator">==</span> NewBlockHashesMsg<span class="token punctuation">:</span>
	<span class="token keyword">var</span> announces newBlockHashesData
	<span class="token keyword">if</span> err <span class="token operator">:=</span> msg<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>announces<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">errResp</span><span class="token punctuation">(</span>ErrDecode<span class="token punctuation">,</span> <span class="token string">"%v: %v"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Mark the hashes as present at the remote node</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> block <span class="token operator">:=</span> <span class="token keyword">range</span> announces <span class="token punctuation">{</span>
		p<span class="token punctuation">.</span><span class="token function">MarkBlock</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Schedule all the unknown hashes for retrieval</span>
	<span class="token comment">// 把本地链没有的块hash找出来，交给fetcher去下载</span>
	unknown <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span>newBlockHashesData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>announces<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> block <span class="token operator">:=</span> <span class="token keyword">range</span> announces <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token operator">!</span>pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">HasBlock</span><span class="token punctuation">(</span>block<span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> block<span class="token punctuation">.</span>Number<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			unknown <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>unknown<span class="token punctuation">,</span> block<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> block <span class="token operator">:=</span> <span class="token keyword">range</span> unknown <span class="token punctuation">{</span>
		pm<span class="token punctuation">.</span>fetcher<span class="token punctuation">.</span><span class="token function">Notify</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> block<span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> block<span class="token punctuation">.</span>Number<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>RequestOneHeader<span class="token punctuation">,</span> p<span class="token punctuation">.</span>RequestBodies<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
</code></pre> 
  <pre><code class="prism language-go"><span class="token comment">// Notify announces the fetcher of the potential availability of a new block in</span>
<span class="token comment">// the network.</span>
<span class="token comment">// 通知fetcher（自己）有新块产生，没有块实体，有hash、高度等信息</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Fetcher<span class="token punctuation">)</span> <span class="token function">Notify</span><span class="token punctuation">(</span>peer <span class="token builtin">string</span><span class="token punctuation">,</span> hash common<span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> number <span class="token builtin">uint64</span><span class="token punctuation">,</span> time time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span>
	headerFetcher headerRequesterFn<span class="token punctuation">,</span> bodyFetcher bodyRequesterFn<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	block <span class="token operator">:=</span> <span class="token operator">&amp;</span>announce<span class="token punctuation">{</span>
		hash<span class="token punctuation">:</span>        hash<span class="token punctuation">,</span>
		number<span class="token punctuation">:</span>      number<span class="token punctuation">,</span>
		time<span class="token punctuation">:</span>        time<span class="token punctuation">,</span>
		origin<span class="token punctuation">:</span>      peer<span class="token punctuation">,</span>
		fetchHeader<span class="token punctuation">:</span> headerFetcher<span class="token punctuation">,</span>
		fetchBodies<span class="token punctuation">:</span> bodyFetcher<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> f<span class="token punctuation">.</span>notify <span class="token operator">&lt;-</span> block<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span> errTerminated
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <pre><code class="prism language-go"><span class="token comment">// fetcher.loop()的notify通道消息处理</span>
<span class="token keyword">case</span> notification <span class="token operator">:=</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>notify<span class="token punctuation">:</span>
	<span class="token comment">// A block was announced, make sure the peer isn't DOSing us</span>
	propAnnounceInMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	count <span class="token operator">:=</span> f<span class="token punctuation">.</span>announces<span class="token punctuation">[</span>notification<span class="token punctuation">.</span>origin<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
	<span class="token keyword">if</span> count <span class="token operator">&gt;</span> hashLimit <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Peer exceeded outstanding announces"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> notification<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> <span class="token string">"limit"</span><span class="token punctuation">,</span> hashLimit<span class="token punctuation">)</span>
		propAnnounceDOSMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">break</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// If we have a valid block number, check that it's potentially useful</span>
	<span class="token comment">// 高度检查</span>
	<span class="token keyword">if</span> notification<span class="token punctuation">.</span>number <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> dist <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span>notification<span class="token punctuation">.</span>number<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">int64</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">chainHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> dist <span class="token operator">&lt;</span> <span class="token operator">-</span>maxUncleDist <span class="token operator">||</span> dist <span class="token operator">&gt;</span> maxQueueDist <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Peer discarded announcement"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> notification<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> notification<span class="token punctuation">.</span>number<span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> notification<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> <span class="token string">"distance"</span><span class="token punctuation">,</span> dist<span class="token punctuation">)</span>
			propAnnounceDropMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// All is well, schedule the announce if block's not yet downloading</span>
	<span class="token comment">// 检查是否已经在下载，已下载则忽略</span>
	<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> f<span class="token punctuation">.</span>fetching<span class="token punctuation">[</span>notification<span class="token punctuation">.</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
		<span class="token keyword">break</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> f<span class="token punctuation">.</span>completing<span class="token punctuation">[</span>notification<span class="token punctuation">.</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
		<span class="token keyword">break</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 更新peer已经通知给我们的区块数量</span>
	f<span class="token punctuation">.</span>announces<span class="token punctuation">[</span>notification<span class="token punctuation">.</span>origin<span class="token punctuation">]</span> <span class="token operator">=</span> count
	<span class="token comment">// 把通知信息加入到announced，供调度</span>
	f<span class="token punctuation">.</span>announced<span class="token punctuation">[</span>notification<span class="token punctuation">.</span>hash<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>announced<span class="token punctuation">[</span>notification<span class="token punctuation">.</span>hash<span class="token punctuation">]</span><span class="token punctuation">,</span> notification<span class="token punctuation">)</span>
	<span class="token keyword">if</span> f<span class="token punctuation">.</span>announceChangeHook <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>announced<span class="token punctuation">[</span>notification<span class="token punctuation">.</span>hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		f<span class="token punctuation">.</span><span class="token function">announceChangeHook</span><span class="token punctuation">(</span>notification<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>announced<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token comment">// 有通知放入到announced，则重设0s定时器，loop的另外一个分支会处理这些通知</span>
		f<span class="token punctuation">.</span><span class="token function">rescheduleFetch</span><span class="token punctuation">(</span>fetchTimer<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
</code></pre> 
  <h3><a id="fetcher_496"></a>fetcher获取完整区块</h3> 
  <p>本节介绍fetcher获取完整区块的过程，这也是fetcher最重要的功能，会涉及到fetcher至少80%的代码。单独拉放一大节吧。</p> 
  <h2><a id="Fetcher_500"></a>Fetcher的大头</h2> 
  <p>Fetcher最主要的功能就是获取完整的区块，然后在合适的实际交给InsertChain去验证和插入到本地区块链。我们还是从宏观入手，看Fetcher是如何工作的，一定要先掌握好宏观，因为代码层面上没有这么清晰。</p> 
  <h3><a id="_504"></a>宏观</h3> 
  <p>首先，看两个节点是如何交互，获取完整区块，使用时序图的方式看一下，见图6，流程很清晰不再文字介绍。</p> 
  <p><img src="http://cdn.lessisbetter.site/image-20180822103401508.png-own" alt="图6：节点获取完整区块的时序图"></p> 
  <p>再看下获取区块过程中，fetcher内部的状态转移，它使用状态来记录，要获取的区块在什么阶段，见图7。我稍微解释一下：</p> 
  <ol> 
   <li>收到<code>NewBlockHashesMsg</code>后，相关信息会记录到<code>announced</code>，进入<code>announced</code>状态，代表了本节点接收了消息。</li> 
   <li><code>announced</code>由fetcher协程处理，经过校验后，会向给他发送消息的Peer发送请求，请求该区块的区块头，然后进入<code>fetching</code>状态。</li> 
   <li>获取区块头后，如果区块头表示没有交易和uncle，则转移到<code>completing</code>状态，并且使用区块头合成完整的区块，加入到<code>queued</code>优先级队列。</li> 
   <li>获取区块头后，如果区块头表示该区块有交易和uncle，则转移到<code>fetched</code>状态，然后发送请求，请求交易和uncle，然后转移到<code>completing</code>状态。</li> 
   <li>收到交易和uncle后，使用头、交易、uncle这3个信息，生成完整的区块，加入到队列<code>queued</code>。</li> 
  </ol> 
  <p><img src="http://cdn.lessisbetter.site/image-20180822103701006.png-own" alt="图7：获取区块状态转移图"></p> 
  <h3><a id="_528"></a>微观</h3> 
  <p>接下来就是从代码角度看如何获取完整区块的流程了，有点多，看不懂的时候，再回顾下上面宏观的介绍图。</p> 
  <p>首先看Fetcher的定义，它存放了通信数据和状态管理，捡加注释的看，上文提到的状态，里面都有。</p> 
  <pre><code class="prism language-go"><span class="token comment">// Fetcher is responsible for accumulating block announcements from various peers</span>
<span class="token comment">// and scheduling them for retrieval.</span>
<span class="token comment">// 积累块通知，然后调度获取这些块</span>
<span class="token keyword">type</span> Fetcher <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token comment">// Various event channels</span>
    <span class="token comment">// 收到区块hash值的通道</span>
	notify <span class="token keyword">chan</span> <span class="token operator">*</span>announce
    <span class="token comment">// 收到完整区块的通道</span>
	inject <span class="token keyword">chan</span> <span class="token operator">*</span>inject

	blockFilter <span class="token keyword">chan</span> <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Block
	<span class="token comment">// 过滤header的通道的通道</span>
	headerFilter <span class="token keyword">chan</span> <span class="token keyword">chan</span> <span class="token operator">*</span>headerFilterTask
	<span class="token comment">// 过滤body的通道的通道</span>
	bodyFilter <span class="token keyword">chan</span> <span class="token keyword">chan</span> <span class="token operator">*</span>bodyFilterTask

	done <span class="token keyword">chan</span> common<span class="token punctuation">.</span>Hash
	quit <span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

	<span class="token comment">// Announce states</span>
	<span class="token comment">// Peer已经给了本节点多少区块头通知</span>
	announces <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// Per peer announce counts to prevent memory exhaustion</span>
	<span class="token comment">// 已经announced的区块列表</span>
	announced <span class="token keyword">map</span><span class="token punctuation">[</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>announce <span class="token comment">// Announced blocks, scheduled for fetching</span>
	<span class="token comment">// 正在fetching区块头的请求</span>
	fetching <span class="token keyword">map</span><span class="token punctuation">[</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">]</span><span class="token operator">*</span>announce <span class="token comment">// Announced blocks, currently fetching</span>
	<span class="token comment">// 已经fetch到区块头，还差body的请求，用来获取body</span>
	fetched <span class="token keyword">map</span><span class="token punctuation">[</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>announce <span class="token comment">// Blocks with headers fetched, scheduled for body retrieval</span>
	<span class="token comment">// 已经得到区块头的</span>
	completing <span class="token keyword">map</span><span class="token punctuation">[</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">]</span><span class="token operator">*</span>announce <span class="token comment">// Blocks with headers, currently body-completing</span>

	<span class="token comment">// Block cache</span>
	<span class="token comment">// queue，优先级队列，高度做优先级</span>
	<span class="token comment">// queues，统计peer通告了多少块</span>
	<span class="token comment">// queued，代表这个块如队列了，</span>
	queue  <span class="token operator">*</span>prque<span class="token punctuation">.</span>Prque            <span class="token comment">// Queue containing the import operations (block number sorted)</span>
	queues <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span>          <span class="token comment">// Per peer block counts to prevent memory exhaustion</span>
	queued <span class="token keyword">map</span><span class="token punctuation">[</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">]</span><span class="token operator">*</span>inject <span class="token comment">// Set of already queued blocks (to dedupe imports)</span>

	<span class="token comment">// Callbacks</span>
	getBlock       blockRetrievalFn   <span class="token comment">// Retrieves a block from the local chain</span>
	verifyHeader   headerVerifierFn   <span class="token comment">// Checks if a block's headers have a valid proof of work，验证区块头，包含了PoW验证</span>
	broadcastBlock blockBroadcasterFn <span class="token comment">// Broadcasts a block to connected peers，广播给peer</span>
	chainHeight    chainHeightFn      <span class="token comment">// Retrieves the current chain's height</span>
	insertChain    chainInsertFn      <span class="token comment">// Injects a batch of blocks into the chain，插入区块到链的函数</span>
	dropPeer       peerDropFn         <span class="token comment">// Drops a peer for misbehaving</span>

	<span class="token comment">// Testing hooks</span>
	announceChangeHook <span class="token keyword">func</span><span class="token punctuation">(</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token comment">// Method to call upon adding or deleting a hash from the announce list</span>
	queueChangeHook    <span class="token keyword">func</span><span class="token punctuation">(</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token comment">// Method to call upon adding or deleting a block from the import queue</span>
	fetchingHook       <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span>     <span class="token comment">// Method to call upon starting a block (eth/61) or header (eth/62) fetch</span>
	completingHook     <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span>     <span class="token comment">// Method to call upon starting a block body fetch (eth/62)</span>
	importedHook       <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Block<span class="token punctuation">)</span>      <span class="token comment">// Method to call upon successful block import (both eth/61 and eth/62)</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p><code>NewBlockHashesMsg</code>消息的处理<a href="#NewBlockHashesMsg%E7%9A%84%E5%A4%84%E7%90%86" rel="nofollow">前面的小节已经讲过了</a>，不记得可向前翻看。这里从<code>announced</code>的状态处理说起。<code>loop()</code>中，<code>fetchTimer</code>超时后，代表了收到了消息通知，需要处理，会从<code>announced</code>中选择出需要处理的通知，然后创建请求，请求区块头，由于可能有很多节点都通知了它某个区块的Hash，所以随机的从这些发送消息的Peer中选择一个Peer，发送请求的时候，为每个Peer都创建了单独的协程。</p> 
  <pre><code class="prism language-go"><span class="token keyword">case</span> <span class="token operator">&lt;-</span>fetchTimer<span class="token punctuation">.</span>C<span class="token punctuation">:</span>
	<span class="token comment">// At least one block's timer ran out, check for needing retrieval</span>
	<span class="token comment">// 有区块通知，去处理</span>
	request <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span>

	<span class="token keyword">for</span> hash<span class="token punctuation">,</span> announces <span class="token operator">:=</span> <span class="token keyword">range</span> f<span class="token punctuation">.</span>announced <span class="token punctuation">{</span>
		<span class="token keyword">if</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>announces<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>time<span class="token punctuation">)</span> <span class="token operator">&gt;</span> arriveTimeout<span class="token operator">-</span>gatherSlack <span class="token punctuation">{</span>
			<span class="token comment">// Pick a random peer to retrieve from, reset all others</span>
			<span class="token comment">// 可能有很多peer都发送了这个区块的hash值，随机选择一个peer</span>
			announce <span class="token operator">:=</span> announces<span class="token punctuation">[</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>announces<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
			f<span class="token punctuation">.</span><span class="token function">forgetHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>

			<span class="token comment">// If the block still didn't arrive, queue for fetching</span>
			<span class="token comment">// 本地还没有这个区块，创建获取区块的请求</span>
			<span class="token keyword">if</span> f<span class="token punctuation">.</span><span class="token function">getBlock</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				request<span class="token punctuation">[</span>announce<span class="token punctuation">.</span>origin<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>request<span class="token punctuation">[</span>announce<span class="token punctuation">.</span>origin<span class="token punctuation">]</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span>
				f<span class="token punctuation">.</span>fetching<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">=</span> announce
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Send out all block header requests</span>
	<span class="token comment">// 把所有的request发送出去</span>
	<span class="token comment">// 为每一个peer都创建一个协程，然后请求所有需要从该peer获取的请求</span>
	<span class="token keyword">for</span> peer<span class="token punctuation">,</span> hashes <span class="token operator">:=</span> <span class="token keyword">range</span> request <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Fetching scheduled headers"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> hashes<span class="token punctuation">)</span>

		<span class="token comment">// Create a closure of the fetch and schedule in on a new thread</span>
		fetchHeader<span class="token punctuation">,</span> hashes <span class="token operator">:=</span> f<span class="token punctuation">.</span>fetching<span class="token punctuation">[</span>hashes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fetchHeader<span class="token punctuation">,</span> hashes
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> f<span class="token punctuation">.</span>fetchingHook <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				f<span class="token punctuation">.</span><span class="token function">fetchingHook</span><span class="token punctuation">(</span>hashes<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> hash <span class="token operator">:=</span> <span class="token keyword">range</span> hashes <span class="token punctuation">{</span>
				headerFetchMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
				<span class="token function">fetchHeader</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token comment">// Suboptimal, but protocol doesn't allow batch header retrievals</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Schedule the next fetch if blocks are still pending</span>
	f<span class="token punctuation">.</span><span class="token function">rescheduleFetch</span><span class="token punctuation">(</span>fetchTimer<span class="token punctuation">)</span>
</code></pre> 
  <p>从<code>Notify</code>的调用中，可以看出，<code>fetcherHeader()</code>的实际函数是<code>RequestOneHeader()</code>，该函数使用的消息是<code>GetBlockHeadersMsg</code>，可以用来请求多个区块头，不过fetcher只请求一个。</p> 
  <pre><code class="prism language-go">pm<span class="token punctuation">.</span>fetcher<span class="token punctuation">.</span><span class="token function">Notify</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> block<span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> block<span class="token punctuation">.</span>Number<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>RequestOneHeader<span class="token punctuation">,</span> p<span class="token punctuation">.</span>RequestBodies<span class="token punctuation">)</span>

<span class="token comment">// RequestOneHeader is a wrapper around the header query functions to fetch a</span>
<span class="token comment">// single header. It is used solely by the fetcher.</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>peer<span class="token punctuation">)</span> <span class="token function">RequestOneHeader</span><span class="token punctuation">(</span>hash common<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	p<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Fetching single header"</span><span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span>
	<span class="token keyword">return</span> p2p<span class="token punctuation">.</span><span class="token function">Send</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>rw<span class="token punctuation">,</span> GetBlockHeadersMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>getBlockHeadersData<span class="token punctuation">{</span>Origin<span class="token punctuation">:</span> hashOrNumber<span class="token punctuation">{</span>Hash<span class="token punctuation">:</span> hash<span class="token punctuation">}</span><span class="token punctuation">,</span> Amount<span class="token punctuation">:</span> <span class="token function">uint64</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Skip<span class="token punctuation">:</span> <span class="token function">uint64</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Reverse<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p><code>GetBlockHeadersMsg</code>的处理如下：因为它是获取多个区块头的，所以处理起来比较“麻烦”，还好，fetcher只获取一个区块头，其处理在20行~33行，获取下一个区块头的处理逻辑，这里就不看了，最后调用<code>SendBlockHeaders()</code>将区块头发送给请求的节点，消息是<code>BlockHeadersMsg</code>。</p> 
  <pre><code class="prism language-go"><span class="token comment">// handleMsg()</span>
<span class="token comment">// Block header query, collect the requested headers and reply</span>
<span class="token keyword">case</span> msg<span class="token punctuation">.</span>Code <span class="token operator">==</span> GetBlockHeadersMsg<span class="token punctuation">:</span>
	<span class="token comment">// Decode the complex header query</span>
	<span class="token keyword">var</span> query getBlockHeadersData
	<span class="token keyword">if</span> err <span class="token operator">:=</span> msg<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">errResp</span><span class="token punctuation">(</span>ErrDecode<span class="token punctuation">,</span> <span class="token string">"%v: %v"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	hashMode <span class="token operator">:=</span> query<span class="token punctuation">.</span>Origin<span class="token punctuation">.</span>Hash <span class="token operator">!=</span> <span class="token punctuation">(</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

	<span class="token comment">// Gather headers until the fetch or network limits is reached</span>
	<span class="token comment">// 收集区块头，直到达到限制</span>
	<span class="token keyword">var</span> <span class="token punctuation">(</span>
		bytes   common<span class="token punctuation">.</span>StorageSize
		headers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header
		unknown <span class="token builtin">bool</span>
	<span class="token punctuation">)</span>
	<span class="token comment">// 自己已知区块 &amp;&amp; 少于查询的数量 &amp;&amp; 大小小于2MB &amp;&amp; 小于能下载的最大数量</span>
	<span class="token keyword">for</span> <span class="token operator">!</span>unknown <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">int</span><span class="token punctuation">(</span>query<span class="token punctuation">.</span>Amount<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> bytes <span class="token operator">&lt;</span> softResponseLimit <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span> <span class="token operator">&lt;</span> downloader<span class="token punctuation">.</span>MaxHeaderFetch <span class="token punctuation">{</span>
		<span class="token comment">// Retrieve the next header satisfying the query</span>
		<span class="token comment">// 获取区块头</span>
		<span class="token keyword">var</span> origin <span class="token operator">*</span>types<span class="token punctuation">.</span>Header
		<span class="token keyword">if</span> hashMode <span class="token punctuation">{</span>
            <span class="token comment">// fetcher 使用的模式</span>
			origin <span class="token operator">=</span> pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">GetHeaderByHash</span><span class="token punctuation">(</span>query<span class="token punctuation">.</span>Origin<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			origin <span class="token operator">=</span> pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">GetHeaderByNumber</span><span class="token punctuation">(</span>query<span class="token punctuation">.</span>Origin<span class="token punctuation">.</span>Number<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> origin <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>
		number <span class="token operator">:=</span> origin<span class="token punctuation">.</span>Number<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		headers <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>headers<span class="token punctuation">,</span> origin<span class="token punctuation">)</span>
		bytes <span class="token operator">+=</span> estHeaderRlpSize

		<span class="token comment">// Advance to the next header of the query</span>
		<span class="token comment">// 下一个区块头的获取，不同策略，方式不同</span>
		<span class="token keyword">switch</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> query<span class="token punctuation">.</span>Origin<span class="token punctuation">.</span>Hash <span class="token operator">!=</span> <span class="token punctuation">(</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> query<span class="token punctuation">.</span>Reverse<span class="token punctuation">:</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">SendBlockHeaders</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span>
</code></pre> 
  <p><code>BlockHeadersMsg</code>的处理很有意思，因为<code>GetBlockHeadersMsg</code>并不是fetcher独占的消息，downloader也可以调用，所以，响应消息的处理需要分辨出是fetcher请求的，还是downloader请求的。它的处理逻辑是：fetcher先过滤收到的区块头，如果fetcher不要的，那就是downloader的，在调用<code>fetcher.FilterHeaders</code>的时候，fetcher就将自己要的区块头拿走了。</p> 
  <pre><code class="prism language-go"><span class="token comment">// handleMsg()</span>
<span class="token keyword">case</span> msg<span class="token punctuation">.</span>Code <span class="token operator">==</span> BlockHeadersMsg<span class="token punctuation">:</span>
	<span class="token comment">// A batch of headers arrived to one of our previous requests</span>
	<span class="token keyword">var</span> headers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header
	<span class="token keyword">if</span> err <span class="token operator">:=</span> msg<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>headers<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">errResp</span><span class="token punctuation">(</span>ErrDecode<span class="token punctuation">,</span> <span class="token string">"msg %v: %v"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// If no headers were received, but we're expending a DAO fork check, maybe it's that</span>
	<span class="token comment">// 检查是不是当前DAO的硬分叉</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forkDrop <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token comment">// Possibly an empty reply to the fork header checks, sanity check TDs</span>
		verifyDAO <span class="token operator">:=</span> <span class="token boolean">true</span>

		<span class="token comment">// If we already have a DAO header, we can check the peer's TD against it. If</span>
		<span class="token comment">// the peer's ahead of this, it too must have a reply to the DAO check</span>
		<span class="token keyword">if</span> daoHeader <span class="token operator">:=</span> pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">GetHeaderByNumber</span><span class="token punctuation">(</span>pm<span class="token punctuation">.</span>chainconfig<span class="token punctuation">.</span>DAOForkBlock<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> daoHeader <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> td <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token function">Head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> td<span class="token punctuation">.</span><span class="token function">Cmp</span><span class="token punctuation">(</span>pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">GetTd</span><span class="token punctuation">(</span>daoHeader<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> daoHeader<span class="token punctuation">.</span>Number<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				verifyDAO <span class="token operator">=</span> <span class="token boolean">false</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// If we're seemingly on the same chain, disable the drop timer</span>
		<span class="token keyword">if</span> verifyDAO <span class="token punctuation">{</span>
			p<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Seems to be on the same side of the DAO fork"</span><span class="token punctuation">)</span>
			p<span class="token punctuation">.</span>forkDrop<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			p<span class="token punctuation">.</span>forkDrop <span class="token operator">=</span> <span class="token boolean">nil</span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Filter out any explicitly requested headers, deliver the rest to the downloader</span>
	<span class="token comment">// 过滤是不是fetcher请求的区块头，去掉fetcher请求的区块头再交给downloader</span>
	filter <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span>
	<span class="token keyword">if</span> filter <span class="token punctuation">{</span>
		<span class="token comment">// If it's a potential DAO fork check, validate against the rules</span>
		<span class="token comment">// 检查是否硬分叉</span>
		<span class="token keyword">if</span> p<span class="token punctuation">.</span>forkDrop <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> pm<span class="token punctuation">.</span>chainconfig<span class="token punctuation">.</span>DAOForkBlock<span class="token punctuation">.</span><span class="token function">Cmp</span><span class="token punctuation">(</span>headers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Number<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			<span class="token comment">// Disable the fork drop timer</span>
			p<span class="token punctuation">.</span>forkDrop<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			p<span class="token punctuation">.</span>forkDrop <span class="token operator">=</span> <span class="token boolean">nil</span>

			<span class="token comment">// Validate the header and either drop the peer or continue</span>
			<span class="token keyword">if</span> err <span class="token operator">:=</span> misc<span class="token punctuation">.</span><span class="token function">VerifyDAOHeaderExtraData</span><span class="token punctuation">(</span>pm<span class="token punctuation">.</span>chainconfig<span class="token punctuation">,</span> headers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				p<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Verified to be on the other side of the DAO fork, dropping"</span><span class="token punctuation">)</span>
				<span class="token keyword">return</span> err
			<span class="token punctuation">}</span>
			p<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Verified to be on the same side of the DAO fork"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token boolean">nil</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Irrelevant of the fork checks, send the header to the fetcher just in case</span>
		<span class="token comment">// 使用fetcher过滤区块头</span>
		headers <span class="token operator">=</span> pm<span class="token punctuation">.</span>fetcher<span class="token punctuation">.</span><span class="token function">FilterHeaders</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> headers<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 剩下的区块头交给downloader</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span>filter <span class="token punctuation">{</span>
		err <span class="token operator">:=</span> pm<span class="token punctuation">.</span>downloader<span class="token punctuation">.</span><span class="token function">DeliverHeaders</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> headers<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Failed to deliver headers"</span><span class="token punctuation">,</span> <span class="token string">"err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
  <p><code>FilterHeaders()</code>是一个很有大智慧的函数，看起来耐人寻味，但实在妙。它要把所有的区块头，都传递给fetcher协程，还要获取fetcher协程处理后的结果。<code>fetcher.headerFilter</code>是存放通道的通道，而<code>filter</code>是存放包含区块头过滤任务的通道。它先把<code>filter</code>传递给了<code>headerFilter</code>，这样<code>fetcher</code>协程就在另外一段等待了，而后将<code>headerFilterTask</code>传入<code>filter</code>，fetcher就能读到数据了，处理后，再将数据写回<code>filter</code>而刚好被<code>FilterHeaders</code>函数处理了，该函数实际运行在<code>handleMsg()</code>的协程中。</p> 
  <p>每个Peer都会分配一个ProtocolManager然后处理该Peer的消息，但<code>fetcher</code>只有一个事件处理协程，如果不创建一个<code>filter</code>，fetcher哪知道是谁发给它的区块头呢？过滤之后，该如何发回去呢？</p> 
  <pre><code class="prism language-go"><span class="token comment">// FilterHeaders extracts all the headers that were explicitly requested by the fetcher,</span>
<span class="token comment">// returning those that should be handled differently.</span>
<span class="token comment">// 寻找出fetcher请求的区块头</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Fetcher<span class="token punctuation">)</span> <span class="token function">FilterHeaders</span><span class="token punctuation">(</span>peer <span class="token builtin">string</span><span class="token punctuation">,</span> headers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> time time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header <span class="token punctuation">{</span>
	log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Filtering headers"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"headers"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// Send the filter channel to the fetcher</span>
	<span class="token comment">// 任务通道</span>
	filter <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>headerFilterTask<span class="token punctuation">)</span>

	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token comment">// 任务通道发送到这个通道</span>
	<span class="token keyword">case</span> f<span class="token punctuation">.</span>headerFilter <span class="token operator">&lt;-</span> filter<span class="token punctuation">:</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Request the filtering of the header list</span>
	<span class="token comment">// 创建过滤任务，发送到任务通道</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> filter <span class="token operator">&lt;-</span> <span class="token operator">&amp;</span>headerFilterTask<span class="token punctuation">{</span>peer<span class="token punctuation">:</span> peer<span class="token punctuation">,</span> headers<span class="token punctuation">:</span> headers<span class="token punctuation">,</span> time<span class="token punctuation">:</span> time<span class="token punctuation">}</span><span class="token punctuation">:</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Retrieve the headers remaining after filtering</span>
	<span class="token comment">// 从任务通道，获取过滤的结果并返回</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> task <span class="token operator">:=</span> <span class="token operator">&lt;-</span>filter<span class="token punctuation">:</span>
		<span class="token keyword">return</span> task<span class="token punctuation">.</span>headers
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>接下来要看<code>f.headerFilter</code>的处理，这段代码有90行，它做了一下几件事：</p> 
  <ol> 
   <li>从<code>f.headerFilter</code>取出<code>filter</code>，然后取出过滤任务<code>task</code>。</li> 
   <li>它把区块头分成3类：<code>unknown</code>这不是分是要返回给调用者的，即<code>handleMsg()</code>, <code>incomplete</code>存放还需要获取body的区块头，<code>complete</code>存放只包含区块头的区块。遍历所有的区块头，填到到对应的分类中，具体的判断可看18行的注释，记住宏观中将的状态转移图。</li> 
   <li>把<code>unknonw</code>中的区块返回给<code>handleMsg()</code>。</li> 
   <li>把 <code>incomplete</code>的区块头获取状态移动到<code>fetched</code>状态，然后触发定时器，以便去处理<code>complete</code>的区块。</li> 
   <li>把<code>compelete</code>的区块加入到<code>queued</code>。</li> 
  </ol> 
  <pre><code class="prism language-go"><span class="token comment">// fetcher.loop()</span>
<span class="token keyword">case</span> filter <span class="token operator">:=</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>headerFilter<span class="token punctuation">:</span>
	<span class="token comment">// Headers arrived from a remote peer. Extract those that were explicitly</span>
	<span class="token comment">// requested by the fetcher, and return everything else so it's delivered</span>
	<span class="token comment">// to other parts of the system.</span>
	<span class="token comment">// 收到从远端节点发送的区块头，过滤出fetcher请求的</span>
	<span class="token comment">// 从任务通道获取过滤任务</span>
	<span class="token keyword">var</span> task <span class="token operator">*</span>headerFilterTask
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> task <span class="token operator">=</span> <span class="token operator">&lt;-</span>filter<span class="token punctuation">:</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	headerFilterInMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// Split the batch of headers into unknown ones (to return to the caller),</span>
	<span class="token comment">// known incomplete ones (requiring body retrievals) and completed blocks.</span>
	<span class="token comment">// unknown的不是fetcher请求的，complete放没有交易和uncle的区块，有头就够了，incomplete放</span>
	<span class="token comment">// 还需要获取uncle和交易的区块</span>
	unknown<span class="token punctuation">,</span> incomplete<span class="token punctuation">,</span> complete <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>announce<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Block<span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token comment">// 遍历所有收到的header</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> header <span class="token operator">:=</span> <span class="token keyword">range</span> task<span class="token punctuation">.</span>headers <span class="token punctuation">{</span>
		hash <span class="token operator">:=</span> header<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

		<span class="token comment">// Filter fetcher-requested headers from other synchronisation algorithms</span>
		<span class="token comment">// 是正在获取的hash，并且对应请求的peer，并且未fetched，未completing，未queued</span>
		<span class="token keyword">if</span> announce <span class="token operator">:=</span> f<span class="token punctuation">.</span>fetching<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span> announce <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> announce<span class="token punctuation">.</span>origin <span class="token operator">==</span> task<span class="token punctuation">.</span>peer <span class="token operator">&amp;&amp;</span> f<span class="token punctuation">.</span>fetched<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> f<span class="token punctuation">.</span>completing<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> f<span class="token punctuation">.</span>queued<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token comment">// If the delivered header does not match the promised number, drop the announcer</span>
			<span class="token comment">// 高度校验，竟然不匹配，扰乱秩序，peer肯定是坏蛋。</span>
			<span class="token keyword">if</span> header<span class="token punctuation">.</span>Number<span class="token punctuation">.</span><span class="token function">Uint64</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> announce<span class="token punctuation">.</span>number <span class="token punctuation">{</span>
				log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Invalid block number fetched"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> announce<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> header<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"announced"</span><span class="token punctuation">,</span> announce<span class="token punctuation">.</span>number<span class="token punctuation">,</span> <span class="token string">"provided"</span><span class="token punctuation">,</span> header<span class="token punctuation">.</span>Number<span class="token punctuation">)</span>
				f<span class="token punctuation">.</span><span class="token function">dropPeer</span><span class="token punctuation">(</span>announce<span class="token punctuation">.</span>origin<span class="token punctuation">)</span>
				f<span class="token punctuation">.</span><span class="token function">forgetHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
				<span class="token keyword">continue</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// Only keep if not imported by other means</span>
			<span class="token comment">// 本地链没有当前区块</span>
			<span class="token keyword">if</span> f<span class="token punctuation">.</span><span class="token function">getBlock</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				announce<span class="token punctuation">.</span>header <span class="token operator">=</span> header
				announce<span class="token punctuation">.</span>time <span class="token operator">=</span> task<span class="token punctuation">.</span>time

				<span class="token comment">// If the block is empty (header only), short circuit into the final import queue</span>
				<span class="token comment">// 如果区块没有交易和uncle，加入到complete</span>
				<span class="token keyword">if</span> header<span class="token punctuation">.</span>TxHash <span class="token operator">==</span> types<span class="token punctuation">.</span><span class="token function">DeriveSha</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span>Transactions<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> header<span class="token punctuation">.</span>UncleHash <span class="token operator">==</span> types<span class="token punctuation">.</span><span class="token function">CalcUncleHash</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Block empty, skipping body retrieval"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> announce<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> header<span class="token punctuation">.</span>Number<span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> header<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

					block <span class="token operator">:=</span> types<span class="token punctuation">.</span><span class="token function">NewBlockWithHeader</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span>
					block<span class="token punctuation">.</span>ReceivedAt <span class="token operator">=</span> task<span class="token punctuation">.</span>time

					complete <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>complete<span class="token punctuation">,</span> block<span class="token punctuation">)</span>
					f<span class="token punctuation">.</span>completing<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">=</span> announce
					<span class="token keyword">continue</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// Otherwise add to the list of blocks needing completion</span>
				<span class="token comment">// 否则就是不完整的区块</span>
				incomplete <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>incomplete<span class="token punctuation">,</span> announce<span class="token punctuation">)</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
				log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Block already imported, discarding header"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> announce<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">,</span> header<span class="token punctuation">.</span>Number<span class="token punctuation">,</span> <span class="token string">"hash"</span><span class="token punctuation">,</span> header<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				f<span class="token punctuation">.</span><span class="token function">forgetHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// Fetcher doesn't know about it, add to the return list</span>
			<span class="token comment">// 没请求过的header</span>
			unknown <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>unknown<span class="token punctuation">,</span> header<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 把未知的区块头，再传递会filter</span>
	headerFilterOutMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>unknown<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> filter <span class="token operator">&lt;-</span> <span class="token operator">&amp;</span>headerFilterTask<span class="token punctuation">{</span>headers<span class="token punctuation">:</span> unknown<span class="token punctuation">,</span> time<span class="token punctuation">:</span> task<span class="token punctuation">.</span>time<span class="token punctuation">}</span><span class="token punctuation">:</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Schedule the retrieved headers for body completion</span>
	<span class="token comment">// 把未完整的区块加入到fetched，跳过已经在completeing中的，然后触发completeTimer定时器</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> announce <span class="token operator">:=</span> <span class="token keyword">range</span> incomplete <span class="token punctuation">{</span>
		hash <span class="token operator">:=</span> announce<span class="token punctuation">.</span>header<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> f<span class="token punctuation">.</span>completing<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>
		f<span class="token punctuation">.</span>fetched<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>fetched<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">,</span> announce<span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>fetched<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
			f<span class="token punctuation">.</span><span class="token function">rescheduleComplete</span><span class="token punctuation">(</span>completeTimer<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Schedule the header-only blocks for import</span>
	<span class="token comment">// 把只有头的区块入队列</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> block <span class="token operator">:=</span> <span class="token keyword">range</span> complete <span class="token punctuation">{</span>
		<span class="token keyword">if</span> announce <span class="token operator">:=</span> f<span class="token punctuation">.</span>completing<span class="token punctuation">[</span>block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> announce <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			f<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>announce<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> block<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
  <p>跟随状态图的转义，剩下的工作是<code>fetched</code>转移到<code>completing</code>，上面的流程已经触发了<code>completeTimer</code>定时器，超时后就会处理，流程与请求Header类似，不再赘述，此时发送的请求消息是<code>GetBlockBodiesMsg</code>，实际调的函数是<code>RequestBodies</code>。</p> 
  <pre><code class="prism language-go"><span class="token comment">// fetcher.loop()</span>
<span class="token keyword">case</span> <span class="token operator">&lt;-</span>completeTimer<span class="token punctuation">.</span>C<span class="token punctuation">:</span>
	<span class="token comment">// At least one header's timer ran out, retrieve everything</span>
	<span class="token comment">// 至少有1个header已经获取完了</span>
	request <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span>

	<span class="token comment">// 遍历所有待获取body的announce</span>
	<span class="token keyword">for</span> hash<span class="token punctuation">,</span> announces <span class="token operator">:=</span> <span class="token keyword">range</span> f<span class="token punctuation">.</span>fetched <span class="token punctuation">{</span>
		<span class="token comment">// Pick a random peer to retrieve from, reset all others</span>
		<span class="token comment">// 随机选一个Peer发送请求，因为可能已经有很多Peer通知它这个区块了</span>
		announce <span class="token operator">:=</span> announces<span class="token punctuation">[</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>announces<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
		f<span class="token punctuation">.</span><span class="token function">forgetHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>

		<span class="token comment">// If the block still didn't arrive, queue for completion</span>
		<span class="token comment">// 如果本地没有这个区块，则放入到completing，创建请求</span>
		<span class="token keyword">if</span> f<span class="token punctuation">.</span><span class="token function">getBlock</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			request<span class="token punctuation">[</span>announce<span class="token punctuation">.</span>origin<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>request<span class="token punctuation">[</span>announce<span class="token punctuation">.</span>origin<span class="token punctuation">]</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span>
			f<span class="token punctuation">.</span>completing<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">=</span> announce
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Send out all block body requests</span>
	<span class="token comment">// 发送所有的请求，获取body，依然是每个peer一个单独协程</span>
	<span class="token keyword">for</span> peer<span class="token punctuation">,</span> hashes <span class="token operator">:=</span> <span class="token keyword">range</span> request <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Fetching scheduled bodies"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"list"</span><span class="token punctuation">,</span> hashes<span class="token punctuation">)</span>

		<span class="token comment">// Create a closure of the fetch and schedule in on a new thread</span>
		<span class="token keyword">if</span> f<span class="token punctuation">.</span>completingHook <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			f<span class="token punctuation">.</span><span class="token function">completingHook</span><span class="token punctuation">(</span>hashes<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		bodyFetchMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>hashes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">go</span> f<span class="token punctuation">.</span>completing<span class="token punctuation">[</span>hashes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">fetchBodies</span><span class="token punctuation">(</span>hashes<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Schedule the next fetch if blocks are still pending</span>
	f<span class="token punctuation">.</span><span class="token function">rescheduleComplete</span><span class="token punctuation">(</span>completeTimer<span class="token punctuation">)</span>
</code></pre> 
  <p><code>handleMsg()</code>处理该消息也是干净利落，直接获取RLP格式的body，然后发送响应消息。</p> 
  <pre><code class="prism language-go"><span class="token comment">// handleMsg()</span>
<span class="token keyword">case</span> msg<span class="token punctuation">.</span>Code <span class="token operator">==</span> GetBlockBodiesMsg<span class="token punctuation">:</span>
	<span class="token comment">// Decode the retrieval message</span>
	msgStream <span class="token operator">:=</span> rlp<span class="token punctuation">.</span><span class="token function">NewStream</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Payload<span class="token punctuation">,</span> <span class="token function">uint64</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>Size<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> msgStream<span class="token punctuation">.</span><span class="token function">List</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	<span class="token comment">// Gather blocks until the fetch or network limits is reached</span>
	<span class="token keyword">var</span> <span class="token punctuation">(</span>
		hash   common<span class="token punctuation">.</span>Hash
		bytes  <span class="token builtin">int</span>
		bodies <span class="token punctuation">[</span><span class="token punctuation">]</span>rlp<span class="token punctuation">.</span>RawValue
	<span class="token punctuation">)</span>

	<span class="token comment">// 遍历所有请求</span>
	<span class="token keyword">for</span> bytes <span class="token operator">&lt;</span> softResponseLimit <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>bodies<span class="token punctuation">)</span> <span class="token operator">&lt;</span> downloader<span class="token punctuation">.</span>MaxBlockFetch <span class="token punctuation">{</span>
		<span class="token comment">// Retrieve the hash of the next block</span>
		<span class="token keyword">if</span> err <span class="token operator">:=</span> msgStream<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> rlp<span class="token punctuation">.</span>EOL <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token function">errResp</span><span class="token punctuation">(</span>ErrDecode<span class="token punctuation">,</span> <span class="token string">"msg %v: %v"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// Retrieve the requested block body, stopping if enough was found</span>
		<span class="token comment">// 获取body，RLP格式</span>
		<span class="token keyword">if</span> data <span class="token operator">:=</span> pm<span class="token punctuation">.</span>blockchain<span class="token punctuation">.</span><span class="token function">GetBodyRLP</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
			bodies <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>bodies<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
			bytes <span class="token operator">+=</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">SendBlockBodiesRLP</span><span class="token punctuation">(</span>bodies<span class="token punctuation">)</span>
</code></pre> 
  <p>响应消息<code>BlockBodiesMsg</code>的处理与处理获取header的处理原理相同，先交给fetcher过滤，然后剩下的才是downloader的。需要注意一点，响应消息里只包含交易列表和叔块列表。</p> 
  <pre><code class="prism language-go"><span class="token comment">// handleMsg()</span>
<span class="token keyword">case</span> msg<span class="token punctuation">.</span>Code <span class="token operator">==</span> BlockBodiesMsg<span class="token punctuation">:</span>
	<span class="token comment">// A batch of block bodies arrived to one of our previous requests</span>
	<span class="token keyword">var</span> request blockBodiesData
	<span class="token keyword">if</span> err <span class="token operator">:=</span> msg<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">errResp</span><span class="token punctuation">(</span>ErrDecode<span class="token punctuation">,</span> <span class="token string">"msg %v: %v"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Deliver them all to the downloader for queuing</span>
	<span class="token comment">// 传递给downloader去处理</span>
	transactions <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Transaction<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span>
	uncles <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> i<span class="token punctuation">,</span> body <span class="token operator">:=</span> <span class="token keyword">range</span> request <span class="token punctuation">{</span>
		transactions<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> body<span class="token punctuation">.</span>Transactions
		uncles<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> body<span class="token punctuation">.</span>Uncles
	<span class="token punctuation">}</span>
	<span class="token comment">// Filter out any explicitly requested bodies, deliver the rest to the downloader</span>
	<span class="token comment">// 先让fetcher过滤去fetcher请求的body，剩下的给downloader</span>
	filter <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>transactions<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">len</span><span class="token punctuation">(</span>uncles<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span>
	<span class="token keyword">if</span> filter <span class="token punctuation">{</span>
		transactions<span class="token punctuation">,</span> uncles <span class="token operator">=</span> pm<span class="token punctuation">.</span>fetcher<span class="token punctuation">.</span><span class="token function">FilterBodies</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> transactions<span class="token punctuation">,</span> uncles<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 剩下的body交给downloader</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>transactions<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">len</span><span class="token punctuation">(</span>uncles<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span>filter <span class="token punctuation">{</span>
		err <span class="token operator">:=</span> pm<span class="token punctuation">.</span>downloader<span class="token punctuation">.</span><span class="token function">DeliverBodies</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>id<span class="token punctuation">,</span> transactions<span class="token punctuation">,</span> uncles<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"Failed to deliver bodies"</span><span class="token punctuation">,</span> <span class="token string">"err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
  <p>过滤函数的原理也与Header相同。</p> 
  <pre><code class="prism language-go"><span class="token comment">// FilterBodies extracts all the block bodies that were explicitly requested by</span>
<span class="token comment">// the fetcher, returning those that should be handled differently.</span>
<span class="token comment">// 过去出fetcher请求的body，返回它没有处理的，过程类型header的处理</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Fetcher<span class="token punctuation">)</span> <span class="token function">FilterBodies</span><span class="token punctuation">(</span>peer <span class="token builtin">string</span><span class="token punctuation">,</span> transactions <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Transaction<span class="token punctuation">,</span> uncles <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header<span class="token punctuation">,</span> time time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Transaction<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Header<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	log<span class="token punctuation">.</span><span class="token function">Trace</span><span class="token punctuation">(</span><span class="token string">"Filtering bodies"</span><span class="token punctuation">,</span> <span class="token string">"peer"</span><span class="token punctuation">,</span> peer<span class="token punctuation">,</span> <span class="token string">"txs"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>transactions<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"uncles"</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>uncles<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// Send the filter channel to the fetcher</span>
	filter <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token operator">*</span>bodyFilterTask<span class="token punctuation">)</span>

	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> f<span class="token punctuation">.</span>bodyFilter <span class="token operator">&lt;-</span> filter<span class="token punctuation">:</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Request the filtering of the body list</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> filter <span class="token operator">&lt;-</span> <span class="token operator">&amp;</span>bodyFilterTask<span class="token punctuation">{</span>peer<span class="token punctuation">:</span> peer<span class="token punctuation">,</span> transactions<span class="token punctuation">:</span> transactions<span class="token punctuation">,</span> uncles<span class="token punctuation">:</span> uncles<span class="token punctuation">,</span> time<span class="token punctuation">:</span> time<span class="token punctuation">}</span><span class="token punctuation">:</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Retrieve the bodies remaining after filtering</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> task <span class="token operator">:=</span> <span class="token operator">&lt;-</span>filter<span class="token punctuation">:</span>
		<span class="token keyword">return</span> task<span class="token punctuation">.</span>transactions<span class="token punctuation">,</span> task<span class="token punctuation">.</span>uncles
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>实际过滤body的处理瞧一下，这和Header的处理是不同的。直接看不点：</p> 
  <ol> 
   <li>它要的区块，单独取出来存到<code>blocks</code>中，它不要的继续留在<code>task</code>中。</li> 
   <li>判断是不是fetcher请求的方法：如果交易列表和叔块列表计算出的hash值与区块头中的一样，并且消息来自请求的Peer，则就是fetcher请求的。</li> 
   <li>将<code>blocks</code>中的区块加入到<code>queued</code>，终结。</li> 
  </ol> 
  <pre><code class="prism language-go"><span class="token keyword">case</span> filter <span class="token operator">:=</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>bodyFilter<span class="token punctuation">:</span>
	<span class="token comment">// Block bodies arrived, extract any explicitly requested blocks, return the rest</span>
	<span class="token keyword">var</span> task <span class="token operator">*</span>bodyFilterTask
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> task <span class="token operator">=</span> <span class="token operator">&lt;-</span>filter<span class="token punctuation">:</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	bodyFilterInMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>transactions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	blocks <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>types<span class="token punctuation">.</span>Block<span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token comment">// 获取的每个body的txs列表和uncle列表</span>
	<span class="token comment">// 遍历每个区块的txs列表和uncle列表，计算hash后判断是否是当前fetcher请求的body</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>transactions<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>uncles<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token comment">// Match up a body to any possible completion request</span>
		matched <span class="token operator">:=</span> <span class="token boolean">false</span>

		<span class="token comment">// 遍历所有保存的请求，因为tx和uncle，不知道它是属于哪个区块的，只能去遍历所有的请求，通常量不大，所以遍历没有性能影响</span>
		<span class="token keyword">for</span> hash<span class="token punctuation">,</span> announce <span class="token operator">:=</span> <span class="token keyword">range</span> f<span class="token punctuation">.</span>completing <span class="token punctuation">{</span>
			<span class="token keyword">if</span> f<span class="token punctuation">.</span>queued<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				<span class="token comment">// 把传入的每个块的hash和unclehash和它请求出去的记录进行对比，匹配则说明是fetcher请求的区块body</span>
				txnHash <span class="token operator">:=</span> types<span class="token punctuation">.</span><span class="token function">DeriveSha</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span><span class="token function">Transactions</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>transactions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				uncleHash <span class="token operator">:=</span> types<span class="token punctuation">.</span><span class="token function">CalcUncleHash</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>uncles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>

				<span class="token keyword">if</span> txnHash <span class="token operator">==</span> announce<span class="token punctuation">.</span>header<span class="token punctuation">.</span>TxHash <span class="token operator">&amp;&amp;</span> uncleHash <span class="token operator">==</span> announce<span class="token punctuation">.</span>header<span class="token punctuation">.</span>UncleHash <span class="token operator">&amp;&amp;</span> announce<span class="token punctuation">.</span>origin <span class="token operator">==</span> task<span class="token punctuation">.</span>peer <span class="token punctuation">{</span>
					<span class="token comment">// Mark the body matched, reassemble if still unknown</span>
					matched <span class="token operator">=</span> <span class="token boolean">true</span>

					<span class="token comment">// 如果当前链还没有这个区块，则收集这个区块，合并成新区块</span>
					<span class="token keyword">if</span> f<span class="token punctuation">.</span><span class="token function">getBlock</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
						block <span class="token operator">:=</span> types<span class="token punctuation">.</span><span class="token function">NewBlockWithHeader</span><span class="token punctuation">(</span>announce<span class="token punctuation">.</span>header<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">WithBody</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>transactions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> task<span class="token punctuation">.</span>uncles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
						block<span class="token punctuation">.</span>ReceivedAt <span class="token operator">=</span> task<span class="token punctuation">.</span>time

						blocks <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>blocks<span class="token punctuation">,</span> block<span class="token punctuation">)</span>
					<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
						f<span class="token punctuation">.</span><span class="token function">forgetHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 从task中移除fetcher请求的数据</span>
		<span class="token keyword">if</span> matched <span class="token punctuation">{</span>
			task<span class="token punctuation">.</span>transactions <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>transactions<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> task<span class="token punctuation">.</span>transactions<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>
			task<span class="token punctuation">.</span>uncles <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>uncles<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> task<span class="token punctuation">.</span>uncles<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>
			i<span class="token operator">--</span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 将剩余的数据返回</span>
	bodyFilterOutMeter<span class="token punctuation">.</span><span class="token function">Mark</span><span class="token punctuation">(</span><span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>transactions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> filter <span class="token operator">&lt;-</span> task<span class="token punctuation">:</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>f<span class="token punctuation">.</span>quit<span class="token punctuation">:</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// Schedule the retrieved blocks for ordered import</span>
	<span class="token comment">// 把收集的区块加入到队列</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> block <span class="token operator">:=</span> <span class="token keyword">range</span> blocks <span class="token punctuation">{</span>
		<span class="token keyword">if</span> announce <span class="token operator">:=</span> f<span class="token punctuation">.</span>completing<span class="token punctuation">[</span>block<span class="token punctuation">.</span><span class="token function">Hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> announce <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			f<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>announce<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> block<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p>至此，fetcher获取完整区块的流程讲完了，fetcher模块中80%的代码也都贴出来了，还有2个值得看看的函数：</p> 
  <ol> 
   <li><code>forgetHash(hash common.Hash)</code>：用于清空指定hash指的记/状态录信息。</li> 
   <li><code>forgetBlock(hash common.Hash)</code>：用于从队列中移除一个区块。</li> 
  </ol> 
  <p>最后了，再回到开始看看fetcher模块和新区块的传播流程，有没有豁然开朗。</p> 
  <blockquote> 
   <ol> 
    <li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li> 
    <li>本文作者：<a href="http://lessisbetter.site/about/" rel="nofollow">大彬</a></li> 
    <li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/" rel="nofollow">http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/</a></li> 
   </ol> 
  </blockquote> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
