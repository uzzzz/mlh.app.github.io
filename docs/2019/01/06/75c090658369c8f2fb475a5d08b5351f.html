<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>bitcoinj开发详解 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="bitcoinj开发详解" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/shebao3333/article/details/85913764 当你希望使用java开发比特币应用，或者希望应用与比特币对接时，bitcoinj是最佳的选择，它是最早也是目前最成熟的比特币java开发包，bitcoinj包含了比特币规范的大部分实现，例如密钥、地址、脚本、SPV协议等。利用bitcoinj可以快速开发支持比特币的java应用，例如交易所、比特币钱包、android手机游戏等等。 bitcoinj的功能相当丰富，但文档并不易懂，学习bitcoinj的最佳途径是汇智网的在线互动教程 java比特币开发详解，本文内容即节选自该课程。 什么是比特币？ 当我们谈到比特币时，其实在不同的场景下有不同的指代。 比特币首先是一种数字加密货币，用户可以通过比特币网络进行 比特币转账或商品结算，就和传统的货币一样： 不过比特币是基于密码学技术的虚拟化货币，它没有实体，仅仅隐含在从发送方到接收方的交易中，接收方必须使用其持有的密钥来 消费收到的比特币。 对于科技从业者而言，比特币则更多了一层含义：比特币对应着 一种划时代的数字加密货币系统，其内容包含通信协议、激励机制、实现代码 与承载网络等： 事实上，比特币是数十年来密码学技术、分布式计算等领域的集大成者， 它不是第一个出现的数字货币，但无疑是最成功的，一个洞察了人性的虚拟产品。 区块链结构 比特币是一个专用数据库，它只保存一种类型的数据记录 —— 交易，例如 张三转给李四几个币，或者李四转给王五几个币： 一旦涉及到资金，大家都会变得慎重了。因此交易记录最好在技术上可以保证 是不能篡改的，这样出了问题可以翻翻老账，这就要求账本必须值得信赖。 比特币采用一种特殊的数据结构区块链/Blockchain来保障交易的不可篡改性， 每一个包含一批交易数据的区块，同时也包含了前一个区块的指纹： 在比特币中，一个区块的指纹是使用密码学中常见的哈希函数来实现的。 哈希函数可以将大块数据压缩成精简的表示，而且可以保证如果精简 的表示不同，那么其对应的原始数据也不同。 例如，在上图中如果12#区块被攻击者篡改，那么它的哈希结果将不同于在 13#区块中保存的其原始指纹，这使得识别篡改的区块这一任务很容易，或者 说篡改的难度很大 —— 攻击者必须同时修改12#之后的所有区块才能保证 指纹校验成功。 另一方面，如果攻击者直接篡改14#区块（我们假设这是最后一个块），那么 显然是可行的，因为它缺乏之后更多区块的保护。这引入了在比特币中常用 的一个概念：交易的确认数/Confirms。 交易一旦被确认打包到区块中，它的确认数就是1，之后每增长一个区块 则确认数加1。例如对于上图中的标注交易，当链增长到14#块时，该交易的 确认数就是3。 显然一个交易的确认数越多，意味着攻击者篡改交易的可能性越小。在比特币 中的应用当中，交易的接收者通常需要在六个确认之后，才可以将该笔 交易视为成功。 去中心化机制 与当前流通的任何法币都不同，比特币是去中心化的，没有一个中央机构 来管理比特币的发行与流通，因此比特币网络是一个典型的P2P网络，在每个 （全）节点上都有完整的区块链数据： 在这样的分布式计算环境下，如何保证新的交易在各个节点区块链中得以 一致的更新，就是经典的分布式一致性问题了 —— 每个节点都有可能提交 新的交易，而不同节点提交的交易也可能不相同，到底以哪个节点为准？ 解决这种问题的经典方法就是（动态）选举一个决策者，其他节点复制 决策者的行为即可避免节点之间的不一致了。比特币的解决思路也一样， 不过它采用了一种类似于抢答的机制来动态选择胜出的节点，由胜出的 节点负责出块并打包交易 —— 所有节点都同时求解同一个问题，最先得到结果 的节点获胜并获得出块权利，其他节点则转而求解下一次出块的问题： 比特币给出的问题不可以通过解析方法求解，节点必须在所有的可能 结果中暴力尝试求解，由于胜出的节点可以获得比特币奖励，使得 节点旳动机和行为颇为类似于淘金的西部牛仔，因此这一求解过程被 称为挖矿/Mining。 理论上每个节点都有获胜的概率，但显然，在同样的时间内，计算力强大的 节点会比其他节点尝试的机会更多，因此获胜的概率也越大 —— 在这种抢答机制下， 算力代替了智力，而这种依赖于暴力求解问题从而达成节点一致性的共识算法 被称为工作量证明/Proof Of Work。 课程内容 本课程适合于希望开发比特币应用的Java工程师，内容涵盖比特币的基本 概念、工作原理、应用开发接口、离线密钥管理、分层确定性钱包以及 裸交易等诸多关键知识点。 第一章 比特币概述 主要介绍比特币的基本概念和核心工作原理。 第二章 Hi，比特币 这一章主要介绍如何使用现有软件进行比特币的操作，例如创建地址、转账、 查询余额、浏览区块等，同时介绍比特币应用中的核心概念，如钱包、交易、UTXO等。 第三章 使用RPC访问比特币网络 这一章主要介绍如何在程序代码中利用节点软件的RPC API接口访问比特币 网络，进行转账、地址创建、查询余额等操作，同时给出了一种简单的 在网站中支持比特币支付的方案。 第四章 自己管理密钥与地址 这一章主要介绍如何离线管理密钥与地址，并详细讲解比特币中的脚本以及 其与地址、身份验证之间的关系。如果你希望在自己的应用中增加类似于 钱包的功能，这部分的内容将让你收益匪浅。 第五章 使用分层确定性钱包 这一章主要介绍被广泛使用的分层确定性钱包，并详细讲解如何在程序代码 中加以应用。如果你需要管理大量的密钥和地址，那么分层确定性钱包应该 很有帮助。 第六章 离线构造裸交易 这一章主要介绍裸交易的作用，以及如何在程序代码中创建裸交易。如果你 需要使用第三方节点来广播你的比特币交易，那么裸交易就是你的唯一选择。 第七章 使用SPV节点 这一章讲解bitcoinj的SPV节点实现机制与核心组件。SPV节点是一种轻量 的比特币节点实现，它无须下载完整的区块，因此非常适合实现手机上的 比特币钱包，或者应用于不希望使用全节点的其他场景。 课程代码示例：用bitcoinj生成比特币地址 在比特币网络中，地址的作用就是接收以太币，并以UTXO的形式呆在 交易里等待被消费掉。因此地址最初是与密钥相关的：因为密钥对应着 某个用户/身份。在比特币的演化过程中，陆续出现了若干种形式的地址， 但核心始终是一致的：标识目标用户/身份。 利用bitcoinj可以非常简单地离线生成比特币地址，例如，下面的代码生成P2PKH地址： NetworkParameters params = RegTestParams.get(); ECKey key = new ECKey(); Address addr = new Addr(params,key.getPubKeyHash()); System.out.format(&quot;p2pkh address =&gt; %s\n&quot;,addr.toString()); 由于密钥和P2PKH是一一对应的，因此，ECKey也提供了直接的方法返回P2PKH地址，例如： Address addr = key.toAddress(params); 从上面的示例代码可以看到，bitcoinj开发api的设计非常清晰，也容易理解，只需要一点引导，相信你可以很快掌握用bitcoinj开发java比特币应用的方法！" />
<meta property="og:description" content="版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/shebao3333/article/details/85913764 当你希望使用java开发比特币应用，或者希望应用与比特币对接时，bitcoinj是最佳的选择，它是最早也是目前最成熟的比特币java开发包，bitcoinj包含了比特币规范的大部分实现，例如密钥、地址、脚本、SPV协议等。利用bitcoinj可以快速开发支持比特币的java应用，例如交易所、比特币钱包、android手机游戏等等。 bitcoinj的功能相当丰富，但文档并不易懂，学习bitcoinj的最佳途径是汇智网的在线互动教程 java比特币开发详解，本文内容即节选自该课程。 什么是比特币？ 当我们谈到比特币时，其实在不同的场景下有不同的指代。 比特币首先是一种数字加密货币，用户可以通过比特币网络进行 比特币转账或商品结算，就和传统的货币一样： 不过比特币是基于密码学技术的虚拟化货币，它没有实体，仅仅隐含在从发送方到接收方的交易中，接收方必须使用其持有的密钥来 消费收到的比特币。 对于科技从业者而言，比特币则更多了一层含义：比特币对应着 一种划时代的数字加密货币系统，其内容包含通信协议、激励机制、实现代码 与承载网络等： 事实上，比特币是数十年来密码学技术、分布式计算等领域的集大成者， 它不是第一个出现的数字货币，但无疑是最成功的，一个洞察了人性的虚拟产品。 区块链结构 比特币是一个专用数据库，它只保存一种类型的数据记录 —— 交易，例如 张三转给李四几个币，或者李四转给王五几个币： 一旦涉及到资金，大家都会变得慎重了。因此交易记录最好在技术上可以保证 是不能篡改的，这样出了问题可以翻翻老账，这就要求账本必须值得信赖。 比特币采用一种特殊的数据结构区块链/Blockchain来保障交易的不可篡改性， 每一个包含一批交易数据的区块，同时也包含了前一个区块的指纹： 在比特币中，一个区块的指纹是使用密码学中常见的哈希函数来实现的。 哈希函数可以将大块数据压缩成精简的表示，而且可以保证如果精简 的表示不同，那么其对应的原始数据也不同。 例如，在上图中如果12#区块被攻击者篡改，那么它的哈希结果将不同于在 13#区块中保存的其原始指纹，这使得识别篡改的区块这一任务很容易，或者 说篡改的难度很大 —— 攻击者必须同时修改12#之后的所有区块才能保证 指纹校验成功。 另一方面，如果攻击者直接篡改14#区块（我们假设这是最后一个块），那么 显然是可行的，因为它缺乏之后更多区块的保护。这引入了在比特币中常用 的一个概念：交易的确认数/Confirms。 交易一旦被确认打包到区块中，它的确认数就是1，之后每增长一个区块 则确认数加1。例如对于上图中的标注交易，当链增长到14#块时，该交易的 确认数就是3。 显然一个交易的确认数越多，意味着攻击者篡改交易的可能性越小。在比特币 中的应用当中，交易的接收者通常需要在六个确认之后，才可以将该笔 交易视为成功。 去中心化机制 与当前流通的任何法币都不同，比特币是去中心化的，没有一个中央机构 来管理比特币的发行与流通，因此比特币网络是一个典型的P2P网络，在每个 （全）节点上都有完整的区块链数据： 在这样的分布式计算环境下，如何保证新的交易在各个节点区块链中得以 一致的更新，就是经典的分布式一致性问题了 —— 每个节点都有可能提交 新的交易，而不同节点提交的交易也可能不相同，到底以哪个节点为准？ 解决这种问题的经典方法就是（动态）选举一个决策者，其他节点复制 决策者的行为即可避免节点之间的不一致了。比特币的解决思路也一样， 不过它采用了一种类似于抢答的机制来动态选择胜出的节点，由胜出的 节点负责出块并打包交易 —— 所有节点都同时求解同一个问题，最先得到结果 的节点获胜并获得出块权利，其他节点则转而求解下一次出块的问题： 比特币给出的问题不可以通过解析方法求解，节点必须在所有的可能 结果中暴力尝试求解，由于胜出的节点可以获得比特币奖励，使得 节点旳动机和行为颇为类似于淘金的西部牛仔，因此这一求解过程被 称为挖矿/Mining。 理论上每个节点都有获胜的概率，但显然，在同样的时间内，计算力强大的 节点会比其他节点尝试的机会更多，因此获胜的概率也越大 —— 在这种抢答机制下， 算力代替了智力，而这种依赖于暴力求解问题从而达成节点一致性的共识算法 被称为工作量证明/Proof Of Work。 课程内容 本课程适合于希望开发比特币应用的Java工程师，内容涵盖比特币的基本 概念、工作原理、应用开发接口、离线密钥管理、分层确定性钱包以及 裸交易等诸多关键知识点。 第一章 比特币概述 主要介绍比特币的基本概念和核心工作原理。 第二章 Hi，比特币 这一章主要介绍如何使用现有软件进行比特币的操作，例如创建地址、转账、 查询余额、浏览区块等，同时介绍比特币应用中的核心概念，如钱包、交易、UTXO等。 第三章 使用RPC访问比特币网络 这一章主要介绍如何在程序代码中利用节点软件的RPC API接口访问比特币 网络，进行转账、地址创建、查询余额等操作，同时给出了一种简单的 在网站中支持比特币支付的方案。 第四章 自己管理密钥与地址 这一章主要介绍如何离线管理密钥与地址，并详细讲解比特币中的脚本以及 其与地址、身份验证之间的关系。如果你希望在自己的应用中增加类似于 钱包的功能，这部分的内容将让你收益匪浅。 第五章 使用分层确定性钱包 这一章主要介绍被广泛使用的分层确定性钱包，并详细讲解如何在程序代码 中加以应用。如果你需要管理大量的密钥和地址，那么分层确定性钱包应该 很有帮助。 第六章 离线构造裸交易 这一章主要介绍裸交易的作用，以及如何在程序代码中创建裸交易。如果你 需要使用第三方节点来广播你的比特币交易，那么裸交易就是你的唯一选择。 第七章 使用SPV节点 这一章讲解bitcoinj的SPV节点实现机制与核心组件。SPV节点是一种轻量 的比特币节点实现，它无须下载完整的区块，因此非常适合实现手机上的 比特币钱包，或者应用于不希望使用全节点的其他场景。 课程代码示例：用bitcoinj生成比特币地址 在比特币网络中，地址的作用就是接收以太币，并以UTXO的形式呆在 交易里等待被消费掉。因此地址最初是与密钥相关的：因为密钥对应着 某个用户/身份。在比特币的演化过程中，陆续出现了若干种形式的地址， 但核心始终是一致的：标识目标用户/身份。 利用bitcoinj可以非常简单地离线生成比特币地址，例如，下面的代码生成P2PKH地址： NetworkParameters params = RegTestParams.get(); ECKey key = new ECKey(); Address addr = new Addr(params,key.getPubKeyHash()); System.out.format(&quot;p2pkh address =&gt; %s\n&quot;,addr.toString()); 由于密钥和P2PKH是一一对应的，因此，ECKey也提供了直接的方法返回P2PKH地址，例如： Address addr = key.toAddress(params); 从上面的示例代码可以看到，bitcoinj开发api的设计非常清晰，也容易理解，只需要一点引导，相信你可以很快掌握用bitcoinj开发java比特币应用的方法！" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-06T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/shebao3333/article/details/85913764 当你希望使用java开发比特币应用，或者希望应用与比特币对接时，bitcoinj是最佳的选择，它是最早也是目前最成熟的比特币java开发包，bitcoinj包含了比特币规范的大部分实现，例如密钥、地址、脚本、SPV协议等。利用bitcoinj可以快速开发支持比特币的java应用，例如交易所、比特币钱包、android手机游戏等等。 bitcoinj的功能相当丰富，但文档并不易懂，学习bitcoinj的最佳途径是汇智网的在线互动教程 java比特币开发详解，本文内容即节选自该课程。 什么是比特币？ 当我们谈到比特币时，其实在不同的场景下有不同的指代。 比特币首先是一种数字加密货币，用户可以通过比特币网络进行 比特币转账或商品结算，就和传统的货币一样： 不过比特币是基于密码学技术的虚拟化货币，它没有实体，仅仅隐含在从发送方到接收方的交易中，接收方必须使用其持有的密钥来 消费收到的比特币。 对于科技从业者而言，比特币则更多了一层含义：比特币对应着 一种划时代的数字加密货币系统，其内容包含通信协议、激励机制、实现代码 与承载网络等： 事实上，比特币是数十年来密码学技术、分布式计算等领域的集大成者， 它不是第一个出现的数字货币，但无疑是最成功的，一个洞察了人性的虚拟产品。 区块链结构 比特币是一个专用数据库，它只保存一种类型的数据记录 —— 交易，例如 张三转给李四几个币，或者李四转给王五几个币： 一旦涉及到资金，大家都会变得慎重了。因此交易记录最好在技术上可以保证 是不能篡改的，这样出了问题可以翻翻老账，这就要求账本必须值得信赖。 比特币采用一种特殊的数据结构区块链/Blockchain来保障交易的不可篡改性， 每一个包含一批交易数据的区块，同时也包含了前一个区块的指纹： 在比特币中，一个区块的指纹是使用密码学中常见的哈希函数来实现的。 哈希函数可以将大块数据压缩成精简的表示，而且可以保证如果精简 的表示不同，那么其对应的原始数据也不同。 例如，在上图中如果12#区块被攻击者篡改，那么它的哈希结果将不同于在 13#区块中保存的其原始指纹，这使得识别篡改的区块这一任务很容易，或者 说篡改的难度很大 —— 攻击者必须同时修改12#之后的所有区块才能保证 指纹校验成功。 另一方面，如果攻击者直接篡改14#区块（我们假设这是最后一个块），那么 显然是可行的，因为它缺乏之后更多区块的保护。这引入了在比特币中常用 的一个概念：交易的确认数/Confirms。 交易一旦被确认打包到区块中，它的确认数就是1，之后每增长一个区块 则确认数加1。例如对于上图中的标注交易，当链增长到14#块时，该交易的 确认数就是3。 显然一个交易的确认数越多，意味着攻击者篡改交易的可能性越小。在比特币 中的应用当中，交易的接收者通常需要在六个确认之后，才可以将该笔 交易视为成功。 去中心化机制 与当前流通的任何法币都不同，比特币是去中心化的，没有一个中央机构 来管理比特币的发行与流通，因此比特币网络是一个典型的P2P网络，在每个 （全）节点上都有完整的区块链数据： 在这样的分布式计算环境下，如何保证新的交易在各个节点区块链中得以 一致的更新，就是经典的分布式一致性问题了 —— 每个节点都有可能提交 新的交易，而不同节点提交的交易也可能不相同，到底以哪个节点为准？ 解决这种问题的经典方法就是（动态）选举一个决策者，其他节点复制 决策者的行为即可避免节点之间的不一致了。比特币的解决思路也一样， 不过它采用了一种类似于抢答的机制来动态选择胜出的节点，由胜出的 节点负责出块并打包交易 —— 所有节点都同时求解同一个问题，最先得到结果 的节点获胜并获得出块权利，其他节点则转而求解下一次出块的问题： 比特币给出的问题不可以通过解析方法求解，节点必须在所有的可能 结果中暴力尝试求解，由于胜出的节点可以获得比特币奖励，使得 节点旳动机和行为颇为类似于淘金的西部牛仔，因此这一求解过程被 称为挖矿/Mining。 理论上每个节点都有获胜的概率，但显然，在同样的时间内，计算力强大的 节点会比其他节点尝试的机会更多，因此获胜的概率也越大 —— 在这种抢答机制下， 算力代替了智力，而这种依赖于暴力求解问题从而达成节点一致性的共识算法 被称为工作量证明/Proof Of Work。 课程内容 本课程适合于希望开发比特币应用的Java工程师，内容涵盖比特币的基本 概念、工作原理、应用开发接口、离线密钥管理、分层确定性钱包以及 裸交易等诸多关键知识点。 第一章 比特币概述 主要介绍比特币的基本概念和核心工作原理。 第二章 Hi，比特币 这一章主要介绍如何使用现有软件进行比特币的操作，例如创建地址、转账、 查询余额、浏览区块等，同时介绍比特币应用中的核心概念，如钱包、交易、UTXO等。 第三章 使用RPC访问比特币网络 这一章主要介绍如何在程序代码中利用节点软件的RPC API接口访问比特币 网络，进行转账、地址创建、查询余额等操作，同时给出了一种简单的 在网站中支持比特币支付的方案。 第四章 自己管理密钥与地址 这一章主要介绍如何离线管理密钥与地址，并详细讲解比特币中的脚本以及 其与地址、身份验证之间的关系。如果你希望在自己的应用中增加类似于 钱包的功能，这部分的内容将让你收益匪浅。 第五章 使用分层确定性钱包 这一章主要介绍被广泛使用的分层确定性钱包，并详细讲解如何在程序代码 中加以应用。如果你需要管理大量的密钥和地址，那么分层确定性钱包应该 很有帮助。 第六章 离线构造裸交易 这一章主要介绍裸交易的作用，以及如何在程序代码中创建裸交易。如果你 需要使用第三方节点来广播你的比特币交易，那么裸交易就是你的唯一选择。 第七章 使用SPV节点 这一章讲解bitcoinj的SPV节点实现机制与核心组件。SPV节点是一种轻量 的比特币节点实现，它无须下载完整的区块，因此非常适合实现手机上的 比特币钱包，或者应用于不希望使用全节点的其他场景。 课程代码示例：用bitcoinj生成比特币地址 在比特币网络中，地址的作用就是接收以太币，并以UTXO的形式呆在 交易里等待被消费掉。因此地址最初是与密钥相关的：因为密钥对应着 某个用户/身份。在比特币的演化过程中，陆续出现了若干种形式的地址， 但核心始终是一致的：标识目标用户/身份。 利用bitcoinj可以非常简单地离线生成比特币地址，例如，下面的代码生成P2PKH地址： NetworkParameters params = RegTestParams.get(); ECKey key = new ECKey(); Address addr = new Addr(params,key.getPubKeyHash()); System.out.format(&quot;p2pkh address =&gt; %s\\n&quot;,addr.toString()); 由于密钥和P2PKH是一一对应的，因此，ECKey也提供了直接的方法返回P2PKH地址，例如： Address addr = key.toAddress(params); 从上面的示例代码可以看到，bitcoinj开发api的设计非常清晰，也容易理解，只需要一点引导，相信你可以很快掌握用bitcoinj开发java比特币应用的方法！","@type":"BlogPosting","url":"/2019/01/06/75c090658369c8f2fb475a5d08b5351f.html","headline":"bitcoinj开发详解","dateModified":"2019-01-06T00:00:00+08:00","datePublished":"2019-01-06T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/01/06/75c090658369c8f2fb475a5d08b5351f.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>bitcoinj开发详解</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/shebao3333/article/details/85913764 
 </div> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>当你希望使用java开发比特币应用，或者希望应用与比特币对接时，bitcoinj是最佳的选择，它是最早也是目前最成熟的比特币java开发包，bitcoinj包含了比特币规范的大部分实现，例如密钥、地址、脚本、SPV协议等。利用bitcoinj可以快速开发支持比特币的java应用，例如交易所、比特币钱包、android手机游戏等等。</p> 
  <p>bitcoinj的功能相当丰富，但文档并不易懂，学习bitcoinj的最佳途径是汇智网的在线互动教程 <a href="http://xc.hubwiz.com/course/5bb35c90c02e6b6a59171df0?affid=csdn7878" rel="nofollow">java比特币开发详解</a>，本文内容即节选自该课程。</p> 
  <h2><a id="_4"></a>什么是比特币？</h2> 
  <p>当我们谈到比特币时，其实在不同的场景下有不同的指代。</p> 
  <p>比特币首先是一种数字加密货币，用户可以通过比特币网络进行 比特币转账或商品结算，就和传统的货币一样：<br> <img src="https://ask.qcloudimg.com/http-save/developer-news/k0tg1azl65.jpeg" alt="在这里插入图片描述"></p> 
  <p>不过比特币是基于密码学技术的虚拟化货币，它没有实体，仅仅隐含在从发送方到接收方的交易中，接收方必须使用其持有的密钥来 消费收到的比特币。</p> 
  <p>对于科技从业者而言，比特币则更多了一层含义：比特币对应着 一种划时代的数字加密货币系统，其内容包含通信协议、激励机制、实现代码 与承载网络等：<br> <img src="https://ask.qcloudimg.com/http-save/developer-news/63rz2hv4ib.jpeg" alt="在这里插入图片描述"></p> 
  <p>事实上，比特币是数十年来密码学技术、分布式计算等领域的集大成者， 它不是第一个出现的数字货币，但无疑是最成功的，一个洞察了人性的虚拟产品。</p> 
  <h2><a id="_18"></a>区块链结构</h2> 
  <p>比特币是一个专用数据库，它只保存一种类型的数据记录 —— 交易，例如 张三转给李四几个币，或者李四转给王五几个币：<br> <img src="https://ask.qcloudimg.com/http-save/developer-news/f0f9qqig68.jpeg" alt="在这里插入图片描述"></p> 
  <p>一旦涉及到资金，大家都会变得慎重了。因此交易记录最好在技术上可以保证 是不能篡改的，这样出了问题可以翻翻老账，这就要求账本必须值得信赖。</p> 
  <p>比特币采用一种特殊的数据结构区块链/Blockchain来保障交易的不可篡改性， 每一个包含一批交易数据的区块，同时也包含了前一个区块的指纹：<br> <img src="https://ask.qcloudimg.com/http-save/developer-news/ovo9adybq7.jpeg" alt="在这里插入图片描述"></p> 
  <p>在比特币中，一个区块的指纹是使用密码学中常见的哈希函数来实现的。 哈希函数可以将大块数据压缩成精简的表示，而且可以保证如果精简 的表示不同，那么其对应的原始数据也不同。</p> 
  <p>例如，在上图中如果12#区块被攻击者篡改，那么它的哈希结果将不同于在 13#区块中保存的其原始指纹，这使得识别篡改的区块这一任务很容易，或者 说篡改的难度很大 —— 攻击者必须同时修改12#之后的所有区块才能保证 指纹校验成功。</p> 
  <p>另一方面，如果攻击者直接篡改14#区块（我们假设这是最后一个块），那么 显然是可行的，因为它缺乏之后更多区块的保护。这引入了在比特币中常用 的一个概念：交易的确认数/Confirms。</p> 
  <p>交易一旦被确认打包到区块中，它的确认数就是1，之后每增长一个区块 则确认数加1。例如对于上图中的标注交易，当链增长到14#块时，该交易的 确认数就是3。</p> 
  <p>显然一个交易的确认数越多，意味着攻击者篡改交易的可能性越小。在比特币 中的应用当中，交易的接收者通常需要在六个确认之后，才可以将该笔 交易视为成功。</p> 
  <h2><a id="_38"></a>去中心化机制</h2> 
  <p>与当前流通的任何法币都不同，比特币是去中心化的，没有一个中央机构 来管理比特币的发行与流通，因此比特币网络是一个典型的P2P网络，在每个 （全）节点上都有完整的区块链数据：</p> 
  <p><img src="https://ask.qcloudimg.com/http-save/developer-news/zv800zv090.jpeg" alt="在这里插入图片描述"><br> 在这样的分布式计算环境下，如何保证新的交易在各个节点区块链中得以 一致的更新，就是经典的分布式一致性问题了 —— 每个节点都有可能提交 新的交易，而不同节点提交的交易也可能不相同，到底以哪个节点为准？</p> 
  <p>解决这种问题的经典方法就是（动态）选举一个决策者，其他节点复制 决策者的行为即可避免节点之间的不一致了。比特币的解决思路也一样， 不过它采用了一种类似于抢答的机制来动态选择胜出的节点，由胜出的 节点负责出块并打包交易 —— 所有节点都同时求解同一个问题，最先得到结果 的节点获胜并获得出块权利，其他节点则转而求解下一次出块的问题：</p> 
  <p><img src="https://ask.qcloudimg.com/http-save/developer-news/1lc24ddiw4.jpeg" alt="在这里插入图片描述"><br> 比特币给出的问题不可以通过解析方法求解，节点必须在所有的可能 结果中暴力尝试求解，由于胜出的节点可以获得比特币奖励，使得 节点旳动机和行为颇为类似于淘金的西部牛仔，因此这一求解过程被 称为挖矿/Mining。</p> 
  <p>理论上每个节点都有获胜的概率，但显然，在同样的时间内，计算力强大的 节点会比其他节点尝试的机会更多，因此获胜的概率也越大 —— 在这种抢答机制下， 算力代替了智力，而这种依赖于暴力求解问题从而达成节点一致性的共识算法 被称为工作量证明/Proof Of Work。</p> 
  <h2><a id="_52"></a>课程内容</h2> 
  <p>本课程适合于希望开发比特币应用的Java工程师，内容涵盖比特币的基本 概念、工作原理、应用开发接口、离线密钥管理、分层确定性钱包以及 裸交易等诸多关键知识点。</p> 
  <p>第一章 比特币概述</p> 
  <p>主要介绍比特币的基本概念和核心工作原理。</p> 
  <p>第二章 Hi，比特币</p> 
  <p>这一章主要介绍如何使用现有软件进行比特币的操作，例如创建地址、转账、 查询余额、浏览区块等，同时介绍比特币应用中的核心概念，如钱包、交易、UTXO等。</p> 
  <p>第三章 使用RPC访问比特币网络</p> 
  <p>这一章主要介绍如何在程序代码中利用节点软件的RPC API接口访问比特币 网络，进行转账、地址创建、查询余额等操作，同时给出了一种简单的 在网站中支持比特币支付的方案。</p> 
  <p>第四章 自己管理密钥与地址</p> 
  <p>这一章主要介绍如何离线管理密钥与地址，并详细讲解比特币中的脚本以及 其与地址、身份验证之间的关系。如果你希望在自己的应用中增加类似于 钱包的功能，这部分的内容将让你收益匪浅。</p> 
  <p>第五章 使用分层确定性钱包</p> 
  <p>这一章主要介绍被广泛使用的分层确定性钱包，并详细讲解如何在程序代码 中加以应用。如果你需要管理大量的密钥和地址，那么分层确定性钱包应该 很有帮助。</p> 
  <p>第六章 离线构造裸交易</p> 
  <p>这一章主要介绍裸交易的作用，以及如何在程序代码中创建裸交易。如果你 需要使用第三方节点来广播你的比特币交易，那么裸交易就是你的唯一选择。</p> 
  <p>第七章 使用SPV节点</p> 
  <p>这一章讲解bitcoinj的SPV节点实现机制与核心组件。SPV节点是一种轻量 的比特币节点实现，它无须下载完整的区块，因此非常适合实现手机上的 比特币钱包，或者应用于不希望使用全节点的其他场景。</p> 
  <h2><a id="bitcoinj_84"></a>课程代码示例：用bitcoinj生成比特币地址</h2> 
  <p>在比特币网络中，地址的作用就是接收以太币，并以UTXO的形式呆在 交易里等待被消费掉。因此地址最初是与密钥相关的：因为密钥对应着 某个用户/身份。在比特币的演化过程中，陆续出现了若干种形式的地址， 但核心始终是一致的：标识目标用户/身份。</p> 
  <p>利用bitcoinj可以非常简单地离线生成比特币地址，例如，下面的代码生成P2PKH地址：</p> 
  <pre><code>NetworkParameters params = RegTestParams.get();
ECKey key = new ECKey();
Address addr = new Addr(params,key.getPubKeyHash());
System.out.format("p2pkh address =&gt; %s\n",addr.toString());
</code></pre> 
  <p>由于密钥和P2PKH是一一对应的，因此，ECKey也提供了直接的方法返回P2PKH地址，例如：</p> 
  <pre><code>Address addr = key.toAddress(params);
</code></pre> 
  <p>从上面的示例代码可以看到，bitcoinj开发api的设计非常清晰，也容易理解，只需要一点引导，相信你可以很快掌握用bitcoinj开发java比特币应用的方法！</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
