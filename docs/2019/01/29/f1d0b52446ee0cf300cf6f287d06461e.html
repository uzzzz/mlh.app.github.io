<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>从 Spring Cloud 看一个微服务框架的「五脏六腑」 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="从 Spring Cloud 看一个微服务框架的「五脏六腑」" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Linux编程 点击右侧关注，免费入门到精通！ 作者丨java团长 Spring Cloud 是一个基于 Spring Boot 实现的微服务框架，它包含了实现微服务架构所需的各种组件。 注：Spring Boot 简单理解就是简化 Spring 项目的搭建、配置、组合的框架。因为与构建微服务本身没有直接关系，所以本文不对 Spring Boot 进行展开。另外本文有一些例子涉及到 Spring 和 Spring Boot，建议先了解一下 Spring 和 Spring Boot 再阅读本文。 本文的阅读对象主要是没有接触过服务架构，想对其有一个宏观的了解的同学。 本文将从 Spring Cloud 出发，分两小节讲述微服务框架的「五脏六腑」： 第一小节「服务架构」旨在说明的包括两点，一服务架构是什么及其必要性；二是服务架构的基本组成。为什么第一节写服务架构而不是微服务架构呢？原因主要是微服务架构本身与服务架构有着千丝万缕的关系，服务架构是微服务架构的根基。 第二小节「五脏六腑」则将结合 Spring Cloud 这个特例来介绍一个完整的微服务框架的组成。 服务架构 为了方便理解，我先讲一个小故事：（改编自一知乎答主） Martin（微服务提出者也叫 Martin）刚来到公司时是一个基层员工，它上面有经理、老板，那个时候所有人都听老板的指挥。 但是过了两年，公司的人越来越多，原来的模式下整个公司的运作效率太低，管理也很混乱。 于是已经踏上中层岗位的 Martin 建议老板进行部门划分（服务化），专门的部门只做专门的事情（单一职责）。例如研发部门只做研发，人事部门只做招聘。 老板听取了 Martin 的意见，对公司的组织架构进行了调整。 有一天，Martin 发现公司的部门越来越多，各个部门并不能完全知道对方所做的事情，这对跨部门协作（服务调用）带来了困难。 行政部门会（注册中心）来记录所有的部门，每当有新的部门行政都会记录下来（服务注册），然后公布出来让所有部门知道（服务发现）。 在新的组织架构下，公司的效率逐步提高。老板也给 Martin 发了大量奖金作为奖励，Martin 从此赢取白富美走向了人生巅峰。 这是一个公司组织架构演变的故事，主要讲的是随着公司规模的扩大，组织从集中化管理到分布化管理的过程。 映射到我们的信息系统里来也是一样的，随着我们的系统越来越复杂，变得难以管理，也有人想到去拆分然后治理。在解决复杂问题上，分治可以说是一个屡试不爽的办法。 服务化即是拆解的一种手段。而上面圆括号里面的内容其实就对应了一个服务化架构的最小组成元素，分别是服务、服务调用、注册中心、服务注册、服务发现。有了这些基本的组成要素，就可以实现一个最简单的服务架构。 面向服务的架构和微服务架构 面向服务的架构（SOA）和微服务架构是目前两种主流的服务化架构，都符合上面的例子，也有上面提到的所有组件。这两种服务架构有很多可以讲的，但是与本文的相关性不大，本文不做会过多展开，只简单介绍一下两者的区别。 准确地说微服务是去 ESB（企业服务总线）的 SOA。ESB 借鉴了计算机组成原理中的通信模型 —— 总线，所有需要和外部系统通信的系统，通过 ESB 进行标准化地转换从而消除协议、异构系统之间的差异，这样就可以利用现有的系统构建一个全新的松耦合的异构的分布式系统。微服务架构去掉 ESB，本质上是一种去中心化的思想。 五脏六腑 心脏 顺着上一节的思路，从最简单、最核心的问题出发，假设服务 A 要调用服务 B，会有什么问题？ 服务在哪？（服务治理问题） 怎么调用？（服务调用问题） 这两个是最核心的问题，也是任何微服务框架首要解决的两个问题。 为了解决第一个问题 Spring Cloud 提供了 Eureka、Zookeeper、Cloud Foundry、Consul 等服务治理框架的集成。它们的工作模式是将所有的微服务注册到一个 Server 上，然后通过心跳进行服务健康监测。这样服务 A 调用 B 时可以从注册中心拿到可用的服务 B 的地址、端口进行调用。 第二个服务调用有人可能认为就是一个简单的 HTTP 或者 RPC 调用，不是什么问题。但是在分布式的场景下，服务调用需要考虑的因素会更多。比如一个服务有多个实例，此时请求进来了交给谁处理，请求的负载怎么平衡到各个实例，都是比较棘手的问题。Spring Cloud 提供了两种服务调用的方式：一种是 Ribbon + restTemplate，另一种是 Feign。 其中 Ribbon 是基于 HTTP 和 TCP 客户端的负载均衡器，restTemplate 是 Spring 提供的 Restful 远程调用的模板，两者结合就可以达到远程调用的负载均衡。 而 Feign 是一个更加声明式的 HTTP 客户端，开发者可以像调用本地方法一样调用它，完全感觉不到是远程调用，结合 Ribbon 也可以做负载均衡。 既然两个问题都得到了解决，我们就用一个例子来进一步说明一下，例子包含了微服务中最基本的三个角色（注册中心、服务提供者、服务消费者)： 注册中心 注解 @EnableEurekaServer 表示该 Spring Boot 应用是一个注册中心。 @EnableEurekaServer@SpringBootApplicationpublic&nbsp;class&nbsp;EurekaserverApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(EurekaserverApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}} eureka.client.registerWithEureka: false 和fetchRegistry: false 来表明自己是一个 eureka server。 server:&nbsp;port:&nbsp;8080eureka:&nbsp;instance:&nbsp;&nbsp;&nbsp;hostname:&nbsp;localhost&nbsp;client:&nbsp;&nbsp;&nbsp;registerWithEureka:&nbsp;false&nbsp;&nbsp;&nbsp;fetchRegistry:&nbsp;false&nbsp;&nbsp;&nbsp;serviceUrl:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultZone:&nbsp;http://${eureka.instance.hostname}:${server.port}/eureka/ service-hello 服务 注解 @EnableEurekaClient 表示他是一个 Eureka 客户端，它会在注册中心注册自己。 注解 @RestController 表示这是一个控制器，@RequestMapping(&quot;/hello&quot;) 表示匹配到请求 &#39;/hello&#39; 时会调用该方法进行响应。 @SpringBootApplication@EnableEurekaClient@RestControllerpublic&nbsp;class&nbsp;ServiceHelloApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(ServiceHelloApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;@Value(&quot;${server.port}&quot;)&nbsp;&nbsp;&nbsp;String&nbsp;port;&nbsp;&nbsp;&nbsp;@RequestMapping(&quot;/hello&quot;)&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;home(@RequestParam&nbsp;String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;hello&nbsp;&quot;+name+&quot;,i&nbsp;am&nbsp;from&nbsp;port:&quot;&nbsp;+port;&nbsp;&nbsp;&nbsp;}} 注册中心的地址为 http://localhost:8080/eureka/，也就是上面我们定义的。服务名为 service-hello，将会被调用者使用。 eureka:&nbsp;client:&nbsp;&nbsp;&nbsp;serviceUrl:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultZone:&nbsp;http://localhost:8080/eureka/server:&nbsp;port:&nbsp;8081spring:&nbsp;application:&nbsp;&nbsp;&nbsp;name:&nbsp;service-hello 服务消费者 service-ribbon 假设 service-ribbon 端口为 8082，当我们访问 http://localhost:8080/hello 时，HelloControler 接收到请求，并调用 HelloService 中的 helloService 方法，HelloService 中通过定义的 restTemplate 去调用 http://service-hello/hello。此处要注意的是 @LoadBalanced 注解，它表示启用负载均衡。 @SpringBootApplication@EnableDiscoveryClientpublic&nbsp;class&nbsp;ServiceRibbonApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(ServiceRibbonApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;@Bean&nbsp;&nbsp;&nbsp;@LoadBalanced&nbsp;&nbsp;&nbsp;RestTemplate&nbsp;restTemplate()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;RestTemplate();&nbsp;&nbsp;&nbsp;}}@Servicepublic&nbsp;class&nbsp;HelloService&nbsp;{&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;RestTemplate&nbsp;restTemplate;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;helloService(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;restTemplate.getForObject(&quot;http://service-hello/hello?name=&quot;+name,String.class);&nbsp;&nbsp;&nbsp;}}@RestControllerpublic&nbsp;class&nbsp;HelloControler&nbsp;{&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;HelloService&nbsp;helloService;&nbsp;&nbsp;&nbsp;@RequestMapping(value&nbsp;=&nbsp;&quot;/hello&quot;)&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;hello(@RequestParam&nbsp;String&nbsp;name){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;helloService.helloService(name);&nbsp;&nbsp;&nbsp;}} 至此其实一个微服务应用的雏形已经搭建出来了，服务治理、服务调用可以说是「五脏六腑」中的「心脏」。 心脏的依托 接下来我们要进一步思考的是「五脏六腑」中其余的部分，因为少了它们人也是活不久的。下面通过一个问题或需求对应一个组件的方式进行介绍。 服务“雪崩”与断路器 由于网络等原因，服务并不能保证 100% 可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗殆尽，导致服务瘫痪。 由于服务与服务之间存在依赖，故障会在调用链路上传播，导致整个微服务系统崩溃，这就是服务故障的“雪崩”效应。 为了解决这个问题，Spring Cloud 提供了对 Hystrix 断路器的集成，当服务调用失败的频次达到一定阈值，断路器将被开启，降级的策略可以开发者制定，一般是返回一个固定值。这样就能够避免连锁故障。 此外 Spring Cloud 还提供 Hystrix Dashboard 和 Hystrix Turbine，帮助我们进行监控和聚合监控。 服务暴露与路由网关 微服务中的服务很多，直接暴露给用户一是不安全，二是对用户不友好。因此在微服务和面向服务的架构中，通常会有一个路由网关的角色，来负责路由转发和过滤。对应到 Spring Cloud 中有 Zuul 和 Gateway 两个组件可用。 路由网关接收了所有的用户请求，有着很高的负载，因此它通常是一个集群。用户的请求会先经过一层负载均衡被发到路由网关。 服务配置与配置中心 在微服务应用中，服务数量巨多，而每个服务不同环境都有着不同的配置，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。需要注意的是此处的配置与注册中心注册的配置信息是两个概念，此处的配置是服务本身的一些配置信息，如下图： Spring Cloud 提供了 Spring Cloud Config 组件，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程 Git 仓库中，帮助我们管理服务的配置信息。 信息同步与消息总线 前一个问题讲到了每个服务都有一些配置信息，那么配置信息更新了我们该怎么办，手动一个个去更新？当然不是，Spring Cloud 提供了 Spring Cloud Bus 组件，它通过轻量消息代理连接各个分布的节点。当配置信息更新的时候，我们只要更新一个节点的配置，这个更新就会被广播到这个分布式系统中。 问题定位与链路追踪 在微服务系统中，服务之间可以相互调用，因此我们一个请求可能会一条调用链，而整个系统会存在一张调用网，其中任意一个服务调用失败或网络超时都可能导致整个请求失败。因为调用关系的复杂，这给问题的定位造成了极大的困难，这也是必须提供服务链路追踪的原因。 Spring Cloud 为我们提供了 Spring Cloud Sleuth 组件，它能够跟进一个请求到底有哪些服务参与，参与的顺序是怎样的，从而达到每个请求的步骤清晰可见。借助服务链路追踪，我们可以快速定位问题。 至此，Spring Cloud 的所有基础组件都介绍完了。但是目前所有的组件介绍都是分散的，它们组合起来，完整的样子是什么样的？如下图： 偷懒偷了张图，图中漏掉了 Config Server 和链路追踪组件。但是结合上文的介绍，我们大致可以脑补出这两个东西在图中的位置。Config Server 是一个与所有服务相连的服务集群，链路追踪组件则集成在每个服务中。 小结 服务治理为心脏，路由网关、消息中心、断路器、链路追踪、配置中心等为依托，构造了整个微服务框架的「五脏六腑」。当然，一个微服务系统远比本文所写的复杂得多，尤其是在不同的业务场景之下，因此想要更深入地了解它就需要我们不断地去实践。而作为前端，我了解这些内容一是为了更好地了解整个请求的流程，二是为了后续在 SOA 中接入 Node 子服务积累相关知识。 最后分享一句有趣的调侃 Spring 的话：在 Spring 中没有什么是一个注解解决不了的，如果有，那么就用两个注解。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行" />
<meta property="og:description" content="Linux编程 点击右侧关注，免费入门到精通！ 作者丨java团长 Spring Cloud 是一个基于 Spring Boot 实现的微服务框架，它包含了实现微服务架构所需的各种组件。 注：Spring Boot 简单理解就是简化 Spring 项目的搭建、配置、组合的框架。因为与构建微服务本身没有直接关系，所以本文不对 Spring Boot 进行展开。另外本文有一些例子涉及到 Spring 和 Spring Boot，建议先了解一下 Spring 和 Spring Boot 再阅读本文。 本文的阅读对象主要是没有接触过服务架构，想对其有一个宏观的了解的同学。 本文将从 Spring Cloud 出发，分两小节讲述微服务框架的「五脏六腑」： 第一小节「服务架构」旨在说明的包括两点，一服务架构是什么及其必要性；二是服务架构的基本组成。为什么第一节写服务架构而不是微服务架构呢？原因主要是微服务架构本身与服务架构有着千丝万缕的关系，服务架构是微服务架构的根基。 第二小节「五脏六腑」则将结合 Spring Cloud 这个特例来介绍一个完整的微服务框架的组成。 服务架构 为了方便理解，我先讲一个小故事：（改编自一知乎答主） Martin（微服务提出者也叫 Martin）刚来到公司时是一个基层员工，它上面有经理、老板，那个时候所有人都听老板的指挥。 但是过了两年，公司的人越来越多，原来的模式下整个公司的运作效率太低，管理也很混乱。 于是已经踏上中层岗位的 Martin 建议老板进行部门划分（服务化），专门的部门只做专门的事情（单一职责）。例如研发部门只做研发，人事部门只做招聘。 老板听取了 Martin 的意见，对公司的组织架构进行了调整。 有一天，Martin 发现公司的部门越来越多，各个部门并不能完全知道对方所做的事情，这对跨部门协作（服务调用）带来了困难。 行政部门会（注册中心）来记录所有的部门，每当有新的部门行政都会记录下来（服务注册），然后公布出来让所有部门知道（服务发现）。 在新的组织架构下，公司的效率逐步提高。老板也给 Martin 发了大量奖金作为奖励，Martin 从此赢取白富美走向了人生巅峰。 这是一个公司组织架构演变的故事，主要讲的是随着公司规模的扩大，组织从集中化管理到分布化管理的过程。 映射到我们的信息系统里来也是一样的，随着我们的系统越来越复杂，变得难以管理，也有人想到去拆分然后治理。在解决复杂问题上，分治可以说是一个屡试不爽的办法。 服务化即是拆解的一种手段。而上面圆括号里面的内容其实就对应了一个服务化架构的最小组成元素，分别是服务、服务调用、注册中心、服务注册、服务发现。有了这些基本的组成要素，就可以实现一个最简单的服务架构。 面向服务的架构和微服务架构 面向服务的架构（SOA）和微服务架构是目前两种主流的服务化架构，都符合上面的例子，也有上面提到的所有组件。这两种服务架构有很多可以讲的，但是与本文的相关性不大，本文不做会过多展开，只简单介绍一下两者的区别。 准确地说微服务是去 ESB（企业服务总线）的 SOA。ESB 借鉴了计算机组成原理中的通信模型 —— 总线，所有需要和外部系统通信的系统，通过 ESB 进行标准化地转换从而消除协议、异构系统之间的差异，这样就可以利用现有的系统构建一个全新的松耦合的异构的分布式系统。微服务架构去掉 ESB，本质上是一种去中心化的思想。 五脏六腑 心脏 顺着上一节的思路，从最简单、最核心的问题出发，假设服务 A 要调用服务 B，会有什么问题？ 服务在哪？（服务治理问题） 怎么调用？（服务调用问题） 这两个是最核心的问题，也是任何微服务框架首要解决的两个问题。 为了解决第一个问题 Spring Cloud 提供了 Eureka、Zookeeper、Cloud Foundry、Consul 等服务治理框架的集成。它们的工作模式是将所有的微服务注册到一个 Server 上，然后通过心跳进行服务健康监测。这样服务 A 调用 B 时可以从注册中心拿到可用的服务 B 的地址、端口进行调用。 第二个服务调用有人可能认为就是一个简单的 HTTP 或者 RPC 调用，不是什么问题。但是在分布式的场景下，服务调用需要考虑的因素会更多。比如一个服务有多个实例，此时请求进来了交给谁处理，请求的负载怎么平衡到各个实例，都是比较棘手的问题。Spring Cloud 提供了两种服务调用的方式：一种是 Ribbon + restTemplate，另一种是 Feign。 其中 Ribbon 是基于 HTTP 和 TCP 客户端的负载均衡器，restTemplate 是 Spring 提供的 Restful 远程调用的模板，两者结合就可以达到远程调用的负载均衡。 而 Feign 是一个更加声明式的 HTTP 客户端，开发者可以像调用本地方法一样调用它，完全感觉不到是远程调用，结合 Ribbon 也可以做负载均衡。 既然两个问题都得到了解决，我们就用一个例子来进一步说明一下，例子包含了微服务中最基本的三个角色（注册中心、服务提供者、服务消费者)： 注册中心 注解 @EnableEurekaServer 表示该 Spring Boot 应用是一个注册中心。 @EnableEurekaServer@SpringBootApplicationpublic&nbsp;class&nbsp;EurekaserverApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(EurekaserverApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}} eureka.client.registerWithEureka: false 和fetchRegistry: false 来表明自己是一个 eureka server。 server:&nbsp;port:&nbsp;8080eureka:&nbsp;instance:&nbsp;&nbsp;&nbsp;hostname:&nbsp;localhost&nbsp;client:&nbsp;&nbsp;&nbsp;registerWithEureka:&nbsp;false&nbsp;&nbsp;&nbsp;fetchRegistry:&nbsp;false&nbsp;&nbsp;&nbsp;serviceUrl:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultZone:&nbsp;http://${eureka.instance.hostname}:${server.port}/eureka/ service-hello 服务 注解 @EnableEurekaClient 表示他是一个 Eureka 客户端，它会在注册中心注册自己。 注解 @RestController 表示这是一个控制器，@RequestMapping(&quot;/hello&quot;) 表示匹配到请求 &#39;/hello&#39; 时会调用该方法进行响应。 @SpringBootApplication@EnableEurekaClient@RestControllerpublic&nbsp;class&nbsp;ServiceHelloApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(ServiceHelloApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;@Value(&quot;${server.port}&quot;)&nbsp;&nbsp;&nbsp;String&nbsp;port;&nbsp;&nbsp;&nbsp;@RequestMapping(&quot;/hello&quot;)&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;home(@RequestParam&nbsp;String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;hello&nbsp;&quot;+name+&quot;,i&nbsp;am&nbsp;from&nbsp;port:&quot;&nbsp;+port;&nbsp;&nbsp;&nbsp;}} 注册中心的地址为 http://localhost:8080/eureka/，也就是上面我们定义的。服务名为 service-hello，将会被调用者使用。 eureka:&nbsp;client:&nbsp;&nbsp;&nbsp;serviceUrl:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultZone:&nbsp;http://localhost:8080/eureka/server:&nbsp;port:&nbsp;8081spring:&nbsp;application:&nbsp;&nbsp;&nbsp;name:&nbsp;service-hello 服务消费者 service-ribbon 假设 service-ribbon 端口为 8082，当我们访问 http://localhost:8080/hello 时，HelloControler 接收到请求，并调用 HelloService 中的 helloService 方法，HelloService 中通过定义的 restTemplate 去调用 http://service-hello/hello。此处要注意的是 @LoadBalanced 注解，它表示启用负载均衡。 @SpringBootApplication@EnableDiscoveryClientpublic&nbsp;class&nbsp;ServiceRibbonApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(ServiceRibbonApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;@Bean&nbsp;&nbsp;&nbsp;@LoadBalanced&nbsp;&nbsp;&nbsp;RestTemplate&nbsp;restTemplate()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;RestTemplate();&nbsp;&nbsp;&nbsp;}}@Servicepublic&nbsp;class&nbsp;HelloService&nbsp;{&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;RestTemplate&nbsp;restTemplate;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;helloService(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;restTemplate.getForObject(&quot;http://service-hello/hello?name=&quot;+name,String.class);&nbsp;&nbsp;&nbsp;}}@RestControllerpublic&nbsp;class&nbsp;HelloControler&nbsp;{&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;HelloService&nbsp;helloService;&nbsp;&nbsp;&nbsp;@RequestMapping(value&nbsp;=&nbsp;&quot;/hello&quot;)&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;hello(@RequestParam&nbsp;String&nbsp;name){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;helloService.helloService(name);&nbsp;&nbsp;&nbsp;}} 至此其实一个微服务应用的雏形已经搭建出来了，服务治理、服务调用可以说是「五脏六腑」中的「心脏」。 心脏的依托 接下来我们要进一步思考的是「五脏六腑」中其余的部分，因为少了它们人也是活不久的。下面通过一个问题或需求对应一个组件的方式进行介绍。 服务“雪崩”与断路器 由于网络等原因，服务并不能保证 100% 可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗殆尽，导致服务瘫痪。 由于服务与服务之间存在依赖，故障会在调用链路上传播，导致整个微服务系统崩溃，这就是服务故障的“雪崩”效应。 为了解决这个问题，Spring Cloud 提供了对 Hystrix 断路器的集成，当服务调用失败的频次达到一定阈值，断路器将被开启，降级的策略可以开发者制定，一般是返回一个固定值。这样就能够避免连锁故障。 此外 Spring Cloud 还提供 Hystrix Dashboard 和 Hystrix Turbine，帮助我们进行监控和聚合监控。 服务暴露与路由网关 微服务中的服务很多，直接暴露给用户一是不安全，二是对用户不友好。因此在微服务和面向服务的架构中，通常会有一个路由网关的角色，来负责路由转发和过滤。对应到 Spring Cloud 中有 Zuul 和 Gateway 两个组件可用。 路由网关接收了所有的用户请求，有着很高的负载，因此它通常是一个集群。用户的请求会先经过一层负载均衡被发到路由网关。 服务配置与配置中心 在微服务应用中，服务数量巨多，而每个服务不同环境都有着不同的配置，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。需要注意的是此处的配置与注册中心注册的配置信息是两个概念，此处的配置是服务本身的一些配置信息，如下图： Spring Cloud 提供了 Spring Cloud Config 组件，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程 Git 仓库中，帮助我们管理服务的配置信息。 信息同步与消息总线 前一个问题讲到了每个服务都有一些配置信息，那么配置信息更新了我们该怎么办，手动一个个去更新？当然不是，Spring Cloud 提供了 Spring Cloud Bus 组件，它通过轻量消息代理连接各个分布的节点。当配置信息更新的时候，我们只要更新一个节点的配置，这个更新就会被广播到这个分布式系统中。 问题定位与链路追踪 在微服务系统中，服务之间可以相互调用，因此我们一个请求可能会一条调用链，而整个系统会存在一张调用网，其中任意一个服务调用失败或网络超时都可能导致整个请求失败。因为调用关系的复杂，这给问题的定位造成了极大的困难，这也是必须提供服务链路追踪的原因。 Spring Cloud 为我们提供了 Spring Cloud Sleuth 组件，它能够跟进一个请求到底有哪些服务参与，参与的顺序是怎样的，从而达到每个请求的步骤清晰可见。借助服务链路追踪，我们可以快速定位问题。 至此，Spring Cloud 的所有基础组件都介绍完了。但是目前所有的组件介绍都是分散的，它们组合起来，完整的样子是什么样的？如下图： 偷懒偷了张图，图中漏掉了 Config Server 和链路追踪组件。但是结合上文的介绍，我们大致可以脑补出这两个东西在图中的位置。Config Server 是一个与所有服务相连的服务集群，链路追踪组件则集成在每个服务中。 小结 服务治理为心脏，路由网关、消息中心、断路器、链路追踪、配置中心等为依托，构造了整个微服务框架的「五脏六腑」。当然，一个微服务系统远比本文所写的复杂得多，尤其是在不同的业务场景之下，因此想要更深入地了解它就需要我们不断地去实践。而作为前端，我了解这些内容一是为了更好地了解整个请求的流程，二是为了后续在 SOA 中接入 Node 子服务积累相关知识。 最后分享一句有趣的调侃 Spring 的话：在 Spring 中没有什么是一个注解解决不了的，如果有，那么就用两个注解。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行" />
<link rel="canonical" href="https://mlh.app/2019/01/29/f1d0b52446ee0cf300cf6f287d06461e.html" />
<meta property="og:url" content="https://mlh.app/2019/01/29/f1d0b52446ee0cf300cf6f287d06461e.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-29T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"Linux编程 点击右侧关注，免费入门到精通！ 作者丨java团长 Spring Cloud 是一个基于 Spring Boot 实现的微服务框架，它包含了实现微服务架构所需的各种组件。 注：Spring Boot 简单理解就是简化 Spring 项目的搭建、配置、组合的框架。因为与构建微服务本身没有直接关系，所以本文不对 Spring Boot 进行展开。另外本文有一些例子涉及到 Spring 和 Spring Boot，建议先了解一下 Spring 和 Spring Boot 再阅读本文。 本文的阅读对象主要是没有接触过服务架构，想对其有一个宏观的了解的同学。 本文将从 Spring Cloud 出发，分两小节讲述微服务框架的「五脏六腑」： 第一小节「服务架构」旨在说明的包括两点，一服务架构是什么及其必要性；二是服务架构的基本组成。为什么第一节写服务架构而不是微服务架构呢？原因主要是微服务架构本身与服务架构有着千丝万缕的关系，服务架构是微服务架构的根基。 第二小节「五脏六腑」则将结合 Spring Cloud 这个特例来介绍一个完整的微服务框架的组成。 服务架构 为了方便理解，我先讲一个小故事：（改编自一知乎答主） Martin（微服务提出者也叫 Martin）刚来到公司时是一个基层员工，它上面有经理、老板，那个时候所有人都听老板的指挥。 但是过了两年，公司的人越来越多，原来的模式下整个公司的运作效率太低，管理也很混乱。 于是已经踏上中层岗位的 Martin 建议老板进行部门划分（服务化），专门的部门只做专门的事情（单一职责）。例如研发部门只做研发，人事部门只做招聘。 老板听取了 Martin 的意见，对公司的组织架构进行了调整。 有一天，Martin 发现公司的部门越来越多，各个部门并不能完全知道对方所做的事情，这对跨部门协作（服务调用）带来了困难。 行政部门会（注册中心）来记录所有的部门，每当有新的部门行政都会记录下来（服务注册），然后公布出来让所有部门知道（服务发现）。 在新的组织架构下，公司的效率逐步提高。老板也给 Martin 发了大量奖金作为奖励，Martin 从此赢取白富美走向了人生巅峰。 这是一个公司组织架构演变的故事，主要讲的是随着公司规模的扩大，组织从集中化管理到分布化管理的过程。 映射到我们的信息系统里来也是一样的，随着我们的系统越来越复杂，变得难以管理，也有人想到去拆分然后治理。在解决复杂问题上，分治可以说是一个屡试不爽的办法。 服务化即是拆解的一种手段。而上面圆括号里面的内容其实就对应了一个服务化架构的最小组成元素，分别是服务、服务调用、注册中心、服务注册、服务发现。有了这些基本的组成要素，就可以实现一个最简单的服务架构。 面向服务的架构和微服务架构 面向服务的架构（SOA）和微服务架构是目前两种主流的服务化架构，都符合上面的例子，也有上面提到的所有组件。这两种服务架构有很多可以讲的，但是与本文的相关性不大，本文不做会过多展开，只简单介绍一下两者的区别。 准确地说微服务是去 ESB（企业服务总线）的 SOA。ESB 借鉴了计算机组成原理中的通信模型 —— 总线，所有需要和外部系统通信的系统，通过 ESB 进行标准化地转换从而消除协议、异构系统之间的差异，这样就可以利用现有的系统构建一个全新的松耦合的异构的分布式系统。微服务架构去掉 ESB，本质上是一种去中心化的思想。 五脏六腑 心脏 顺着上一节的思路，从最简单、最核心的问题出发，假设服务 A 要调用服务 B，会有什么问题？ 服务在哪？（服务治理问题） 怎么调用？（服务调用问题） 这两个是最核心的问题，也是任何微服务框架首要解决的两个问题。 为了解决第一个问题 Spring Cloud 提供了 Eureka、Zookeeper、Cloud Foundry、Consul 等服务治理框架的集成。它们的工作模式是将所有的微服务注册到一个 Server 上，然后通过心跳进行服务健康监测。这样服务 A 调用 B 时可以从注册中心拿到可用的服务 B 的地址、端口进行调用。 第二个服务调用有人可能认为就是一个简单的 HTTP 或者 RPC 调用，不是什么问题。但是在分布式的场景下，服务调用需要考虑的因素会更多。比如一个服务有多个实例，此时请求进来了交给谁处理，请求的负载怎么平衡到各个实例，都是比较棘手的问题。Spring Cloud 提供了两种服务调用的方式：一种是 Ribbon + restTemplate，另一种是 Feign。 其中 Ribbon 是基于 HTTP 和 TCP 客户端的负载均衡器，restTemplate 是 Spring 提供的 Restful 远程调用的模板，两者结合就可以达到远程调用的负载均衡。 而 Feign 是一个更加声明式的 HTTP 客户端，开发者可以像调用本地方法一样调用它，完全感觉不到是远程调用，结合 Ribbon 也可以做负载均衡。 既然两个问题都得到了解决，我们就用一个例子来进一步说明一下，例子包含了微服务中最基本的三个角色（注册中心、服务提供者、服务消费者)： 注册中心 注解 @EnableEurekaServer 表示该 Spring Boot 应用是一个注册中心。 @EnableEurekaServer@SpringBootApplicationpublic&nbsp;class&nbsp;EurekaserverApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(EurekaserverApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}} eureka.client.registerWithEureka: false 和fetchRegistry: false 来表明自己是一个 eureka server。 server:&nbsp;port:&nbsp;8080eureka:&nbsp;instance:&nbsp;&nbsp;&nbsp;hostname:&nbsp;localhost&nbsp;client:&nbsp;&nbsp;&nbsp;registerWithEureka:&nbsp;false&nbsp;&nbsp;&nbsp;fetchRegistry:&nbsp;false&nbsp;&nbsp;&nbsp;serviceUrl:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultZone:&nbsp;http://${eureka.instance.hostname}:${server.port}/eureka/ service-hello 服务 注解 @EnableEurekaClient 表示他是一个 Eureka 客户端，它会在注册中心注册自己。 注解 @RestController 表示这是一个控制器，@RequestMapping(&quot;/hello&quot;) 表示匹配到请求 &#39;/hello&#39; 时会调用该方法进行响应。 @SpringBootApplication@EnableEurekaClient@RestControllerpublic&nbsp;class&nbsp;ServiceHelloApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(ServiceHelloApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;@Value(&quot;${server.port}&quot;)&nbsp;&nbsp;&nbsp;String&nbsp;port;&nbsp;&nbsp;&nbsp;@RequestMapping(&quot;/hello&quot;)&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;home(@RequestParam&nbsp;String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;hello&nbsp;&quot;+name+&quot;,i&nbsp;am&nbsp;from&nbsp;port:&quot;&nbsp;+port;&nbsp;&nbsp;&nbsp;}} 注册中心的地址为 http://localhost:8080/eureka/，也就是上面我们定义的。服务名为 service-hello，将会被调用者使用。 eureka:&nbsp;client:&nbsp;&nbsp;&nbsp;serviceUrl:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultZone:&nbsp;http://localhost:8080/eureka/server:&nbsp;port:&nbsp;8081spring:&nbsp;application:&nbsp;&nbsp;&nbsp;name:&nbsp;service-hello 服务消费者 service-ribbon 假设 service-ribbon 端口为 8082，当我们访问 http://localhost:8080/hello 时，HelloControler 接收到请求，并调用 HelloService 中的 helloService 方法，HelloService 中通过定义的 restTemplate 去调用 http://service-hello/hello。此处要注意的是 @LoadBalanced 注解，它表示启用负载均衡。 @SpringBootApplication@EnableDiscoveryClientpublic&nbsp;class&nbsp;ServiceRibbonApplication&nbsp;{&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(ServiceRibbonApplication.class,&nbsp;args);&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;@Bean&nbsp;&nbsp;&nbsp;@LoadBalanced&nbsp;&nbsp;&nbsp;RestTemplate&nbsp;restTemplate()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;RestTemplate();&nbsp;&nbsp;&nbsp;}}@Servicepublic&nbsp;class&nbsp;HelloService&nbsp;{&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;RestTemplate&nbsp;restTemplate;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;helloService(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;restTemplate.getForObject(&quot;http://service-hello/hello?name=&quot;+name,String.class);&nbsp;&nbsp;&nbsp;}}@RestControllerpublic&nbsp;class&nbsp;HelloControler&nbsp;{&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;HelloService&nbsp;helloService;&nbsp;&nbsp;&nbsp;@RequestMapping(value&nbsp;=&nbsp;&quot;/hello&quot;)&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;hello(@RequestParam&nbsp;String&nbsp;name){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;helloService.helloService(name);&nbsp;&nbsp;&nbsp;}} 至此其实一个微服务应用的雏形已经搭建出来了，服务治理、服务调用可以说是「五脏六腑」中的「心脏」。 心脏的依托 接下来我们要进一步思考的是「五脏六腑」中其余的部分，因为少了它们人也是活不久的。下面通过一个问题或需求对应一个组件的方式进行介绍。 服务“雪崩”与断路器 由于网络等原因，服务并不能保证 100% 可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗殆尽，导致服务瘫痪。 由于服务与服务之间存在依赖，故障会在调用链路上传播，导致整个微服务系统崩溃，这就是服务故障的“雪崩”效应。 为了解决这个问题，Spring Cloud 提供了对 Hystrix 断路器的集成，当服务调用失败的频次达到一定阈值，断路器将被开启，降级的策略可以开发者制定，一般是返回一个固定值。这样就能够避免连锁故障。 此外 Spring Cloud 还提供 Hystrix Dashboard 和 Hystrix Turbine，帮助我们进行监控和聚合监控。 服务暴露与路由网关 微服务中的服务很多，直接暴露给用户一是不安全，二是对用户不友好。因此在微服务和面向服务的架构中，通常会有一个路由网关的角色，来负责路由转发和过滤。对应到 Spring Cloud 中有 Zuul 和 Gateway 两个组件可用。 路由网关接收了所有的用户请求，有着很高的负载，因此它通常是一个集群。用户的请求会先经过一层负载均衡被发到路由网关。 服务配置与配置中心 在微服务应用中，服务数量巨多，而每个服务不同环境都有着不同的配置，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。需要注意的是此处的配置与注册中心注册的配置信息是两个概念，此处的配置是服务本身的一些配置信息，如下图： Spring Cloud 提供了 Spring Cloud Config 组件，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程 Git 仓库中，帮助我们管理服务的配置信息。 信息同步与消息总线 前一个问题讲到了每个服务都有一些配置信息，那么配置信息更新了我们该怎么办，手动一个个去更新？当然不是，Spring Cloud 提供了 Spring Cloud Bus 组件，它通过轻量消息代理连接各个分布的节点。当配置信息更新的时候，我们只要更新一个节点的配置，这个更新就会被广播到这个分布式系统中。 问题定位与链路追踪 在微服务系统中，服务之间可以相互调用，因此我们一个请求可能会一条调用链，而整个系统会存在一张调用网，其中任意一个服务调用失败或网络超时都可能导致整个请求失败。因为调用关系的复杂，这给问题的定位造成了极大的困难，这也是必须提供服务链路追踪的原因。 Spring Cloud 为我们提供了 Spring Cloud Sleuth 组件，它能够跟进一个请求到底有哪些服务参与，参与的顺序是怎样的，从而达到每个请求的步骤清晰可见。借助服务链路追踪，我们可以快速定位问题。 至此，Spring Cloud 的所有基础组件都介绍完了。但是目前所有的组件介绍都是分散的，它们组合起来，完整的样子是什么样的？如下图： 偷懒偷了张图，图中漏掉了 Config Server 和链路追踪组件。但是结合上文的介绍，我们大致可以脑补出这两个东西在图中的位置。Config Server 是一个与所有服务相连的服务集群，链路追踪组件则集成在每个服务中。 小结 服务治理为心脏，路由网关、消息中心、断路器、链路追踪、配置中心等为依托，构造了整个微服务框架的「五脏六腑」。当然，一个微服务系统远比本文所写的复杂得多，尤其是在不同的业务场景之下，因此想要更深入地了解它就需要我们不断地去实践。而作为前端，我了解这些内容一是为了更好地了解整个请求的流程，二是为了后续在 SOA 中接入 Node 子服务积累相关知识。 最后分享一句有趣的调侃 Spring 的话：在 Spring 中没有什么是一个注解解决不了的，如果有，那么就用两个注解。 &nbsp;推荐↓↓↓&nbsp; 长 按 关 注 👉【16个技术公众号】都在这里！ 涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。 万水千山总是情，点个 “ 好看” 行不行","@type":"BlogPosting","url":"https://mlh.app/2019/01/29/f1d0b52446ee0cf300cf6f287d06461e.html","headline":"从 Spring Cloud 看一个微服务框架的「五脏六腑」","dateModified":"2019-01-29T00:00:00+08:00","datePublished":"2019-01-29T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2019/01/29/f1d0b52446ee0cf300cf6f287d06461e.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>从 Spring Cloud 看一个微服务框架的「五脏六腑」</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="rich_media_content" id="js_content"> 
   <p style="text-align:center;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/XUfq62QbuNhyG8Y9IxZUNMLyjv7k7dsq3bia9CRMmdkOM1WyLYEHlib4MFfrqRE97iaUqJ7NwhZEoHu0U8NCXWzsA/640?wx_fmt=gif" alt="640?wx_fmt=gif"></p>
   <p style="min-height:1em;text-align:center;"><a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span class="js_jump_icon h5_image_link"><img style="letter-spacing:.544px;text-align:justify;color:rgb(62,62,62);width:76px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/XUfq62QbuNiaFZIbV1icByYIGKRlUcFt6IBMGhWJcyxibORgs6MEmSnJlA3ibibR7ibpudwZAbFZdqISttPaQTBkPPtQ/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></span></a></p>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span style="font-family:'宋体', SimSun;"><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"><strong>Linux编程</strong></span></strong></span></a>
   <span style="font-family:'黑体', SimHei;"><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong><strong><span style="letter-spacing:.544px;color:rgb(31,73,125);"></span></strong></span>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span style="letter-spacing:.544px;color:rgb(165,165,165);font-family:'黑体', SimHei;"><span>点击右侧关注，免费入门到精通！</span></span></a>
   <a href="https://mp.weixin.qq.com/s?__biz=MzU2MzcxNzgwMg==&amp;mid=2247483650&amp;idx=3&amp;sn=7d8d32410010e2f58a8b0e9b15fa23ec&amp;scene=21#wechat_redirect" rel="nofollow"><span class="js_jump_icon h5_image_link"><img style="width:56px;" title="1081255447.jpg" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/XUfq62QbuNiaFZIbV1icByYIGKRlUcFt6IldAicZsKdD8KXBZkWQz1eHWULt7Sy2XUdKWbFt8oY6f6nL5deCuF9yg/640?wx_fmt=jpeg" alt="640?wx_fmt=jpeg"></span></a>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:14px;color:rgb(136,136,136);">作者丨java团长</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Spring Cloud 是一个基于 Spring Boot 实现的微服务框架，它包含了实现微服务架构所需的各种组件。</span></p>
   <p><br></p>
   <blockquote>
    <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">注：Spring Boot 简单理解就是简化 Spring 项目的搭建、配置、组合的框架。因为与构建微服务本身没有直接关系，所以本文不对 Spring Boot 进行展开。另外本文有一些例子涉及到 Spring 和 Spring Boot，建议先了解一下 Spring 和 Spring Boot 再阅读本文。</span></p>
    <p><br></p>
    <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">本文的阅读对象主要是没有接触过服务架构，想对其有一个宏观的了解的同学。</span></p>
   </blockquote>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">本文将从 Spring Cloud 出发，分两小节讲述微服务框架的「五脏六腑」：</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">第一小节「服务架构」旨在说明的包括两点，一服务架构是什么及其必要性；二是服务架构的基本组成。为什么第一节写服务架构而不是微服务架构呢？原因主要是微服务架构本身与服务架构有着千丝万缕的关系，服务架构是微服务架构的根基。</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">第二小节「五脏六腑」则将结合 Spring Cloud 这个特例来介绍一个完整的微服务框架的组成。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">服务架构</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">为了方便理解，我先讲一个小故事：（改编自一知乎答主）</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Martin（微服务提出者也叫 Martin）刚来到公司时是一个基层员工，它上面有经理、老板，那个时候所有人都听老板的指挥。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">但是过了两年，公司的人越来越多，原来的模式下整个公司的运作效率太低，管理也很混乱。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">于是已经踏上中层岗位的 Martin 建议老板进行部门划分（服务化），专门的部门只做专门的事情（单一职责）。例如研发部门只做研发，人事部门只做招聘。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">老板听取了 Martin 的意见，对公司的组织架构进行了调整。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">有一天，Martin 发现公司的部门越来越多，各个部门并不能完全知道对方所做的事情，这对跨部门协作（服务调用）带来了困难。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">行政部门会（注册中心）来记录所有的部门，每当有新的部门行政都会记录下来（服务注册），然后公布出来让所有部门知道（服务发现）。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">在新的组织架构下，公司的效率逐步提高。老板也给 Martin 发了大量奖金作为奖励，Martin 从此赢取白富美走向了人生巅峰。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">这是一个公司组织架构演变的故事，主要讲的是随着公司规模的扩大，组织从集中化管理到分布化管理的过程。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">映射到我们的信息系统里来也是一样的，随着我们的系统越来越复杂，变得难以管理，也有人想到去拆分然后治理。在解决复杂问题上，分治可以说是一个屡试不爽的办法。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">服务化即是拆解的一种手段。而上面圆括号里面的内容其实就对应了一个服务化架构的最小组成元素，分别是服务、服务调用、注册中心、服务注册、服务发现。有了这些基本的组成要素，就可以实现一个最简单的服务架构。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif"></span><span style="font-size:16px;color:rgb(0,82,255);">面向服务的架构和微服务架构</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">面向服务的架构（SOA）和微服务架构是目前两种主流的服务化架构，都符合上面的例子，也有上面提到的所有组件。这两种服务架构有很多可以讲的，但是与本文的相关性不大，本文不做会过多展开，只简单介绍一下两者的区别。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">准确地说微服务是去 ESB（企业服务总线）的 SOA。ESB 借鉴了计算机组成原理中的通信模型 —— 总线，所有需要和外部系统通信的系统，通过 ESB 进行标准化地转换从而消除协议、异构系统之间的差异，这样就可以利用现有的系统构建一个全新的松耦合的异构的分布式系统。微服务架构去掉 ESB，本质上是一种去中心化的思想。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">五脏六腑</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">心脏</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">顺着上一节的思路，从最简单、最核心的问题出发，假设服务 A 要调用服务 B，会有什么问题？</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">服务在哪？（服务治理问题）</span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">怎么调用？（服务调用问题）</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">这两个是最核心的问题，也是任何微服务框架首要解决的两个问题。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">为了解决第一个问题 Spring Cloud 提供了 Eureka、Zookeeper、Cloud Foundry、Consul 等服务治理框架的集成。它们的工作模式是将所有的微服务注册到一个 Server 上，然后通过心跳进行服务健康监测。这样服务 A 调用 B 时可以从注册中心拿到可用的服务 B 的地址、端口进行调用。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">第二个服务调用有人可能认为就是一个简单的 HTTP 或者 RPC 调用，不是什么问题。但是在分布式的场景下，服务调用需要考虑的因素会更多。比如一个服务有多个实例，此时请求进来了交给谁处理，请求的负载怎么平衡到各个实例，都是比较棘手的问题。Spring Cloud 提供了两种服务调用的方式：一种是 Ribbon + restTemplate，另一种是 Feign。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">其中 Ribbon 是基于 HTTP 和 TCP 客户端的负载均衡器，restTemplate 是 Spring 提供的 Restful 远程调用的模板，两者结合就可以达到远程调用的负载均衡。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">而 Feign 是一个更加声明式的 HTTP 客户端，开发者可以像调用本地方法一样调用它，完全感觉不到是远程调用，结合 Ribbon 也可以做负载均衡。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">既然两个问题都得到了解决，我们就用一个例子来进一步说明一下，例子包含了微服务中最基本的三个角色（注册中心、服务提供者、服务消费者)：</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">注册中心</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">注解 @EnableEurekaServer 表示该 Spring Boot 应用是一个注册中心。</span></p>
   <p><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs java" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@EnableEurekaServer</span><br><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@SpringBootApplication</span><br><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">public</span>&nbsp;<span class="hljs-class" style="font-size:inherit;color:inherit;line-height:inherit;"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">class</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">EurekaserverApplication</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">public</span>&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">static</span>&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">main</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(String[]&nbsp;args)</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(EurekaserverApplication.class,&nbsp;args);<br>&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">eureka.client.registerWithEureka: false 和fetchRegistry: false 来表明自己是一个 eureka server。</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs bash" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);">server:<br>&nbsp;port:&nbsp;8080<br><br>eureka:<br>&nbsp;instance:<br>&nbsp;&nbsp;&nbsp;hostname:&nbsp;localhost<br>&nbsp;client:<br>&nbsp;&nbsp;&nbsp;registerWithEureka:&nbsp;<span class="hljs-literal" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">false</span><br>&nbsp;&nbsp;&nbsp;fetchRegistry:&nbsp;<span class="hljs-literal" style="font-size:inherit;line-height:inherit;color:rgb(174,135,250);">false</span><br>&nbsp;&nbsp;&nbsp;serviceUrl:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultZone:&nbsp;http://<span class="hljs-variable" style="font-size:inherit;line-height:inherit;color:rgb(98,151,85);">${eureka.instance.hostname}</span>:<span class="hljs-variable" style="font-size:inherit;line-height:inherit;color:rgb(98,151,85);">${server.port}</span>/eureka/<br></code></pre>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">service-hello 服务</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">注解 @EnableEurekaClient 表示他是一个 Eureka 客户端，它会在注册中心注册自己。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">注解 @RestController 表示这是一个控制器，@RequestMapping("/hello") 表示匹配到请求 '/hello' 时会调用该方法进行响应。</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs dart" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@SpringBootApplication</span><br><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@EnableEurekaClient</span><br><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@RestController</span><br>public&nbsp;<span class="hljs-class" style="font-size:inherit;color:inherit;line-height:inherit;"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">class</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">ServiceHelloApplication</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;public&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">static</span>&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">void</span>&nbsp;main(<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">String</span>[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(ServiceHelloApplication.<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">class</span>,&nbsp;args);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@Value</span>(<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">"<span class="hljs-subst" style="font-size:inherit;color:inherit;line-height:inherit;">${server.port}</span>"</span>)<br>&nbsp;&nbsp;&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">String</span>&nbsp;port;<br>&nbsp;&nbsp;&nbsp;<span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@RequestMapping</span>(<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">"/hello"</span>)<br>&nbsp;&nbsp;&nbsp;public&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">String</span>&nbsp;home(<span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@RequestParam</span>&nbsp;<span class="hljs-built_in" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">String</span>&nbsp;name)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">"hello&nbsp;"</span>+name+<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">",i&nbsp;am&nbsp;from&nbsp;port:"</span>&nbsp;+port;<br>&nbsp;&nbsp;&nbsp;}<br><br>}<br></code></pre>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">注册中心的地址为 http://localhost:8080/eureka/，也就是上面我们定义的。服务名为 service-hello，将会被调用者使用。</span></p>
   <p><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs makefile" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-section" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">eureka:</span><br>&nbsp;client:<br>&nbsp;&nbsp;&nbsp;serviceUrl:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defaultZone:&nbsp;http://localhost:8080/eureka/<br><span class="hljs-section" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">server:</span><br>&nbsp;port:&nbsp;8081<br><span class="hljs-section" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">spring:</span><br>&nbsp;application:<br>&nbsp;&nbsp;&nbsp;name:&nbsp;service-hello<br></code></pre>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">服务消费者 service-ribbon</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">假设 service-ribbon 端口为 8082，当我们访问 http://localhost:8080/hello 时，HelloControler 接收到请求，并调用 HelloService 中的 helloService 方法，HelloService 中通过定义的 restTemplate 去调用 http://service-hello/hello。此处要注意的是 @LoadBalanced 注解，它表示启用负载均衡。</span></p>
   <p style="letter-spacing:1px;"><br></p>
   <pre style="font-size:inherit;color:inherit;line-height:inherit;"><code class="hljs java" style="margin-left:2px;line-height:18px;font-size:14px;letter-spacing:0px;font-family:Consolas, Inconsolata, Courier, monospace;color:rgb(169,183,198);background:rgb(40,43,46);"><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@SpringBootApplication</span><br><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@EnableDiscoveryClient</span><br><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">public</span>&nbsp;<span class="hljs-class" style="font-size:inherit;color:inherit;line-height:inherit;"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">class</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">ServiceRibbonApplication</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">public</span>&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">static</span>&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">void</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">main</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(String[]&nbsp;args)</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(ServiceRibbonApplication.class,&nbsp;args);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@Bean</span><br>&nbsp;&nbsp;&nbsp;<span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@LoadBalanced</span><br>&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">RestTemplate&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">restTemplate</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">()</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">new</span>&nbsp;RestTemplate();<br>&nbsp;&nbsp;&nbsp;}<br><br>}<br><br><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@Service</span><br><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">public</span>&nbsp;<span class="hljs-class" style="font-size:inherit;color:inherit;line-height:inherit;"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">class</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">HelloService</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@Autowired</span><br>&nbsp;&nbsp;&nbsp;RestTemplate&nbsp;restTemplate;<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">public</span>&nbsp;String&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">helloService</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(String&nbsp;name)</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;restTemplate.getForObject(<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">"http://service-hello/hello?name="</span>+name,String.class);<br>&nbsp;&nbsp;&nbsp;}<br><br>}<br><br><span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@RestController</span><br><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">public</span>&nbsp;<span class="hljs-class" style="font-size:inherit;color:inherit;line-height:inherit;"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">class</span>&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">HelloControler</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@Autowired</span><br>&nbsp;&nbsp;&nbsp;HelloService&nbsp;helloService;<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-meta" style="font-size:inherit;line-height:inherit;color:rgb(91,218,237);">@RequestMapping</span>(value&nbsp;=&nbsp;<span class="hljs-string" style="font-size:inherit;line-height:inherit;color:rgb(238,220,112);">"/hello"</span>)<br>&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);"><span class="hljs-keyword" style="font-size:inherit;line-height:inherit;">public</span>&nbsp;String&nbsp;<span class="hljs-title" style="font-size:inherit;line-height:inherit;color:rgb(165,218,45);">hello</span><span class="hljs-params" style="font-size:inherit;line-height:inherit;color:rgb(255,152,35);">(@RequestParam&nbsp;String&nbsp;name)</span></span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="font-size:inherit;line-height:inherit;color:rgb(248,35,117);">return</span>&nbsp;helloService.helloService(name);<br>&nbsp;&nbsp;&nbsp;}<br><br>}<br></code></pre>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);"><br></span></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">至此其实一个微服务应用的雏形已经搭建出来了，服务治理、服务调用可以说是「五脏六腑」中的「心脏」。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">心脏的依托</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">接下来我们要进一步思考的是「五脏六腑」中其余的部分，因为少了它们人也是活不久的。下面通过一个问题或需求对应一个组件的方式进行介绍。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">服务“雪崩”与断路器</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">由于网络等原因，服务并不能保证 100% 可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗殆尽，导致服务瘫痪。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">由于服务与服务之间存在依赖，故障会在调用链路上传播，导致整个微服务系统崩溃，这就是服务故障的“雪崩”效应。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">为了解决这个问题，Spring Cloud 提供了对 Hystrix 断路器的集成，当服务调用失败的频次达到一定阈值，断路器将被开启，降级的策略可以开发者制定，一般是返回一个固定值。这样就能够避免连锁故障。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">此外 Spring Cloud 还提供 Hystrix Dashboard 和 Hystrix Turbine，帮助我们进行监控和聚合监控。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">服务暴露与路由网关</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">微服务中的服务很多，直接暴露给用户一是不安全，二是对用户不友好。因此在微服务和面向服务的架构中，通常会有一个路由网关的角色，来负责路由转发和过滤。对应到 Spring Cloud 中有 Zuul 和 Gateway 两个组件可用。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">路由网关接收了所有的用户请求，有着很高的负载，因此它通常是一个集群。用户的请求会先经过一层负载均衡被发到路由网关。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">服务配置与配置中心</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">在微服务应用中，服务数量巨多，而每个服务不同环境都有着不同的配置，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。需要注意的是此处的配置与注册中心注册的配置信息是两个概念，此处的配置是服务本身的一些配置信息，如下图：</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><img style="border:1px solid rgb(238,237,235);background-position:50% 50%;background-repeat:no-repeat;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQyzOu4YRFcehzug6SLoty0RFPjIhG5oqa5ZiagJibmBBkiaVNktFUBpdSc6KCUfNUsuZlu1H8EUhibiaJg/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Spring Cloud 提供了 Spring Cloud Config 组件，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程 Git 仓库中，帮助我们管理服务的配置信息。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">信息同步与消息总线</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">前一个问题讲到了每个服务都有一些配置信息，那么配置信息更新了我们该怎么办，手动一个个去更新？当然不是，Spring Cloud 提供了 Spring Cloud Bus 组件，它通过轻量消息代理连接各个分布的节点。当配置信息更新的时候，我们只要更新一个节点的配置，这个更新就会被广播到这个分布式系统中。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><strong><span style="font-size:16px;color:rgb(74,74,74);">问题定位与链路追踪</span></strong></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">在微服务系统中，服务之间可以相互调用，因此我们一个请求可能会一条调用链，而整个系统会存在一张调用网，其中任意一个服务调用失败或网络超时都可能导致整个请求失败。因为调用关系的复杂，这给问题的定位造成了极大的困难，这也是必须提供服务链路追踪的原因。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">Spring Cloud 为我们提供了 Spring Cloud Sleuth 组件，它能够跟进一个请求到底有哪些服务参与，参与的顺序是怎样的，从而达到每个请求的步骤清晰可见。借助服务链路追踪，我们可以快速定位问题。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">至此，Spring Cloud 的所有基础组件都介绍完了。但是目前所有的组件介绍都是分散的，它们组合起来，完整的样子是什么样的？如下图：</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQyzOu4YRFcehzug6SLoty0REKAqFeUmLeLqQ0N0QYL2czCxa9xWia8Ghy8iaBZ7ibh61icGkkqOJ9WIFw/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">偷懒偷了张图，图中漏掉了 Config Server 和链路追踪组件。但是结合上文的介绍，我们大致可以脑补出这两个东西在图中的位置。Config Server 是一个与所有服务相连的服务集群，链路追踪组件则集成在每个服务中。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(0,82,255);"><img class="__bg_gif" style="color:rgb(0,128,255);font-family:'宋体';letter-spacing:1px;font-size:8px;text-align:center;vertical-align:middle;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/IwiaNBuWUDUw4OUxv50sClowAsFgibBOT8DicW3x9nlUu6buibjSVPyf3vst4EuG4dZOZcB2P62icZnyEMeP8eqoYog/640?wx_fmt=gif" alt="640?wx_fmt=gif">小结</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">服务治理为心脏，路由网关、消息中心、断路器、链路追踪、配置中心等为依托，构造了整个微服务框架的「五脏六腑」。当然，一个微服务系统远比本文所写的复杂得多，尤其是在不同的业务场景之下，因此想要更深入地了解它就需要我们不断地去实践。而作为前端，我了解这些内容一是为了更好地了解整个请求的流程，二是为了后续在 SOA 中接入 Node 子服务积累相关知识。</span></p>
   <p><br></p>
   <p style="letter-spacing:1px;"><span style="font-size:16px;color:rgb(74,74,74);">最后分享一句有趣的调侃 Spring 的话：在 Spring 中没有什么是一个注解解决不了的，如果有，那么就用两个注解。</span></p>
   <p><br></p>
   <p><br></p>
   <p style="text-align:center;letter-spacing:1.5px;"><span style="color:rgb(255,255,255);"><strong><span style="font-size:20px;">&nbsp;推荐↓↓↓&nbsp;</span></strong></span></p>
   <img style="vertical-align:middle;width:313px;" src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/IwiaNBuWUDUzX3vMCt57DzWD1FUkicYK3C3VObzhyt4YU3rXujLwMXHoHqpB6B72h44DNib9J9jbQHk3giaxAeABWg/640?wx_fmt=png" alt="640?wx_fmt=png">
   <p><strong>长</strong></p>
   <p><strong>按</strong></p>
   <p><strong>关</strong></p>
   <p><strong>注</strong></p>
   <p style="letter-spacing:0px;"><strong><span style="font-size:18px;">👉</span></strong><span style="font-size:17px;"><strong>【</strong></span><a href="https://mp.weixin.qq.com/s?__biz=MzUzMDc0NzU4Nw==&amp;mid=2247483768&amp;idx=1&amp;sn=4ef4f1510616baa395c507e32bb439d7&amp;scene=21#wechat_redirect" rel="nofollow" style="text-decoration:underline;color:rgb(255,79,121);font-size:17px;"><span style="color:rgb(255,79,121);font-size:17px;"><strong>16个技术公众号</strong></span></a><span style="font-size:17px;"><strong>】都在这里！</strong></span></p>
   <p><span style="color:rgb(136,136,136);font-size:15px;">涵盖：程序员大咖、源码共读、程序员共读、数据结构与算法、黑客技术和网络安全、大数据科技、编程前端、Java、Python、Web编程开发、Android、iOS开发、Linux、数据库研发、幽默程序员等。</span></p>
   <img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/ol72Wnba7fLkfGhCjKwHfZOmHMkVTIomtmHARHGo86u52ZIGicxfPPFBQ85dBUWf3trqDHPUuN7E2e26DpvfJdQ/640?wx_fmt=png" alt="640?wx_fmt=png">万水千山总是情，点个 “
   <strong><span style="color:rgb(0,112,192);">好看</span></strong>” 行不行
  </div> 
 </div> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
