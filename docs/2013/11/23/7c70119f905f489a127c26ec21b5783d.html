<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>MD5 Hash算法全流程及PYTHON的实现 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="MD5 Hash算法全流程及PYTHON的实现" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="大作业准备做 MD5 的硬件实现 但仅凭网上的资料自己再写出一个MD5程序还是颇费时间的 转载请注明http://blog.csdn.net/boksic 如有疑问欢迎留言 MD5的整个流程描述可以参照&nbsp;RFC1321，在此仅列出HASH算法（在此之前还要做位填充）的伪代码 /* Process each 16-word block. */ For i = 0 to N/16-1 do /* Copy block i into X. */ For j = 0 to 15 do Set X[j] to M[i*16+j]. end /* of loop on j */ /* Save A as AA, B as BB, C as CC, and D as DD. */ AA = A BB = B CC = C DD = D /* Round 1. */ /* Let [abcd k s i] denote the operation a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 0 7 1] [DABC 1 12 2] [CDAB 2 17 3] [BCDA 3 22 4] [ABCD 4 7 5] [DABC 5 12 6] [CDAB 6 17 7] [BCDA 7 22 8] [ABCD 8 7 9] [DABC 9 12 10] [CDAB 10 17 11] [BCDA 11 22 12] [ABCD 12 7 13] [DABC 13 12 14] [CDAB 14 17 15] [BCDA 15 22 16] /* Round 2. */ /* Let [abcd k s i] denote the operation a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 1 5 17] [DABC 6 9 18] [CDAB 11 14 19] [BCDA 0 20 20] [ABCD 5 5 21] [DABC 10 9 22] [CDAB 15 14 23] [BCDA 4 20 24] [ABCD 9 5 25] [DABC 14 9 26] [CDAB 3 14 27] [BCDA 8 20 28] [ABCD 13 5 29] [DABC 2 9 30] [CDAB 7 14 31] [BCDA 12 20 32] /* Round 3. */ /* Let [abcd k s t] denote the operation a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 5 4 33] [DABC 8 11 34] [CDAB 11 16 35] [BCDA 14 23 36] [ABCD 1 4 37] [DABC 4 11 38] [CDAB 7 16 39] [BCDA 10 23 40] [ABCD 13 4 41] [DABC 0 11 42] [CDAB 3 16 43] [BCDA 6 23 44] [ABCD 9 4 45] [DABC 12 11 46] [CDAB 15 16 47] [BCDA 2 23 48] /* Round 4. */ /* Let [abcd k s t] denote the operation a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 0 6 49] [DABC 7 10 50] [CDAB 14 15 51] [BCDA 5 21 52] [ABCD 12 6 53] [DABC 3 10 54] [CDAB 10 15 55] [BCDA 1 21 56] [ABCD 8 6 57] [DABC 15 10 58] [CDAB 6 15 59] [BCDA 13 21 60] [ABCD 4 6 61] [DABC 11 10 62] [CDAB 2 15 63] [BCDA 9 21 64] /* Then perform the following additions. (That is increment each of the four registers by the value it had before this block was started.) */ A = A + AA B = B + BB C = C + CC D = D + DD end /* of loop on i */ 虽然PYTHON中用内置函数一句话就能出结果，但是要理解算法写出代码出来还是要走一遍流程。 首先是定义当中涉及到的几个常量与函数 from math import * in_str=&quot;a&quot; F = lambda x, y, z: (((x) &amp; (y)) | ((~x) &amp; (z))) G = lambda x, y, z: (((x) &amp; (z)) | ((y) &amp; (~z))) H = lambda x, y, z: ((x) ^ (y) ^ (z)) I = lambda x, y, z: ((y) ^ ((x) | (~z))) RL = lambda x,n: (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n)))) FF= lambda a,b,c,d,x,s,ac:func def FF(a, b, c, d, x, s, ac): a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def GG(a, b, c, d, x, s, ac): a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def HH(a, b, c, d, x, s, ac): a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def II(a, b, c, d, x, s, ac): a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a FUNC=[FF,GG,HH,II] S_DATA=[[7,12,17,22],[5,9,14,20],[4,11,16,23],[6,10,15,21]] buf=[0x67452301,0xefcdab89,0x98badcfe,0x10325476] in_data=&#39;&#39;.join(&quot;%.2x&quot; %ord(i) for i in in_str) FF,GG,HH,II就是用到的几个非线性函数， S11-S44是移位常数，in_data是64步中每步用到的常数 还有初始值buf 整个过程就是不停的处理这个BUF 对输入填充部分因为代码写的比较简陋，功能过于局限，所以就不贴出来了 核心算法部分 for i in range(4): for j in range(16): inbufn=(i==0)*j+(i==1)*(1+5*j)%16+(i==2)*(5+3*j)%16+(i==3)*(7*j)%16 temp_buf[-j%4]=FUNC[i](temp_buf[-j%4],temp_buf[(1-j)%4],temp_buf[(2-j)%4],temp_buf[(3-j)%4],in_buf[inbufn],S_DATA[i][j%4],T_DATA[i*16+j]) print hex(temp_buf[0]),hex(temp_buf[1]),hex(temp_buf[2]),hex(temp_buf[3])需要注意的就是inbuf的序号inbufn跟轮数的关系 测试一下 对&quot;a&quot;进行hash Input string is a Hex format: 0x61 pad length is 55 After padding in_data:6180000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000800000000000000 in_buf is : 00008061000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000800000000 T_DATA= 0xd76aa478L 0xe8c7b756L 0x242070db 0xc1bdceeeL 0xf57c0fafL 0x4787c62a 0xa8304613L 0xfd469501L 0x698098d8 0x8b44f7afL 0xffff5bb1L 0x895cd7beL 0x6b901122 0xfd987193L 0xa679438eL 0x49b40821 0xf61e2562L 0xc040b340L 0x265e5a51 0xe9b6c7aaL 0xd62f105dL 0x2441453 0xd8a1e681L 0xe7d3fbc8L 0x21e1cde6 0xc33707d6L 0xf4d50d87L 0x455a14ed 0xa9e3e905L 0xfcefa3f8L 0x676f02d9 0x8d2a4c8aL 0xfffa3942L 0x8771f681L 0x6d9d6122 0xfde5380cL 0xa4beea44L 0x4bdecfa9 0xf6bb4b60L 0xbebfbc70L 0x289b7ec6 0xeaa127faL 0xd4ef3085L 0x4881d05 0xd9d4d039L 0xe6db99e5L 0x1fa27cf8 0xc4ac5665L 0xf4292244L 0x432aff97 0xab9423a7L 0xfc93a039L 0x655b59c3 0x8f0ccc92L 0xffeff47dL 0x85845dd1L 0x6fa87e4f 0xfe2ce6e0L 0xa3014314L 0x4e0811a1 0xf7537e82L 0xbd3af235L 0x2ad7d2bb 0xeb86d391L a b c d =========Round 1============== 0xa56017f4L 0xefcdab89L 0x98badcfeL 0x10325476 0xa56017f4L 0xefcdab89L 0x98badcfeL 0xf2d58361L 0xa56017f4L 0xefcdab89L 0xe65857a7L 0xf2d58361L 0xa56017f4L 0x607d9686L 0xe65857a7L 0xf2d58361L 0x3a9d5bccL 0x607d9686L 0xe65857a7L 0xf2d58361L 0x3a9d5bccL 0x607d9686L 0xe65857a7L 0xe0a07db7L 0x3a9d5bccL 0x607d9686L 0xd31ddc83L 0xe0a07db7L 0x3a9d5bccL 0xa8af6da5L 0xd31ddc83L 0xe0a07db7L 0xbe580957L 0xa8af6da5L 0xd31ddc83L 0xe0a07db7L 0xbe580957L 0xa8af6da5L 0xd31ddc83L 0xf386bea6L 0xbe580957L 0xa8af6da5L 0xf5fdd933L 0xf386bea6L 0xbe580957L 0x68493d6aL 0xf5fdd933L 0xf386bea6L 0x44244cf8L 0x68493d6aL 0xf5fdd933L 0xf386bea6L 0x44244cf8L 0x68493d6aL 0xf5fdd933L 0xd0fe9b27L 0x44244cf8L 0x68493d6aL 0x6360a45fL 0xd0fe9b27L 0x44244cf8L 0xf01e3ce2L 0x6360a45fL 0xd0fe9b27L =========Round 2============== 0x9c341767L 0xf01e3ce2L 0x6360a45fL 0xd0fe9b27L 0x9c341767L 0xf01e3ce2L 0x6360a45fL 0x970ab3a9L 0x9c341767L 0xf01e3ce2L 0xe39ffd23L 0x970ab3a9L 0x9c341767L 0x8d25cc66L 0xe39ffd23L 0x970ab3a9L 0x8c444930L 0x8d25cc66L 0xe39ffd23L 0x970ab3a9L 0x8c444930L 0x8d25cc66L 0xe39ffd23L 0x7267097aL 0x8c444930L 0x8d25cc66L 0x2dacb8a3L 0x7267097aL 0x8c444930L 0x373beab0L 0x2dacb8a3L 0x7267097aL 0xf175e3adL 0x373beab0L 0x2dacb8a3L 0x7267097aL 0xf175e3adL 0x373beab0L 0x2dacb8a3L 0x9d5df67eL 0xf175e3adL 0x373beab0L 0x87b7f475L 0x9d5df67eL 0xf175e3adL 0xc8f891b4L 0x87b7f475L 0x9d5df67eL 0x93842e98L 0xc8f891b4L 0x87b7f475L 0x9d5df67eL 0x93842e98L 0xc8f891b4L 0x87b7f475L 0xc7043b64L 0x93842e98L 0xc8f891b4L 0x94a2ebeeL 0xc7043b64L 0x93842e98L 0x3745961fL 0x94a2ebeeL 0xc7043b64L =========Round 3============== 0xbd607d1eL 0x3745961fL 0x94a2ebeeL 0xc7043b64L 0xbd607d1eL 0x3745961fL 0x94a2ebeeL 0xa6f72085L 0xbd607d1eL 0x3745961fL 0xbf8b4f98L 0xa6f72085L 0xbd607d1eL 0xdaf7f308L 0xbf8b4f98L 0xa6f72085L 0x35a82a7aL 0xdaf7f308L 0xbf8b4f98L 0xa6f72085L 0x35a82a7aL 0xdaf7f308L 0xbf8b4f98L 0x89e0ec97L 0x35a82a7aL 0xdaf7f308L 0x5abe099cL 0x89e0ec97L 0x35a82a7aL 0xcf7e60dbL 0x5abe099cL 0x89e0ec97L 0x75c151e2L 0xcf7e60dbL 0x5abe099cL 0x89e0ec97L 0x75c151e2L 0xcf7e60dbL 0x5abe099cL 0x942e0c86L 0x75c151e2L 0xcf7e60dbL 0xc0e6ac4L 0x942e0c86L 0x75c151e2L 0xcc6f5e9eL 0xc0e6ac4L 0x942e0c86L 0xac50e18L 0xcc6f5e9eL 0xc0e6ac4L 0x942e0c86L 0xac50e18L 0xcc6f5e9eL 0xc0e6ac4L 0x79ca7845L 0xac50e18L 0xcc6f5e9eL 0x8a4a6356L 0x79ca7845L 0xac50e18L 0x918f93bbL 0x8a4a6356L 0x79ca7845L =========Round 4============== 0xcab8fe42L 0x918f93bbL 0x8a4a6356L 0x79ca7845L 0xcab8fe42L 0x918f93bbL 0x8a4a6356L 0x6a4daeeeL 0xcab8fe42L 0x918f93bbL 0x36269c3fL 0x6a4daeeeL 0xcab8fe42L 0x1ee405ebL 0x36269c3fL 0x6a4daeeeL 0x982c7861L 0x1ee405ebL 0x36269c3fL 0x6a4daeeeL 0x982c7861L 0x1ee405ebL 0x36269c3fL 0x6812a362L 0x982c7861L 0x1ee405ebL 0x71fc7709L 0x6812a362L 0x982c7861L 0x893501c0L 0x71fc7709L 0x6812a362L 0xfebd62fdL 0x893501c0L 0x71fc7709L 0x6812a362L 0xfebd62fdL 0x893501c0L 0x71fc7709L 0x28936a74L 0xfebd62fdL 0x893501c0L 0x53e33526L 0x28936a74L 0xfebd62fdL 0xaa4d8ae3L 0x53e33526L 0x28936a74L 0x52309e0bL 0xaa4d8ae3L 0x53e33526L 0x28936a74L 0x52309e0bL 0xaa4d8ae3L 0x53e33526L 0x50f422f3L 0x52309e0bL 0xaa4d8ae3L 0x49dee633L 0x50f422f3L 0x52309e0bL 0xb8e94637L 0x49dee633L 0x50f422f3L =========Result is :0cc175b9c0f1b6a831c399e269772661============ &nbsp;0cc175b9c0f1b6a831c399e269772661结果正确 这样，接下来写Verilog代码可以有个流程参考了 另附verilog的综合结果 阅读更多" />
<meta property="og:description" content="大作业准备做 MD5 的硬件实现 但仅凭网上的资料自己再写出一个MD5程序还是颇费时间的 转载请注明http://blog.csdn.net/boksic 如有疑问欢迎留言 MD5的整个流程描述可以参照&nbsp;RFC1321，在此仅列出HASH算法（在此之前还要做位填充）的伪代码 /* Process each 16-word block. */ For i = 0 to N/16-1 do /* Copy block i into X. */ For j = 0 to 15 do Set X[j] to M[i*16+j]. end /* of loop on j */ /* Save A as AA, B as BB, C as CC, and D as DD. */ AA = A BB = B CC = C DD = D /* Round 1. */ /* Let [abcd k s i] denote the operation a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 0 7 1] [DABC 1 12 2] [CDAB 2 17 3] [BCDA 3 22 4] [ABCD 4 7 5] [DABC 5 12 6] [CDAB 6 17 7] [BCDA 7 22 8] [ABCD 8 7 9] [DABC 9 12 10] [CDAB 10 17 11] [BCDA 11 22 12] [ABCD 12 7 13] [DABC 13 12 14] [CDAB 14 17 15] [BCDA 15 22 16] /* Round 2. */ /* Let [abcd k s i] denote the operation a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 1 5 17] [DABC 6 9 18] [CDAB 11 14 19] [BCDA 0 20 20] [ABCD 5 5 21] [DABC 10 9 22] [CDAB 15 14 23] [BCDA 4 20 24] [ABCD 9 5 25] [DABC 14 9 26] [CDAB 3 14 27] [BCDA 8 20 28] [ABCD 13 5 29] [DABC 2 9 30] [CDAB 7 14 31] [BCDA 12 20 32] /* Round 3. */ /* Let [abcd k s t] denote the operation a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 5 4 33] [DABC 8 11 34] [CDAB 11 16 35] [BCDA 14 23 36] [ABCD 1 4 37] [DABC 4 11 38] [CDAB 7 16 39] [BCDA 10 23 40] [ABCD 13 4 41] [DABC 0 11 42] [CDAB 3 16 43] [BCDA 6 23 44] [ABCD 9 4 45] [DABC 12 11 46] [CDAB 15 16 47] [BCDA 2 23 48] /* Round 4. */ /* Let [abcd k s t] denote the operation a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 0 6 49] [DABC 7 10 50] [CDAB 14 15 51] [BCDA 5 21 52] [ABCD 12 6 53] [DABC 3 10 54] [CDAB 10 15 55] [BCDA 1 21 56] [ABCD 8 6 57] [DABC 15 10 58] [CDAB 6 15 59] [BCDA 13 21 60] [ABCD 4 6 61] [DABC 11 10 62] [CDAB 2 15 63] [BCDA 9 21 64] /* Then perform the following additions. (That is increment each of the four registers by the value it had before this block was started.) */ A = A + AA B = B + BB C = C + CC D = D + DD end /* of loop on i */ 虽然PYTHON中用内置函数一句话就能出结果，但是要理解算法写出代码出来还是要走一遍流程。 首先是定义当中涉及到的几个常量与函数 from math import * in_str=&quot;a&quot; F = lambda x, y, z: (((x) &amp; (y)) | ((~x) &amp; (z))) G = lambda x, y, z: (((x) &amp; (z)) | ((y) &amp; (~z))) H = lambda x, y, z: ((x) ^ (y) ^ (z)) I = lambda x, y, z: ((y) ^ ((x) | (~z))) RL = lambda x,n: (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n)))) FF= lambda a,b,c,d,x,s,ac:func def FF(a, b, c, d, x, s, ac): a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def GG(a, b, c, d, x, s, ac): a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def HH(a, b, c, d, x, s, ac): a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def II(a, b, c, d, x, s, ac): a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a FUNC=[FF,GG,HH,II] S_DATA=[[7,12,17,22],[5,9,14,20],[4,11,16,23],[6,10,15,21]] buf=[0x67452301,0xefcdab89,0x98badcfe,0x10325476] in_data=&#39;&#39;.join(&quot;%.2x&quot; %ord(i) for i in in_str) FF,GG,HH,II就是用到的几个非线性函数， S11-S44是移位常数，in_data是64步中每步用到的常数 还有初始值buf 整个过程就是不停的处理这个BUF 对输入填充部分因为代码写的比较简陋，功能过于局限，所以就不贴出来了 核心算法部分 for i in range(4): for j in range(16): inbufn=(i==0)*j+(i==1)*(1+5*j)%16+(i==2)*(5+3*j)%16+(i==3)*(7*j)%16 temp_buf[-j%4]=FUNC[i](temp_buf[-j%4],temp_buf[(1-j)%4],temp_buf[(2-j)%4],temp_buf[(3-j)%4],in_buf[inbufn],S_DATA[i][j%4],T_DATA[i*16+j]) print hex(temp_buf[0]),hex(temp_buf[1]),hex(temp_buf[2]),hex(temp_buf[3])需要注意的就是inbuf的序号inbufn跟轮数的关系 测试一下 对&quot;a&quot;进行hash Input string is a Hex format: 0x61 pad length is 55 After padding in_data:6180000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000800000000000000 in_buf is : 00008061000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000800000000 T_DATA= 0xd76aa478L 0xe8c7b756L 0x242070db 0xc1bdceeeL 0xf57c0fafL 0x4787c62a 0xa8304613L 0xfd469501L 0x698098d8 0x8b44f7afL 0xffff5bb1L 0x895cd7beL 0x6b901122 0xfd987193L 0xa679438eL 0x49b40821 0xf61e2562L 0xc040b340L 0x265e5a51 0xe9b6c7aaL 0xd62f105dL 0x2441453 0xd8a1e681L 0xe7d3fbc8L 0x21e1cde6 0xc33707d6L 0xf4d50d87L 0x455a14ed 0xa9e3e905L 0xfcefa3f8L 0x676f02d9 0x8d2a4c8aL 0xfffa3942L 0x8771f681L 0x6d9d6122 0xfde5380cL 0xa4beea44L 0x4bdecfa9 0xf6bb4b60L 0xbebfbc70L 0x289b7ec6 0xeaa127faL 0xd4ef3085L 0x4881d05 0xd9d4d039L 0xe6db99e5L 0x1fa27cf8 0xc4ac5665L 0xf4292244L 0x432aff97 0xab9423a7L 0xfc93a039L 0x655b59c3 0x8f0ccc92L 0xffeff47dL 0x85845dd1L 0x6fa87e4f 0xfe2ce6e0L 0xa3014314L 0x4e0811a1 0xf7537e82L 0xbd3af235L 0x2ad7d2bb 0xeb86d391L a b c d =========Round 1============== 0xa56017f4L 0xefcdab89L 0x98badcfeL 0x10325476 0xa56017f4L 0xefcdab89L 0x98badcfeL 0xf2d58361L 0xa56017f4L 0xefcdab89L 0xe65857a7L 0xf2d58361L 0xa56017f4L 0x607d9686L 0xe65857a7L 0xf2d58361L 0x3a9d5bccL 0x607d9686L 0xe65857a7L 0xf2d58361L 0x3a9d5bccL 0x607d9686L 0xe65857a7L 0xe0a07db7L 0x3a9d5bccL 0x607d9686L 0xd31ddc83L 0xe0a07db7L 0x3a9d5bccL 0xa8af6da5L 0xd31ddc83L 0xe0a07db7L 0xbe580957L 0xa8af6da5L 0xd31ddc83L 0xe0a07db7L 0xbe580957L 0xa8af6da5L 0xd31ddc83L 0xf386bea6L 0xbe580957L 0xa8af6da5L 0xf5fdd933L 0xf386bea6L 0xbe580957L 0x68493d6aL 0xf5fdd933L 0xf386bea6L 0x44244cf8L 0x68493d6aL 0xf5fdd933L 0xf386bea6L 0x44244cf8L 0x68493d6aL 0xf5fdd933L 0xd0fe9b27L 0x44244cf8L 0x68493d6aL 0x6360a45fL 0xd0fe9b27L 0x44244cf8L 0xf01e3ce2L 0x6360a45fL 0xd0fe9b27L =========Round 2============== 0x9c341767L 0xf01e3ce2L 0x6360a45fL 0xd0fe9b27L 0x9c341767L 0xf01e3ce2L 0x6360a45fL 0x970ab3a9L 0x9c341767L 0xf01e3ce2L 0xe39ffd23L 0x970ab3a9L 0x9c341767L 0x8d25cc66L 0xe39ffd23L 0x970ab3a9L 0x8c444930L 0x8d25cc66L 0xe39ffd23L 0x970ab3a9L 0x8c444930L 0x8d25cc66L 0xe39ffd23L 0x7267097aL 0x8c444930L 0x8d25cc66L 0x2dacb8a3L 0x7267097aL 0x8c444930L 0x373beab0L 0x2dacb8a3L 0x7267097aL 0xf175e3adL 0x373beab0L 0x2dacb8a3L 0x7267097aL 0xf175e3adL 0x373beab0L 0x2dacb8a3L 0x9d5df67eL 0xf175e3adL 0x373beab0L 0x87b7f475L 0x9d5df67eL 0xf175e3adL 0xc8f891b4L 0x87b7f475L 0x9d5df67eL 0x93842e98L 0xc8f891b4L 0x87b7f475L 0x9d5df67eL 0x93842e98L 0xc8f891b4L 0x87b7f475L 0xc7043b64L 0x93842e98L 0xc8f891b4L 0x94a2ebeeL 0xc7043b64L 0x93842e98L 0x3745961fL 0x94a2ebeeL 0xc7043b64L =========Round 3============== 0xbd607d1eL 0x3745961fL 0x94a2ebeeL 0xc7043b64L 0xbd607d1eL 0x3745961fL 0x94a2ebeeL 0xa6f72085L 0xbd607d1eL 0x3745961fL 0xbf8b4f98L 0xa6f72085L 0xbd607d1eL 0xdaf7f308L 0xbf8b4f98L 0xa6f72085L 0x35a82a7aL 0xdaf7f308L 0xbf8b4f98L 0xa6f72085L 0x35a82a7aL 0xdaf7f308L 0xbf8b4f98L 0x89e0ec97L 0x35a82a7aL 0xdaf7f308L 0x5abe099cL 0x89e0ec97L 0x35a82a7aL 0xcf7e60dbL 0x5abe099cL 0x89e0ec97L 0x75c151e2L 0xcf7e60dbL 0x5abe099cL 0x89e0ec97L 0x75c151e2L 0xcf7e60dbL 0x5abe099cL 0x942e0c86L 0x75c151e2L 0xcf7e60dbL 0xc0e6ac4L 0x942e0c86L 0x75c151e2L 0xcc6f5e9eL 0xc0e6ac4L 0x942e0c86L 0xac50e18L 0xcc6f5e9eL 0xc0e6ac4L 0x942e0c86L 0xac50e18L 0xcc6f5e9eL 0xc0e6ac4L 0x79ca7845L 0xac50e18L 0xcc6f5e9eL 0x8a4a6356L 0x79ca7845L 0xac50e18L 0x918f93bbL 0x8a4a6356L 0x79ca7845L =========Round 4============== 0xcab8fe42L 0x918f93bbL 0x8a4a6356L 0x79ca7845L 0xcab8fe42L 0x918f93bbL 0x8a4a6356L 0x6a4daeeeL 0xcab8fe42L 0x918f93bbL 0x36269c3fL 0x6a4daeeeL 0xcab8fe42L 0x1ee405ebL 0x36269c3fL 0x6a4daeeeL 0x982c7861L 0x1ee405ebL 0x36269c3fL 0x6a4daeeeL 0x982c7861L 0x1ee405ebL 0x36269c3fL 0x6812a362L 0x982c7861L 0x1ee405ebL 0x71fc7709L 0x6812a362L 0x982c7861L 0x893501c0L 0x71fc7709L 0x6812a362L 0xfebd62fdL 0x893501c0L 0x71fc7709L 0x6812a362L 0xfebd62fdL 0x893501c0L 0x71fc7709L 0x28936a74L 0xfebd62fdL 0x893501c0L 0x53e33526L 0x28936a74L 0xfebd62fdL 0xaa4d8ae3L 0x53e33526L 0x28936a74L 0x52309e0bL 0xaa4d8ae3L 0x53e33526L 0x28936a74L 0x52309e0bL 0xaa4d8ae3L 0x53e33526L 0x50f422f3L 0x52309e0bL 0xaa4d8ae3L 0x49dee633L 0x50f422f3L 0x52309e0bL 0xb8e94637L 0x49dee633L 0x50f422f3L =========Result is :0cc175b9c0f1b6a831c399e269772661============ &nbsp;0cc175b9c0f1b6a831c399e269772661结果正确 这样，接下来写Verilog代码可以有个流程参考了 另附verilog的综合结果 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-11-23T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"大作业准备做 MD5 的硬件实现 但仅凭网上的资料自己再写出一个MD5程序还是颇费时间的 转载请注明http://blog.csdn.net/boksic 如有疑问欢迎留言 MD5的整个流程描述可以参照&nbsp;RFC1321，在此仅列出HASH算法（在此之前还要做位填充）的伪代码 /* Process each 16-word block. */ For i = 0 to N/16-1 do /* Copy block i into X. */ For j = 0 to 15 do Set X[j] to M[i*16+j]. end /* of loop on j */ /* Save A as AA, B as BB, C as CC, and D as DD. */ AA = A BB = B CC = C DD = D /* Round 1. */ /* Let [abcd k s i] denote the operation a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 0 7 1] [DABC 1 12 2] [CDAB 2 17 3] [BCDA 3 22 4] [ABCD 4 7 5] [DABC 5 12 6] [CDAB 6 17 7] [BCDA 7 22 8] [ABCD 8 7 9] [DABC 9 12 10] [CDAB 10 17 11] [BCDA 11 22 12] [ABCD 12 7 13] [DABC 13 12 14] [CDAB 14 17 15] [BCDA 15 22 16] /* Round 2. */ /* Let [abcd k s i] denote the operation a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 1 5 17] [DABC 6 9 18] [CDAB 11 14 19] [BCDA 0 20 20] [ABCD 5 5 21] [DABC 10 9 22] [CDAB 15 14 23] [BCDA 4 20 24] [ABCD 9 5 25] [DABC 14 9 26] [CDAB 3 14 27] [BCDA 8 20 28] [ABCD 13 5 29] [DABC 2 9 30] [CDAB 7 14 31] [BCDA 12 20 32] /* Round 3. */ /* Let [abcd k s t] denote the operation a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 5 4 33] [DABC 8 11 34] [CDAB 11 16 35] [BCDA 14 23 36] [ABCD 1 4 37] [DABC 4 11 38] [CDAB 7 16 39] [BCDA 10 23 40] [ABCD 13 4 41] [DABC 0 11 42] [CDAB 3 16 43] [BCDA 6 23 44] [ABCD 9 4 45] [DABC 12 11 46] [CDAB 15 16 47] [BCDA 2 23 48] /* Round 4. */ /* Let [abcd k s t] denote the operation a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */ /* Do the following 16 operations. */ [ABCD 0 6 49] [DABC 7 10 50] [CDAB 14 15 51] [BCDA 5 21 52] [ABCD 12 6 53] [DABC 3 10 54] [CDAB 10 15 55] [BCDA 1 21 56] [ABCD 8 6 57] [DABC 15 10 58] [CDAB 6 15 59] [BCDA 13 21 60] [ABCD 4 6 61] [DABC 11 10 62] [CDAB 2 15 63] [BCDA 9 21 64] /* Then perform the following additions. (That is increment each of the four registers by the value it had before this block was started.) */ A = A + AA B = B + BB C = C + CC D = D + DD end /* of loop on i */ 虽然PYTHON中用内置函数一句话就能出结果，但是要理解算法写出代码出来还是要走一遍流程。 首先是定义当中涉及到的几个常量与函数 from math import * in_str=&quot;a&quot; F = lambda x, y, z: (((x) &amp; (y)) | ((~x) &amp; (z))) G = lambda x, y, z: (((x) &amp; (z)) | ((y) &amp; (~z))) H = lambda x, y, z: ((x) ^ (y) ^ (z)) I = lambda x, y, z: ((y) ^ ((x) | (~z))) RL = lambda x,n: (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n)))) FF= lambda a,b,c,d,x,s,ac:func def FF(a, b, c, d, x, s, ac): a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def GG(a, b, c, d, x, s, ac): a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def HH(a, b, c, d, x, s, ac): a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def II(a, b, c, d, x, s, ac): a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a FUNC=[FF,GG,HH,II] S_DATA=[[7,12,17,22],[5,9,14,20],[4,11,16,23],[6,10,15,21]] buf=[0x67452301,0xefcdab89,0x98badcfe,0x10325476] in_data=&#39;&#39;.join(&quot;%.2x&quot; %ord(i) for i in in_str) FF,GG,HH,II就是用到的几个非线性函数， S11-S44是移位常数，in_data是64步中每步用到的常数 还有初始值buf 整个过程就是不停的处理这个BUF 对输入填充部分因为代码写的比较简陋，功能过于局限，所以就不贴出来了 核心算法部分 for i in range(4): for j in range(16): inbufn=(i==0)*j+(i==1)*(1+5*j)%16+(i==2)*(5+3*j)%16+(i==3)*(7*j)%16 temp_buf[-j%4]=FUNC[i](temp_buf[-j%4],temp_buf[(1-j)%4],temp_buf[(2-j)%4],temp_buf[(3-j)%4],in_buf[inbufn],S_DATA[i][j%4],T_DATA[i*16+j]) print hex(temp_buf[0]),hex(temp_buf[1]),hex(temp_buf[2]),hex(temp_buf[3])需要注意的就是inbuf的序号inbufn跟轮数的关系 测试一下 对&quot;a&quot;进行hash Input string is a Hex format: 0x61 pad length is 55 After padding in_data:6180000000000000000000000000000000000000000000000000000000 0000000000000000000000000000000000000000000000000000000800000000000000 in_buf is : 00008061000000000000000000000000000000000000000000000000000000000000 000000000000000000000000000000000000000000000000000800000000 T_DATA= 0xd76aa478L 0xe8c7b756L 0x242070db 0xc1bdceeeL 0xf57c0fafL 0x4787c62a 0xa8304613L 0xfd469501L 0x698098d8 0x8b44f7afL 0xffff5bb1L 0x895cd7beL 0x6b901122 0xfd987193L 0xa679438eL 0x49b40821 0xf61e2562L 0xc040b340L 0x265e5a51 0xe9b6c7aaL 0xd62f105dL 0x2441453 0xd8a1e681L 0xe7d3fbc8L 0x21e1cde6 0xc33707d6L 0xf4d50d87L 0x455a14ed 0xa9e3e905L 0xfcefa3f8L 0x676f02d9 0x8d2a4c8aL 0xfffa3942L 0x8771f681L 0x6d9d6122 0xfde5380cL 0xa4beea44L 0x4bdecfa9 0xf6bb4b60L 0xbebfbc70L 0x289b7ec6 0xeaa127faL 0xd4ef3085L 0x4881d05 0xd9d4d039L 0xe6db99e5L 0x1fa27cf8 0xc4ac5665L 0xf4292244L 0x432aff97 0xab9423a7L 0xfc93a039L 0x655b59c3 0x8f0ccc92L 0xffeff47dL 0x85845dd1L 0x6fa87e4f 0xfe2ce6e0L 0xa3014314L 0x4e0811a1 0xf7537e82L 0xbd3af235L 0x2ad7d2bb 0xeb86d391L a b c d =========Round 1============== 0xa56017f4L 0xefcdab89L 0x98badcfeL 0x10325476 0xa56017f4L 0xefcdab89L 0x98badcfeL 0xf2d58361L 0xa56017f4L 0xefcdab89L 0xe65857a7L 0xf2d58361L 0xa56017f4L 0x607d9686L 0xe65857a7L 0xf2d58361L 0x3a9d5bccL 0x607d9686L 0xe65857a7L 0xf2d58361L 0x3a9d5bccL 0x607d9686L 0xe65857a7L 0xe0a07db7L 0x3a9d5bccL 0x607d9686L 0xd31ddc83L 0xe0a07db7L 0x3a9d5bccL 0xa8af6da5L 0xd31ddc83L 0xe0a07db7L 0xbe580957L 0xa8af6da5L 0xd31ddc83L 0xe0a07db7L 0xbe580957L 0xa8af6da5L 0xd31ddc83L 0xf386bea6L 0xbe580957L 0xa8af6da5L 0xf5fdd933L 0xf386bea6L 0xbe580957L 0x68493d6aL 0xf5fdd933L 0xf386bea6L 0x44244cf8L 0x68493d6aL 0xf5fdd933L 0xf386bea6L 0x44244cf8L 0x68493d6aL 0xf5fdd933L 0xd0fe9b27L 0x44244cf8L 0x68493d6aL 0x6360a45fL 0xd0fe9b27L 0x44244cf8L 0xf01e3ce2L 0x6360a45fL 0xd0fe9b27L =========Round 2============== 0x9c341767L 0xf01e3ce2L 0x6360a45fL 0xd0fe9b27L 0x9c341767L 0xf01e3ce2L 0x6360a45fL 0x970ab3a9L 0x9c341767L 0xf01e3ce2L 0xe39ffd23L 0x970ab3a9L 0x9c341767L 0x8d25cc66L 0xe39ffd23L 0x970ab3a9L 0x8c444930L 0x8d25cc66L 0xe39ffd23L 0x970ab3a9L 0x8c444930L 0x8d25cc66L 0xe39ffd23L 0x7267097aL 0x8c444930L 0x8d25cc66L 0x2dacb8a3L 0x7267097aL 0x8c444930L 0x373beab0L 0x2dacb8a3L 0x7267097aL 0xf175e3adL 0x373beab0L 0x2dacb8a3L 0x7267097aL 0xf175e3adL 0x373beab0L 0x2dacb8a3L 0x9d5df67eL 0xf175e3adL 0x373beab0L 0x87b7f475L 0x9d5df67eL 0xf175e3adL 0xc8f891b4L 0x87b7f475L 0x9d5df67eL 0x93842e98L 0xc8f891b4L 0x87b7f475L 0x9d5df67eL 0x93842e98L 0xc8f891b4L 0x87b7f475L 0xc7043b64L 0x93842e98L 0xc8f891b4L 0x94a2ebeeL 0xc7043b64L 0x93842e98L 0x3745961fL 0x94a2ebeeL 0xc7043b64L =========Round 3============== 0xbd607d1eL 0x3745961fL 0x94a2ebeeL 0xc7043b64L 0xbd607d1eL 0x3745961fL 0x94a2ebeeL 0xa6f72085L 0xbd607d1eL 0x3745961fL 0xbf8b4f98L 0xa6f72085L 0xbd607d1eL 0xdaf7f308L 0xbf8b4f98L 0xa6f72085L 0x35a82a7aL 0xdaf7f308L 0xbf8b4f98L 0xa6f72085L 0x35a82a7aL 0xdaf7f308L 0xbf8b4f98L 0x89e0ec97L 0x35a82a7aL 0xdaf7f308L 0x5abe099cL 0x89e0ec97L 0x35a82a7aL 0xcf7e60dbL 0x5abe099cL 0x89e0ec97L 0x75c151e2L 0xcf7e60dbL 0x5abe099cL 0x89e0ec97L 0x75c151e2L 0xcf7e60dbL 0x5abe099cL 0x942e0c86L 0x75c151e2L 0xcf7e60dbL 0xc0e6ac4L 0x942e0c86L 0x75c151e2L 0xcc6f5e9eL 0xc0e6ac4L 0x942e0c86L 0xac50e18L 0xcc6f5e9eL 0xc0e6ac4L 0x942e0c86L 0xac50e18L 0xcc6f5e9eL 0xc0e6ac4L 0x79ca7845L 0xac50e18L 0xcc6f5e9eL 0x8a4a6356L 0x79ca7845L 0xac50e18L 0x918f93bbL 0x8a4a6356L 0x79ca7845L =========Round 4============== 0xcab8fe42L 0x918f93bbL 0x8a4a6356L 0x79ca7845L 0xcab8fe42L 0x918f93bbL 0x8a4a6356L 0x6a4daeeeL 0xcab8fe42L 0x918f93bbL 0x36269c3fL 0x6a4daeeeL 0xcab8fe42L 0x1ee405ebL 0x36269c3fL 0x6a4daeeeL 0x982c7861L 0x1ee405ebL 0x36269c3fL 0x6a4daeeeL 0x982c7861L 0x1ee405ebL 0x36269c3fL 0x6812a362L 0x982c7861L 0x1ee405ebL 0x71fc7709L 0x6812a362L 0x982c7861L 0x893501c0L 0x71fc7709L 0x6812a362L 0xfebd62fdL 0x893501c0L 0x71fc7709L 0x6812a362L 0xfebd62fdL 0x893501c0L 0x71fc7709L 0x28936a74L 0xfebd62fdL 0x893501c0L 0x53e33526L 0x28936a74L 0xfebd62fdL 0xaa4d8ae3L 0x53e33526L 0x28936a74L 0x52309e0bL 0xaa4d8ae3L 0x53e33526L 0x28936a74L 0x52309e0bL 0xaa4d8ae3L 0x53e33526L 0x50f422f3L 0x52309e0bL 0xaa4d8ae3L 0x49dee633L 0x50f422f3L 0x52309e0bL 0xb8e94637L 0x49dee633L 0x50f422f3L =========Result is :0cc175b9c0f1b6a831c399e269772661============ &nbsp;0cc175b9c0f1b6a831c399e269772661结果正确 这样，接下来写Verilog代码可以有个流程参考了 另附verilog的综合结果 阅读更多","@type":"BlogPosting","url":"/2013/11/23/7c70119f905f489a127c26ec21b5783d.html","headline":"MD5 Hash算法全流程及PYTHON的实现","dateModified":"2013-11-23T00:00:00+08:00","datePublished":"2013-11-23T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2013/11/23/7c70119f905f489a127c26ec21b5783d.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>MD5 Hash算法全流程及PYTHON的实现</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p>大作业准备做 MD5 的硬件实现 但仅凭网上的资料自己再写出一个MD5程序还是颇费时间的</p> 
  <p>转载请注明http://blog.csdn.net/boksic 如有疑问欢迎留言<br></p> 
  <p>MD5的整个流程描述可以参照&nbsp;RFC1321，在此仅列出HASH算法（在此之前还要做位填充）的伪代码</p> 
  <p></p> 
  <pre><code class="language-plain">   /* Process each 16-word block. */
   For i = 0 to N/16-1 do

     /* Copy block i into X. */
     For j = 0 to 15 do
       Set X[j] to M[i*16+j].
     end /* of loop on j */

     /* Save A as AA, B as BB, C as CC, and D as DD. */
     AA = A
     BB = B
     CC = C
     DD = D

     /* Round 1. */
     /* Let [abcd k s i] denote the operation
          a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */
     /* Do the following 16 operations. */
     [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
     [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
     [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
     [ABCD 12  7  13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]

     /* Round 2. */
     /* Let [abcd k s i] denote the operation
          a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */
     /* Do the following 16 operations. */
     [ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
     [ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
     [ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
     [ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]

     /* Round 3. */
     /* Let [abcd k s t] denote the operation
          a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */
     /* Do the following 16 operations. */
     [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
     [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
     [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
     [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]

     /* Round 4. */
     /* Let [abcd k s t] denote the operation
          a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */
     /* Do the following 16 operations. */
     [ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
     [ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
     [ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
     [ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]

     /* Then perform the following additions. (That is increment each
        of the four registers by the value it had before this block
        was started.) */
     A = A + AA
     B = B + BB
     C = C + CC
     D = D + DD

   end /* of loop on i */

</code></pre>
  <br>
  <p></p> 
  <p>虽然PYTHON中用内置函数一句话就能出结果，但是要理解算法写出代码出来还是要走一遍流程。</p> 
  <p>首先是定义当中涉及到的几个常量与函数</p> 
  <p><br></p> 
  <p></p> 
  <pre><code class="language-python">from math import *
in_str="a"
F = lambda x, y, z: (((x) &amp; (y)) | ((~x) &amp; (z)))
G = lambda x, y, z: (((x) &amp; (z)) | ((y) &amp; (~z)))
H = lambda x, y, z: ((x) ^ (y) ^ (z))
I = lambda x, y, z: ((y) ^ ((x) | (~z))) 
RL = lambda x,n: (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))
FF= lambda a,b,c,d,x,s,ac:func
def FF(a, b, c, d, x, s, ac):
	a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;
	a = RL ((a), (s))&amp;0xffffffff;
	a = (a+b)&amp;0xffffffff
	return a
def GG(a, b, c, d, x, s, ac):
	a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;
	a = RL ((a), (s))&amp;0xffffffff;
	a = (a+b)&amp;0xffffffff
	return a
def HH(a, b, c, d, x, s, ac):
	a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;
	a = RL ((a), (s))&amp;0xffffffff;
	a = (a+b)&amp;0xffffffff
	return a
def II(a, b, c, d, x, s, ac):
	a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;
	a = RL ((a), (s))&amp;0xffffffff;
	a = (a+b)&amp;0xffffffff
	return a	
FUNC=[FF,GG,HH,II]

S_DATA=[[7,12,17,22],[5,9,14,20],[4,11,16,23],[6,10,15,21]]


buf=[0x67452301,0xefcdab89,0x98badcfe,0x10325476]
in_data=''.join("%.2x" %ord(i) for i in in_str)</code></pre>
  <br> FF,GG,HH,II就是用到的几个非线性函数， 
  <p></p> 
  <p>S11-S44是移位常数，in_data是64步中每步用到的常数<br></p> 
  <p>还有初始值buf 整个过程就是不停的处理这个BUF</p> 
  <p>对输入填充部分因为代码写的比较简陋，功能过于局限，所以就不贴出来了</p> 
  <p><br></p> 
  <p>核心算法部分</p> 
  <pre><code class="language-python">for i in range(4):
	for j in range(16):
		inbufn=(i==0)*j+(i==1)*(1+5*j)%16+(i==2)*(5+3*j)%16+(i==3)*(7*j)%16
		temp_buf[-j%4]=FUNC[i](temp_buf[-j%4],temp_buf[(1-j)%4],temp_buf[(2-j)%4],temp_buf[(3-j)%4],in_buf[inbufn],S_DATA[i][j%4],T_DATA[i*16+j])
		print hex(temp_buf[0]),hex(temp_buf[1]),hex(temp_buf[2]),hex(temp_buf[3])</code></pre>需要注意的就是inbuf的序号inbufn跟轮数的关系
  <br>
  <br>
  <p></p> 
  <p>测试一下</p> 
  <p>对"a"进行hash</p> 
  <p></p> 
  <pre><code class="language-python">Input string is a
Hex format: 0x61
pad length is 55
After padding in_data:6180000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000800000000000000
in_buf is : 00008061000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000800000000
T_DATA=
0xd76aa478L 0xe8c7b756L 0x242070db 0xc1bdceeeL 0xf57c0fafL 0x4787c62a 
0xa8304613L 0xfd469501L 0x698098d8 0x8b44f7afL 0xffff5bb1L 0x895cd7beL 
0x6b901122 0xfd987193L 0xa679438eL 0x49b40821 0xf61e2562L 0xc040b340L 
0x265e5a51 0xe9b6c7aaL 0xd62f105dL 0x2441453 0xd8a1e681L 0xe7d3fbc8L 
0x21e1cde6 0xc33707d6L 0xf4d50d87L 0x455a14ed 0xa9e3e905L 0xfcefa3f8L 
0x676f02d9 0x8d2a4c8aL 0xfffa3942L 0x8771f681L 0x6d9d6122 0xfde5380cL 
0xa4beea44L 0x4bdecfa9 0xf6bb4b60L 0xbebfbc70L 0x289b7ec6 0xeaa127faL 
0xd4ef3085L 0x4881d05 0xd9d4d039L 0xe6db99e5L 0x1fa27cf8 0xc4ac5665L 
0xf4292244L 0x432aff97 0xab9423a7L 0xfc93a039L 0x655b59c3 0x8f0ccc92L 
0xffeff47dL 0x85845dd1L 0x6fa87e4f 0xfe2ce6e0L 0xa3014314L 0x4e0811a1 
0xf7537e82L 0xbd3af235L 0x2ad7d2bb 0xeb86d391L
        a       b               c       d
=========Round 1==============
0xa56017f4L 0xefcdab89L 0x98badcfeL 0x10325476
0xa56017f4L 0xefcdab89L 0x98badcfeL 0xf2d58361L
0xa56017f4L 0xefcdab89L 0xe65857a7L 0xf2d58361L
0xa56017f4L 0x607d9686L 0xe65857a7L 0xf2d58361L
0x3a9d5bccL 0x607d9686L 0xe65857a7L 0xf2d58361L
0x3a9d5bccL 0x607d9686L 0xe65857a7L 0xe0a07db7L
0x3a9d5bccL 0x607d9686L 0xd31ddc83L 0xe0a07db7L
0x3a9d5bccL 0xa8af6da5L 0xd31ddc83L 0xe0a07db7L
0xbe580957L 0xa8af6da5L 0xd31ddc83L 0xe0a07db7L
0xbe580957L 0xa8af6da5L 0xd31ddc83L 0xf386bea6L
0xbe580957L 0xa8af6da5L 0xf5fdd933L 0xf386bea6L
0xbe580957L 0x68493d6aL 0xf5fdd933L 0xf386bea6L
0x44244cf8L 0x68493d6aL 0xf5fdd933L 0xf386bea6L
0x44244cf8L 0x68493d6aL 0xf5fdd933L 0xd0fe9b27L
0x44244cf8L 0x68493d6aL 0x6360a45fL 0xd0fe9b27L
0x44244cf8L 0xf01e3ce2L 0x6360a45fL 0xd0fe9b27L
=========Round 2==============
0x9c341767L 0xf01e3ce2L 0x6360a45fL 0xd0fe9b27L
0x9c341767L 0xf01e3ce2L 0x6360a45fL 0x970ab3a9L
0x9c341767L 0xf01e3ce2L 0xe39ffd23L 0x970ab3a9L
0x9c341767L 0x8d25cc66L 0xe39ffd23L 0x970ab3a9L
0x8c444930L 0x8d25cc66L 0xe39ffd23L 0x970ab3a9L
0x8c444930L 0x8d25cc66L 0xe39ffd23L 0x7267097aL
0x8c444930L 0x8d25cc66L 0x2dacb8a3L 0x7267097aL
0x8c444930L 0x373beab0L 0x2dacb8a3L 0x7267097aL
0xf175e3adL 0x373beab0L 0x2dacb8a3L 0x7267097aL
0xf175e3adL 0x373beab0L 0x2dacb8a3L 0x9d5df67eL
0xf175e3adL 0x373beab0L 0x87b7f475L 0x9d5df67eL
0xf175e3adL 0xc8f891b4L 0x87b7f475L 0x9d5df67eL
0x93842e98L 0xc8f891b4L 0x87b7f475L 0x9d5df67eL
0x93842e98L 0xc8f891b4L 0x87b7f475L 0xc7043b64L
0x93842e98L 0xc8f891b4L 0x94a2ebeeL 0xc7043b64L
0x93842e98L 0x3745961fL 0x94a2ebeeL 0xc7043b64L
=========Round 3==============
0xbd607d1eL 0x3745961fL 0x94a2ebeeL 0xc7043b64L
0xbd607d1eL 0x3745961fL 0x94a2ebeeL 0xa6f72085L
0xbd607d1eL 0x3745961fL 0xbf8b4f98L 0xa6f72085L
0xbd607d1eL 0xdaf7f308L 0xbf8b4f98L 0xa6f72085L
0x35a82a7aL 0xdaf7f308L 0xbf8b4f98L 0xa6f72085L
0x35a82a7aL 0xdaf7f308L 0xbf8b4f98L 0x89e0ec97L
0x35a82a7aL 0xdaf7f308L 0x5abe099cL 0x89e0ec97L
0x35a82a7aL 0xcf7e60dbL 0x5abe099cL 0x89e0ec97L
0x75c151e2L 0xcf7e60dbL 0x5abe099cL 0x89e0ec97L
0x75c151e2L 0xcf7e60dbL 0x5abe099cL 0x942e0c86L
0x75c151e2L 0xcf7e60dbL 0xc0e6ac4L 0x942e0c86L
0x75c151e2L 0xcc6f5e9eL 0xc0e6ac4L 0x942e0c86L
0xac50e18L 0xcc6f5e9eL 0xc0e6ac4L 0x942e0c86L
0xac50e18L 0xcc6f5e9eL 0xc0e6ac4L 0x79ca7845L
0xac50e18L 0xcc6f5e9eL 0x8a4a6356L 0x79ca7845L
0xac50e18L 0x918f93bbL 0x8a4a6356L 0x79ca7845L
=========Round 4==============
0xcab8fe42L 0x918f93bbL 0x8a4a6356L 0x79ca7845L
0xcab8fe42L 0x918f93bbL 0x8a4a6356L 0x6a4daeeeL
0xcab8fe42L 0x918f93bbL 0x36269c3fL 0x6a4daeeeL
0xcab8fe42L 0x1ee405ebL 0x36269c3fL 0x6a4daeeeL
0x982c7861L 0x1ee405ebL 0x36269c3fL 0x6a4daeeeL
0x982c7861L 0x1ee405ebL 0x36269c3fL 0x6812a362L
0x982c7861L 0x1ee405ebL 0x71fc7709L 0x6812a362L
0x982c7861L 0x893501c0L 0x71fc7709L 0x6812a362L
0xfebd62fdL 0x893501c0L 0x71fc7709L 0x6812a362L
0xfebd62fdL 0x893501c0L 0x71fc7709L 0x28936a74L
0xfebd62fdL 0x893501c0L 0x53e33526L 0x28936a74L
0xfebd62fdL 0xaa4d8ae3L 0x53e33526L 0x28936a74L
0x52309e0bL 0xaa4d8ae3L 0x53e33526L 0x28936a74L
0x52309e0bL 0xaa4d8ae3L 0x53e33526L 0x50f422f3L
0x52309e0bL 0xaa4d8ae3L 0x49dee633L 0x50f422f3L
0x52309e0bL 0xb8e94637L 0x49dee633L 0x50f422f3L
=========Result is :0cc175b9c0f1b6a831c399e269772661============
</code></pre>&nbsp;0cc175b9c0f1b6a831c399e269772661结果正确
  <br> 这样，接下来写Verilog代码可以有个流程参考了
  <br>
  <p><br></p> 
  <p>另附verilog的综合结果</p> 
  <p><img src="http://hi.csdn.net/attachment/201202/1/0_1328080566K8N5.gif" alt="" style="width:255px;"></p> 
  <p><img src="http://hi.csdn.net/attachment/201202/1/0_1328080577iqzh.gif" alt="" style="width:410px;"><br></p> 
  <p></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/boksic/article/details/7075678,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/boksic/article/details/7075678,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
