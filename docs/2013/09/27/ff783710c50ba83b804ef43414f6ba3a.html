<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>iOS应用内购买（In-App Purchase） | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="iOS应用内购买（In-App Purchase）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&nbsp; &nbsp; &nbsp; &nbsp;现在有很多应用都使用了In-App Purchase，虽然对于很多用户来说，可能并不喜欢甚至讨厌这个模式，以为一点击就要从账户里扣钱。但是，应用内购买对于开发者而言不失为一种好的商业模式,而且人们也将越来越接受这种购买模式。 下面开始介绍一下应用内购买的基本原理和编程方法。 1、基本原理 这里参考了Apple的开发文档In-App Purchase Programming Guide 简要介绍一下整个流程： Pre 0：在iTunesConnect中对于的App创建相应的产品，并在应用信息中加入这些产品。具体步骤之后介绍。 Step 1：应用内根据创建的产品的bundle identifier来获取产品的List。 Step 2：应用请求产品的信息。产品信息为SKProduct对象。 Step 3：App Store返回信息。在实际编程中，Step1，2，3是在一起的。通过创建SKProductsRequest得到SKProductsResponse。SKProducts信息就在SKProductsResponse的对象中，是其Property。 Step 4：在应用中显示产品信息给用户 Step 5：用户点击了一个产品。 Step 6：应用向App Store发出一个购买请求 Payment Request Step 7：App Store处理请求，完成交易，并返回信息到应用。 Step 8: &nbsp;应用获取信息然后根据交易情况将购买的内容解锁给用户使用。 这是In-App Purchase的一个基本的过程描述。在我们实际的编程过程中。对于这个产品列表，我们可能会选择直接提供给用户，而不是通过App Store获取信息。只有当用户点击了某个产品后，我们才开始去获取产品信息并完成购买。另一方面，在购买过程中，我们在应用中应该显示足够的提示信息，因此交易过程中的Notification也很重要。 下面开始StepByStep介绍整个具体的实现过程。这里只是介绍最基本的实现方法，以non-consumable产品为例。 Step 1：创建产品 首先要说明一下为了实现应用内购买，你的AppID就是com.companyname.appname必须是唯一的，不能带*。 在iTunesConnect中Manage My Applications中选择Manage In-App Purchases 有四种产品类型，具体详见开发文档。这里选择non-consumable，就是一次购买终身受用的产品。consumable就是消费类可以不断购买的，这种在游戏中比较常见。 上面是产品的详细信息填写。这里特别注意的是ProductID的填写，其实就是ProductIdentifier，这个和应用的BundleIdentifier类似，必须独一无二，一般的做法是填写成com.companyname.appname.productname，当然从本质上讲可以是任意字符串，只要独一无二就可以了。这个ProductID是之后在程序中获取产品信息的依据。其他方面的信息填写很简单，这里不在费述。 Step 2：在应用版本信息中加入产品 进入到应用页面，点击View Detail，然后在下面可以看到 In-App Purchases，点击Edit然后加入之前创建的Products。 Step 3：创建测试User 为了在开发阶段测试In-App Purchase，Apple为我们提供了Test User功能，通过它，可以在开发时用这个账号免费实现应用内购买。 具体就是在iTunesConnect首页，点击Manage Users 点击Test User进行创建。 Step 4：开始编程。在Xcode中要加入StoreKit.framework，通过它来实现功能 Step 5：一般我们会单独创建一个类来实现应用内购买的功能。由于这个是教程，而不是案例，所以不打算把整个类的编写都搬进来。只是介绍一下重要的东西和流程。 在类中要加入 &lt;SKProductsRequestDelegate,SKPaymentTransactionObserver&gt; 对于SKPaymentTransactionObserver这个东西可以监测交易的整个过程，即使交易时退出应用，交易也可以继续进行，当然要回到应用内的页面才能最后完成交易，显示产品相应内容。类的初始化应加入 [[SKPaymentQueuedefaultQueue]&nbsp;addTransactionObserver:self]; 加入这句代码来实现TransactionObserver的功能，后面有相应的Methods可以加入 paymentQueue：开头 Step 6：下面的介绍不局限在一个类的编写，而是按照购买流程。假设我们已经编写好了一个应用内购买的类，然后我们要实现购买。首先就是Request Products。 _productRequest&nbsp;= [[SKProductsRequestalloc]initWithProductIdentifiers:_productIdentifiers]; _productRequest.delegate&nbsp;=self; [_productRequest&nbsp;start]; 一个完整的请求如上，对于productsIdentifiers，这是一个Set，就是在这里创建一个set加入各个ProductIdentifer &nbsp;NSSet&nbsp;*productIdentifiers = [NSSetsetWithObjects: &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_CAMERA_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_SLOPE_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_DIHEDRAL_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_LINE_PLANE_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nil]; 然后就是request delegate的methods - (void)productsRequest:(SKProductsRequest&nbsp;*)request didReceiveResponse:(SKProductsResponse&nbsp;*)response {&nbsp; &nbsp; &nbsp;NSArray&nbsp;*skProducts = response.products; &nbsp; &nbsp; // process.... } - (void)request:(SKRequest&nbsp;*)request didFailWithError:(NSError&nbsp;*)error { &nbsp; &nbsp;// process.... &nbsp;&nbsp; } 请求成功，就能获取Products，一个NSArray,里面就是SKProduct 对象的产品信息了。产品信息有名称，价格，等等，很容易找到。这些东西只是在显示信息时有用，购买时不需要，只要用SKProduct就行了 Step 7：购买 SKPayment&nbsp;*payment = [SKPaymentpaymentWithProduct:product]; [[SKPaymentQueuedefaultQueue]&nbsp;addPayment:payment]; 代码如上。然后就开始连接App Store了。主要看下面 #pragma mark - SKPaymentTransactionObserver - (void)paymentQueue:(SKPaymentQueue&nbsp;*)queue updatedTransactions:(NSArray&nbsp;*)transactions { &nbsp; &nbsp;for&nbsp;(SKPaymentTransaction&nbsp;*transactionin&nbsp;transactions) { &nbsp; &nbsp; &nbsp; &nbsp;switch&nbsp;(transaction.transactionState) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStatePurchased: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selfcompleteTransaction:transaction]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStateFailed: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selffailedTransaction:transaction]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStateRestored: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selfrestoreTransaction:transaction]; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } } 这里说一下上面的第三种交易状态Restore，恢复。这个是这样的。如果有些人在iPhone上用一个账号购买了一个产品，那么在iPad上又下载了这个应用，还要再重新购买吗？不用了，通过Restore在App Store中检测你这个账号的购买记录，如果有购买记录存在，那就不用再次购买了，直接restoreTransaction。 接下来就是根据购买的状态分别进行处理 - (void) completeTransaction: (SKPaymentTransaction *)transaction { // Your application should implement these two methods. [self recordTransaction:transaction]; [self provideContent:transaction.payment.productIdentifier]; // Remove the transaction from the payment queue. [[SKPaymentQueue defaultQueue] finishTransaction: transaction]; } 一般我们用NSUserDefaults来进行交易的记录就行了。 注意程序中finishTransaction这一行代码，这样TransactionObserver就不再监测这个交易了。 其他状态Restore，failed都是差不多的处理，这些代码在开发文档中有。 当然，对于restore，还有一个Method要注意 - (void)paymentQueue:(SKPaymentQueue&nbsp;*)queue restoreCompletedTransactionsFailedWithError:(NSError&nbsp;*)error 如果restore失败，可以显示相应的信息提示 Step 8：附加 在整个购买过程中，我们一般要给用户一下提示信息，比如等待，比如正在连接，比如交易已完成。要实现这些功能，就应该用notification，在上面的交易环节加入postNotification,然后对notification进行有效处理。本文只讲In-App Purchase，关于notification的编程不做介绍。 基本上，通过上面的环节就能完成整个应用内购买了。当然，从安全性上考虑，Apple在交易完成后会发送验证信息，通过发送验证信息给App Store来判断这笔交易是否出自App Store，从而确认交易的合法性。 关于这方面，Apple 有一个代码包提供了validationController来实现很方便的验证。 阅读更多" />
<meta property="og:description" content="&nbsp; &nbsp; &nbsp; &nbsp;现在有很多应用都使用了In-App Purchase，虽然对于很多用户来说，可能并不喜欢甚至讨厌这个模式，以为一点击就要从账户里扣钱。但是，应用内购买对于开发者而言不失为一种好的商业模式,而且人们也将越来越接受这种购买模式。 下面开始介绍一下应用内购买的基本原理和编程方法。 1、基本原理 这里参考了Apple的开发文档In-App Purchase Programming Guide 简要介绍一下整个流程： Pre 0：在iTunesConnect中对于的App创建相应的产品，并在应用信息中加入这些产品。具体步骤之后介绍。 Step 1：应用内根据创建的产品的bundle identifier来获取产品的List。 Step 2：应用请求产品的信息。产品信息为SKProduct对象。 Step 3：App Store返回信息。在实际编程中，Step1，2，3是在一起的。通过创建SKProductsRequest得到SKProductsResponse。SKProducts信息就在SKProductsResponse的对象中，是其Property。 Step 4：在应用中显示产品信息给用户 Step 5：用户点击了一个产品。 Step 6：应用向App Store发出一个购买请求 Payment Request Step 7：App Store处理请求，完成交易，并返回信息到应用。 Step 8: &nbsp;应用获取信息然后根据交易情况将购买的内容解锁给用户使用。 这是In-App Purchase的一个基本的过程描述。在我们实际的编程过程中。对于这个产品列表，我们可能会选择直接提供给用户，而不是通过App Store获取信息。只有当用户点击了某个产品后，我们才开始去获取产品信息并完成购买。另一方面，在购买过程中，我们在应用中应该显示足够的提示信息，因此交易过程中的Notification也很重要。 下面开始StepByStep介绍整个具体的实现过程。这里只是介绍最基本的实现方法，以non-consumable产品为例。 Step 1：创建产品 首先要说明一下为了实现应用内购买，你的AppID就是com.companyname.appname必须是唯一的，不能带*。 在iTunesConnect中Manage My Applications中选择Manage In-App Purchases 有四种产品类型，具体详见开发文档。这里选择non-consumable，就是一次购买终身受用的产品。consumable就是消费类可以不断购买的，这种在游戏中比较常见。 上面是产品的详细信息填写。这里特别注意的是ProductID的填写，其实就是ProductIdentifier，这个和应用的BundleIdentifier类似，必须独一无二，一般的做法是填写成com.companyname.appname.productname，当然从本质上讲可以是任意字符串，只要独一无二就可以了。这个ProductID是之后在程序中获取产品信息的依据。其他方面的信息填写很简单，这里不在费述。 Step 2：在应用版本信息中加入产品 进入到应用页面，点击View Detail，然后在下面可以看到 In-App Purchases，点击Edit然后加入之前创建的Products。 Step 3：创建测试User 为了在开发阶段测试In-App Purchase，Apple为我们提供了Test User功能，通过它，可以在开发时用这个账号免费实现应用内购买。 具体就是在iTunesConnect首页，点击Manage Users 点击Test User进行创建。 Step 4：开始编程。在Xcode中要加入StoreKit.framework，通过它来实现功能 Step 5：一般我们会单独创建一个类来实现应用内购买的功能。由于这个是教程，而不是案例，所以不打算把整个类的编写都搬进来。只是介绍一下重要的东西和流程。 在类中要加入 &lt;SKProductsRequestDelegate,SKPaymentTransactionObserver&gt; 对于SKPaymentTransactionObserver这个东西可以监测交易的整个过程，即使交易时退出应用，交易也可以继续进行，当然要回到应用内的页面才能最后完成交易，显示产品相应内容。类的初始化应加入 [[SKPaymentQueuedefaultQueue]&nbsp;addTransactionObserver:self]; 加入这句代码来实现TransactionObserver的功能，后面有相应的Methods可以加入 paymentQueue：开头 Step 6：下面的介绍不局限在一个类的编写，而是按照购买流程。假设我们已经编写好了一个应用内购买的类，然后我们要实现购买。首先就是Request Products。 _productRequest&nbsp;= [[SKProductsRequestalloc]initWithProductIdentifiers:_productIdentifiers]; _productRequest.delegate&nbsp;=self; [_productRequest&nbsp;start]; 一个完整的请求如上，对于productsIdentifiers，这是一个Set，就是在这里创建一个set加入各个ProductIdentifer &nbsp;NSSet&nbsp;*productIdentifiers = [NSSetsetWithObjects: &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_CAMERA_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_SLOPE_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_DIHEDRAL_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_LINE_PLANE_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nil]; 然后就是request delegate的methods - (void)productsRequest:(SKProductsRequest&nbsp;*)request didReceiveResponse:(SKProductsResponse&nbsp;*)response {&nbsp; &nbsp; &nbsp;NSArray&nbsp;*skProducts = response.products; &nbsp; &nbsp; // process.... } - (void)request:(SKRequest&nbsp;*)request didFailWithError:(NSError&nbsp;*)error { &nbsp; &nbsp;// process.... &nbsp;&nbsp; } 请求成功，就能获取Products，一个NSArray,里面就是SKProduct 对象的产品信息了。产品信息有名称，价格，等等，很容易找到。这些东西只是在显示信息时有用，购买时不需要，只要用SKProduct就行了 Step 7：购买 SKPayment&nbsp;*payment = [SKPaymentpaymentWithProduct:product]; [[SKPaymentQueuedefaultQueue]&nbsp;addPayment:payment]; 代码如上。然后就开始连接App Store了。主要看下面 #pragma mark - SKPaymentTransactionObserver - (void)paymentQueue:(SKPaymentQueue&nbsp;*)queue updatedTransactions:(NSArray&nbsp;*)transactions { &nbsp; &nbsp;for&nbsp;(SKPaymentTransaction&nbsp;*transactionin&nbsp;transactions) { &nbsp; &nbsp; &nbsp; &nbsp;switch&nbsp;(transaction.transactionState) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStatePurchased: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selfcompleteTransaction:transaction]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStateFailed: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selffailedTransaction:transaction]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStateRestored: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selfrestoreTransaction:transaction]; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } } 这里说一下上面的第三种交易状态Restore，恢复。这个是这样的。如果有些人在iPhone上用一个账号购买了一个产品，那么在iPad上又下载了这个应用，还要再重新购买吗？不用了，通过Restore在App Store中检测你这个账号的购买记录，如果有购买记录存在，那就不用再次购买了，直接restoreTransaction。 接下来就是根据购买的状态分别进行处理 - (void) completeTransaction: (SKPaymentTransaction *)transaction { // Your application should implement these two methods. [self recordTransaction:transaction]; [self provideContent:transaction.payment.productIdentifier]; // Remove the transaction from the payment queue. [[SKPaymentQueue defaultQueue] finishTransaction: transaction]; } 一般我们用NSUserDefaults来进行交易的记录就行了。 注意程序中finishTransaction这一行代码，这样TransactionObserver就不再监测这个交易了。 其他状态Restore，failed都是差不多的处理，这些代码在开发文档中有。 当然，对于restore，还有一个Method要注意 - (void)paymentQueue:(SKPaymentQueue&nbsp;*)queue restoreCompletedTransactionsFailedWithError:(NSError&nbsp;*)error 如果restore失败，可以显示相应的信息提示 Step 8：附加 在整个购买过程中，我们一般要给用户一下提示信息，比如等待，比如正在连接，比如交易已完成。要实现这些功能，就应该用notification，在上面的交易环节加入postNotification,然后对notification进行有效处理。本文只讲In-App Purchase，关于notification的编程不做介绍。 基本上，通过上面的环节就能完成整个应用内购买了。当然，从安全性上考虑，Apple在交易完成后会发送验证信息，通过发送验证信息给App Store来判断这笔交易是否出自App Store，从而确认交易的合法性。 关于这方面，Apple 有一个代码包提供了validationController来实现很方便的验证。 阅读更多" />
<link rel="canonical" href="https://mlh.app/2013/09/27/ff783710c50ba83b804ef43414f6ba3a.html" />
<meta property="og:url" content="https://mlh.app/2013/09/27/ff783710c50ba83b804ef43414f6ba3a.html" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-09-27T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"&nbsp; &nbsp; &nbsp; &nbsp;现在有很多应用都使用了In-App Purchase，虽然对于很多用户来说，可能并不喜欢甚至讨厌这个模式，以为一点击就要从账户里扣钱。但是，应用内购买对于开发者而言不失为一种好的商业模式,而且人们也将越来越接受这种购买模式。 下面开始介绍一下应用内购买的基本原理和编程方法。 1、基本原理 这里参考了Apple的开发文档In-App Purchase Programming Guide 简要介绍一下整个流程： Pre 0：在iTunesConnect中对于的App创建相应的产品，并在应用信息中加入这些产品。具体步骤之后介绍。 Step 1：应用内根据创建的产品的bundle identifier来获取产品的List。 Step 2：应用请求产品的信息。产品信息为SKProduct对象。 Step 3：App Store返回信息。在实际编程中，Step1，2，3是在一起的。通过创建SKProductsRequest得到SKProductsResponse。SKProducts信息就在SKProductsResponse的对象中，是其Property。 Step 4：在应用中显示产品信息给用户 Step 5：用户点击了一个产品。 Step 6：应用向App Store发出一个购买请求 Payment Request Step 7：App Store处理请求，完成交易，并返回信息到应用。 Step 8: &nbsp;应用获取信息然后根据交易情况将购买的内容解锁给用户使用。 这是In-App Purchase的一个基本的过程描述。在我们实际的编程过程中。对于这个产品列表，我们可能会选择直接提供给用户，而不是通过App Store获取信息。只有当用户点击了某个产品后，我们才开始去获取产品信息并完成购买。另一方面，在购买过程中，我们在应用中应该显示足够的提示信息，因此交易过程中的Notification也很重要。 下面开始StepByStep介绍整个具体的实现过程。这里只是介绍最基本的实现方法，以non-consumable产品为例。 Step 1：创建产品 首先要说明一下为了实现应用内购买，你的AppID就是com.companyname.appname必须是唯一的，不能带*。 在iTunesConnect中Manage My Applications中选择Manage In-App Purchases 有四种产品类型，具体详见开发文档。这里选择non-consumable，就是一次购买终身受用的产品。consumable就是消费类可以不断购买的，这种在游戏中比较常见。 上面是产品的详细信息填写。这里特别注意的是ProductID的填写，其实就是ProductIdentifier，这个和应用的BundleIdentifier类似，必须独一无二，一般的做法是填写成com.companyname.appname.productname，当然从本质上讲可以是任意字符串，只要独一无二就可以了。这个ProductID是之后在程序中获取产品信息的依据。其他方面的信息填写很简单，这里不在费述。 Step 2：在应用版本信息中加入产品 进入到应用页面，点击View Detail，然后在下面可以看到 In-App Purchases，点击Edit然后加入之前创建的Products。 Step 3：创建测试User 为了在开发阶段测试In-App Purchase，Apple为我们提供了Test User功能，通过它，可以在开发时用这个账号免费实现应用内购买。 具体就是在iTunesConnect首页，点击Manage Users 点击Test User进行创建。 Step 4：开始编程。在Xcode中要加入StoreKit.framework，通过它来实现功能 Step 5：一般我们会单独创建一个类来实现应用内购买的功能。由于这个是教程，而不是案例，所以不打算把整个类的编写都搬进来。只是介绍一下重要的东西和流程。 在类中要加入 &lt;SKProductsRequestDelegate,SKPaymentTransactionObserver&gt; 对于SKPaymentTransactionObserver这个东西可以监测交易的整个过程，即使交易时退出应用，交易也可以继续进行，当然要回到应用内的页面才能最后完成交易，显示产品相应内容。类的初始化应加入 [[SKPaymentQueuedefaultQueue]&nbsp;addTransactionObserver:self]; 加入这句代码来实现TransactionObserver的功能，后面有相应的Methods可以加入 paymentQueue：开头 Step 6：下面的介绍不局限在一个类的编写，而是按照购买流程。假设我们已经编写好了一个应用内购买的类，然后我们要实现购买。首先就是Request Products。 _productRequest&nbsp;= [[SKProductsRequestalloc]initWithProductIdentifiers:_productIdentifiers]; _productRequest.delegate&nbsp;=self; [_productRequest&nbsp;start]; 一个完整的请求如上，对于productsIdentifiers，这是一个Set，就是在这里创建一个set加入各个ProductIdentifer &nbsp;NSSet&nbsp;*productIdentifiers = [NSSetsetWithObjects: &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_CAMERA_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_SLOPE_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_DIHEDRAL_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;K_LINE_PLANE_ANGLE_MODE, &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nil]; 然后就是request delegate的methods - (void)productsRequest:(SKProductsRequest&nbsp;*)request didReceiveResponse:(SKProductsResponse&nbsp;*)response {&nbsp; &nbsp; &nbsp;NSArray&nbsp;*skProducts = response.products; &nbsp; &nbsp; // process.... } - (void)request:(SKRequest&nbsp;*)request didFailWithError:(NSError&nbsp;*)error { &nbsp; &nbsp;// process.... &nbsp;&nbsp; } 请求成功，就能获取Products，一个NSArray,里面就是SKProduct 对象的产品信息了。产品信息有名称，价格，等等，很容易找到。这些东西只是在显示信息时有用，购买时不需要，只要用SKProduct就行了 Step 7：购买 SKPayment&nbsp;*payment = [SKPaymentpaymentWithProduct:product]; [[SKPaymentQueuedefaultQueue]&nbsp;addPayment:payment]; 代码如上。然后就开始连接App Store了。主要看下面 #pragma mark - SKPaymentTransactionObserver - (void)paymentQueue:(SKPaymentQueue&nbsp;*)queue updatedTransactions:(NSArray&nbsp;*)transactions { &nbsp; &nbsp;for&nbsp;(SKPaymentTransaction&nbsp;*transactionin&nbsp;transactions) { &nbsp; &nbsp; &nbsp; &nbsp;switch&nbsp;(transaction.transactionState) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStatePurchased: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selfcompleteTransaction:transaction]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStateFailed: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selffailedTransaction:transaction]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;caseSKPaymentTransactionStateRestored: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [selfrestoreTransaction:transaction]; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;default: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break; &nbsp; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp; } } 这里说一下上面的第三种交易状态Restore，恢复。这个是这样的。如果有些人在iPhone上用一个账号购买了一个产品，那么在iPad上又下载了这个应用，还要再重新购买吗？不用了，通过Restore在App Store中检测你这个账号的购买记录，如果有购买记录存在，那就不用再次购买了，直接restoreTransaction。 接下来就是根据购买的状态分别进行处理 - (void) completeTransaction: (SKPaymentTransaction *)transaction { // Your application should implement these two methods. [self recordTransaction:transaction]; [self provideContent:transaction.payment.productIdentifier]; // Remove the transaction from the payment queue. [[SKPaymentQueue defaultQueue] finishTransaction: transaction]; } 一般我们用NSUserDefaults来进行交易的记录就行了。 注意程序中finishTransaction这一行代码，这样TransactionObserver就不再监测这个交易了。 其他状态Restore，failed都是差不多的处理，这些代码在开发文档中有。 当然，对于restore，还有一个Method要注意 - (void)paymentQueue:(SKPaymentQueue&nbsp;*)queue restoreCompletedTransactionsFailedWithError:(NSError&nbsp;*)error 如果restore失败，可以显示相应的信息提示 Step 8：附加 在整个购买过程中，我们一般要给用户一下提示信息，比如等待，比如正在连接，比如交易已完成。要实现这些功能，就应该用notification，在上面的交易环节加入postNotification,然后对notification进行有效处理。本文只讲In-App Purchase，关于notification的编程不做介绍。 基本上，通过上面的环节就能完成整个应用内购买了。当然，从安全性上考虑，Apple在交易完成后会发送验证信息，通过发送验证信息给App Store来判断这笔交易是否出自App Store，从而确认交易的合法性。 关于这方面，Apple 有一个代码包提供了validationController来实现很方便的验证。 阅读更多","@type":"BlogPosting","url":"https://mlh.app/2013/09/27/ff783710c50ba83b804ef43414f6ba3a.html","headline":"iOS应用内购买（In-App Purchase）","dateModified":"2013-09-27T00:00:00+08:00","datePublished":"2013-09-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mlh.app/2013/09/27/ff783710c50ba83b804ef43414f6ba3a.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-3');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>iOS应用内购买（In-App Purchase）</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp;现在有很多应用都使用了In-App Purchase，虽然对于很多用户来说，可能并不喜欢甚至讨厌这个模式，以为一点击就要从账户里扣钱。但是，应用内购买对于开发者而言不失为一种好的商业模式,而且人们也将越来越接受这种购买模式。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;"><span></span>下面开始介绍一下应用内购买的基本原理和编程方法。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">1、基本原理</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">这里参考了Apple的开发文档In-App Purchase Programming Guide</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;"><img src="http://img.my.csdn.net/uploads/201303/16/1363401648_4045.jpg" alt="" style="border:none;"><br></span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">简要介绍一下整个流程：</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Pre 0：在iTunesConnect中对于的App创建相应的产品，并在应用信息中加入这些产品。具体步骤之后介绍。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 1：应用内根据创建的产品的bundle identifier来获取产品的List。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 2：应用请求产品的信息。产品信息为SKProduct对象。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 3：App Store返回信息。在实际编程中，Step1，2，3是在一起的。通过创建SKProductsRequest得到SKProductsResponse。SKProducts信息就在SKProductsResponse的对象中，是其Property。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 4：在应用中显示产品信息给用户</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 5：用户点击了一个产品。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 6：应用向App Store发出一个购买请求 Payment Request</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 7：App Store处理请求，完成交易，并返回信息到应用。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 8: &nbsp;应用获取信息然后根据交易情况将购买的内容解锁给用户使用。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;"><br></span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">这是In-App Purchase的一个基本的过程描述。在我们实际的编程过程中。对于这个产品列表，我们可能会选择直接提供给用户，而不是通过App Store获取信息。只有当用户点击了某个产品后，我们才开始去获取产品信息并完成购买。另一方面，在购买过程中，我们在应用中应该显示足够的提示信息，因此交易过程中的Notification也很重要。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;"><br></span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">下面开始StepByStep介绍整个具体的实现过程。这里只是介绍最基本的实现方法，以non-consumable产品为例。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 1：创建产品</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">首先要说明一下为了实现应用内购买，你的AppID就是com.companyname.appname必须是唯一的，不能带*。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">在iTunesConnect中Manage My Applications中选择Manage In-App Purchases</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;"><img src="http://img.my.csdn.net/uploads/201303/16/1363402909_7297.jpg" alt="" style="border:none;"><br></span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;"><img src="http://img.my.csdn.net/uploads/201303/16/1363403721_7772.jpg" alt="" style="border:none;"><br></span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">有四种产品类型，具体详见开发文档。这里选择non-consumable，就是一次购买终身受用的产品。consumable就是消费类可以不断购买的，这种在游戏中比较常见。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;"><img src="http://img.my.csdn.net/uploads/201303/16/1363403837_9660.jpg" alt="" style="border:none;"><br></span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">上面是产品的详细信息填写。这里特别注意的是ProductID的填写，其实就是ProductIdentifier，这个和应用的BundleIdentifier类似，必须独一无二，一般的做法是填写成com.companyname.appname.productname，当然从本质上讲可以是任意字符串，只要独一无二就可以了。这个ProductID是之后在程序中获取产品信息的依据。其他方面的信息填写很简单，这里不在费述。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 2：在应用版本信息中加入产品</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">进入到应用页面，点击View Detail，然后在下面可以看到<img src="http://img.my.csdn.net/uploads/201303/16/1363404618_8808.jpg" alt="" style="border:none;"></span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">In-App Purchases，点击Edit然后加入之前创建的Products。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 3：创建测试User</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">为了在开发阶段测试In-App Purchase，Apple为我们提供了Test User功能，通过它，可以在开发时用这个账号免费实现应用内购买。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">具体就是在iTunesConnect首页，点击Manage Users<img src="http://img.my.csdn.net/uploads/201303/16/1363404809_3163.jpg" alt="" style="border:none;"></span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">点击Test User进行创建。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 4：开始编程。在Xcode中要加入StoreKit.framework，通过它来实现功能</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">Step 5：一般我们会单独创建一个类来实现应用内购买的功能。由于这个是教程，而不是案例，所以不打算把整个类的编写都搬进来。只是介绍一下重要的东西和流程。</span></p> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> <span style="font-size:14px;">在类中要加入</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);">&lt;</span>SKProductsRequestDelegate<span style="color:rgb(0,0,0);">,</span>SKPaymentTransactionObserver<span style="color:rgb(0,0,0);">&gt;</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="color:rgb(0,0,0);"><span style="font-size:14px;">对于SKPaymentTransactionObserver这个东西可以监测交易的整个过程，即使交易时退出应用，交易也可以继续进行，当然要回到应用内的页面才能最后完成交易，显示产品相应内容。类的初始化应加入</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);"></span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(73,0,133);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);">[[</span><span style="color:rgb(126,26,173);">SKPaymentQueue</span><span style="color:rgb(0,0,0);"></span>defaultQueue<span style="color:rgb(0,0,0);">]&nbsp;</span>addTransactionObserver<span style="color:rgb(0,0,0);">:</span><span style="color:rgb(150,0,100);">self</span><span style="color:rgb(0,0,0);">];</span></span></p> 
  <span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;text-align:left;">加入这句代码来实现TransactionObserver的功能，后面有相应的Methods可以加入</span><span style="font-family:Arial;line-height:26px;text-align:left;"></span></span> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="color:rgb(0,0,0);"><span style="font-size:14px;">paymentQueue：开头</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="color:rgb(0,0,0);"><span style="font-size:14px;">Step 6：下面的介绍不局限在一个类的编写，而是按照购买流程。假设我们已经编写好了一个应用内购买的类，然后我们要实现购买。首先就是Request Products。</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);"></span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(66,130,136);"> </p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(66,130,136);"> <span style="font-size:14px;">_productRequest<span style="color:rgb(0,0,0);">&nbsp;= [[</span><span style="color:rgb(126,26,173);">SKProductsRequest</span><span style="color:rgb(0,0,0);"></span><span style="color:rgb(73,0,133);">alloc</span><span style="color:rgb(0,0,0);">]</span><span style="color:rgb(73,0,133);">initWithProductIdentifiers</span><span style="color:rgb(0,0,0);">:</span>_productIdentifiers<span style="color:rgb(0,0,0);">];</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(66,130,136);"> <span style="font-size:14px;">_productRequest<span style="color:rgb(0,0,0);">.</span><span style="color:rgb(126,26,173);">delegate</span><span style="color:rgb(0,0,0);">&nbsp;=</span><span style="color:rgb(150,0,100);">self</span><span style="color:rgb(0,0,0);">;</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(66,130,136);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);">[</span>_productRequest<span style="color:rgb(0,0,0);">&nbsp;</span><span style="color:rgb(73,0,133);">start</span><span style="color:rgb(0,0,0);">];</span></span></p> 
  <span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;text-align:left;"><br> 一个完整的请求如上，对于productsIdentifiers，这是一个Set，就是在这里创建一个set加入各个ProductIdentifer</span><span style="font-family:Arial;line-height:26px;text-align:left;"></span></span> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);"></span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp;<span style="color:rgb(126,26,173);">NSSet</span>&nbsp;*productIdentifiers = [<span style="color:rgb(126,26,173);">NSSet</span><span style="color:rgb(73,0,133);">setWithObjects</span>:</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(126,71,38);">K_CAMERA_ANGLE_MODE</span>,</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(126,71,38);">K_SLOPE_ANGLE_MODE</span>,</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(126,71,38);">K_DIHEDRAL_ANGLE_MODE</span>,</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(126,71,38);">K_LINE_PLANE_ANGLE_MODE</span>,</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(150,0,100);">nil</span>];</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">然后就是request delegate的methods</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> </p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">- (<span style="color:rgb(150,0,100);">void</span>)productsRequest:(<span style="color:rgb(126,26,173);">SKProductsRequest</span>&nbsp;*)request didReceiveResponse:(<span style="color:rgb(126,26,173);">SKProductsResponse</span>&nbsp;*)response</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">{&nbsp;</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp;<span style="color:rgb(126,26,173);">NSArray</span>&nbsp;*skProducts = response.<span style="color:rgb(126,26,173);">products</span>;</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; // process....</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">}</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;min-height:21px;"> <span style="font-size:14px;"><br></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">- (<span style="color:rgb(150,0,100);">void</span>)request:(<span style="color:rgb(126,26,173);">SKRequest</span>&nbsp;*)request didFailWithError:(<span style="color:rgb(126,26,173);">NSError</span>&nbsp;*)error</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">{</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(168,0,17);"> <span style="color:rgb(0,0,0);"><span style="font-size:14px;">&nbsp; &nbsp;// process.... &nbsp;&nbsp;</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">}</span></p> 
  <span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;text-align:left;"><br></span><span style="font-family:Arial;line-height:26px;text-align:left;"></span></span> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">请求成功，就能获取Products，一个NSArray,里面就是SKProduct 对象的产品信息了。产品信息有名称，价格，等等，很容易找到。这些东西只是在显示信息时有用，购买时不需要，只要用SKProduct就行了</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">Step 7：购买</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> </p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;"><span style="color:rgb(126,26,173);">SKPayment</span>&nbsp;*payment = [<span style="color:rgb(126,26,173);">SKPayment</span><span style="color:rgb(73,0,133);">paymentWithProduct</span>:product];</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(73,0,133);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);">[[</span><span style="color:rgb(126,26,173);">SKPaymentQueue</span><span style="color:rgb(0,0,0);"></span>defaultQueue<span style="color:rgb(0,0,0);">]&nbsp;</span>addPayment<span style="color:rgb(0,0,0);">:payment];</span></span></p> 
  <span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;text-align:left;">代码如上。然后就开始连接App Store了。主要看下面</span><span style="font-family:Arial;line-height:26px;text-align:left;"></span></span> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> </p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(130,70,39);"> <span style="font-size:14px;">#pragma mark - SKPaymentTransactionObserver</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">- (<span style="color:rgb(150,0,100);">void</span>)paymentQueue:(<span style="color:rgb(126,26,173);">SKPaymentQueue</span>&nbsp;*)queue updatedTransactions:(<span style="color:rgb(126,26,173);">NSArray</span>&nbsp;*)transactions</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">{</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp;<span style="color:rgb(150,0,100);">for</span>&nbsp;(<span style="color:rgb(126,26,173);">SKPaymentTransaction</span>&nbsp;*transaction<span style="color:rgb(150,0,100);">in</span>&nbsp;transactions) {</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(150,0,100);">switch</span>&nbsp;(transaction.<span style="color:rgb(126,26,173);">transactionState</span>) {</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(73,0,133);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style="color:rgb(150,0,100);">case</span><span style="color:rgb(0,0,0);"></span>SKPaymentTransactionStatePurchased<span style="color:rgb(0,0,0);">:</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<span style="color:rgb(150,0,100);">self</span><span style="color:rgb(38,90,94);">completeTransaction</span>:transaction];</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(150,0,100);">break</span>;</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(73,0,133);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style="color:rgb(150,0,100);">case</span><span style="color:rgb(0,0,0);"></span>SKPaymentTransactionStateFailed<span style="color:rgb(0,0,0);">:</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<span style="color:rgb(150,0,100);">self</span><span style="color:rgb(38,90,94);">failedTransaction</span>:transaction];</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(150,0,100);">break</span>;</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(73,0,133);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style="color:rgb(150,0,100);">case</span><span style="color:rgb(0,0,0);"></span>SKPaymentTransactionStateRestored<span style="color:rgb(0,0,0);">:</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [<span style="color:rgb(150,0,100);">self</span><span style="color:rgb(38,90,94);">restoreTransaction</span>:transaction];</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;min-height:21px;"> <span style="font-size:14px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(150,0,100);">default</span>:</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color:rgb(150,0,100);">break</span>;</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">&nbsp; &nbsp; }</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">}</span></p> 
  <span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;text-align:left;"><br> 这里说一下上面的第三种交易状态Restore，恢复。这个是这样的。如果有些人在iPhone上用一个账号购买了一个产品，那么在iPad上又下载了这个应用，还要再重新购买吗？不用了，通过Restore在App Store中检测你这个账号的购买记录，如果有购买记录存在，那就不用再次购买了，直接restoreTransaction。</span><span style="font-family:Arial;line-height:26px;text-align:left;"></span></span> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="color:rgb(0,0,0);"><span style="font-size:14px;"><br></span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="color:rgb(0,0,0);"><span style="font-size:14px;">接下来就是根据购买的状态分别进行处理</span></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;color:rgb(126,26,173);"> <span style="font-size:14px;"><span style="color:rgb(0,0,0);"></span></span></p> 
  <div class="column" style="font-family:Arial;line-height:26px;text-align:left;"> 
   <pre><span style="font-family:Menlo;"><span style="font-size:14px;">- (void) completeTransaction: (SKPaymentTransaction *)transaction { </span></span></pre> 
   <pre><span style="font-family:Menlo;"><span style="font-size:14px;"> // Your application should implement these two methods. [self recordTransaction:transaction]; [self provideContent:transaction.payment.productIdentifier]; </span></span></pre> 
   <pre><span style="font-family:Menlo;"><span style="font-size:14px;"> // Remove the transaction from the payment queue. </span></span></pre> 
   <pre><span style="font-family:Menlo;"><span style="font-size:14px;"> [[SKPaymentQueue defaultQueue] finishTransaction: transaction]; } </span></span></pre> 
  </div> 
  <span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;text-align:left;">一般我们用NSUserDefaults来进行交易的记录就行了。</span><span style="font-family:Arial;line-height:26px;text-align:left;"></span></span> 
  <p style="font-family:Arial;line-height:26px;text-align:left;"> </p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">注意程序中finishTransaction这一行代码，这样TransactionObserver就不再监测这个交易了。</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">其他状态Restore，failed都是差不多的处理，这些代码在开发文档中有。</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;"><br></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">当然，对于restore，还有一个Method要注意</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> </p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">- (<span style="color:rgb(150,0,100);">void</span>)paymentQueue:(<span style="color:rgb(126,26,173);">SKPaymentQueue</span>&nbsp;*)queue restoreCompletedTransactionsFailedWithError:(<span style="color:rgb(126,26,173);">NSError</span>&nbsp;*)error</span></p> 
  <span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;text-align:left;">如果restore失败，可以显示相应的信息提示</span><span style="font-family:Arial;line-height:26px;text-align:left;"></span></span> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;"><br></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">Step 8：附加</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">在整个购买过程中，我们一般要给用户一下提示信息，比如等待，比如正在连接，比如交易已完成。要实现这些功能，就应该用notification，在上面的交易环节加入postNotification,然后对notification进行有效处理。本文只讲In-App Purchase，关于notification的编程不做介绍。</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;"><br></span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">基本上，通过上面的环节就能完成整个应用内购买了。当然，从安全性上考虑，Apple在交易完成后会发送验证信息，通过发送验证信息给App Store来判断这笔交易是否出自App Store，从而确认交易的合法性。</span></p> 
  <p style="line-height:26px;text-align:left;font-family:Menlo;"> <span style="font-size:14px;">关于这方面，Apple 有一个代码包提供了validationController来实现很方便的验证。</span></p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yrx1004/article/details/12089335,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/yrx1004/article/details/12089335,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d1dbe5a3e5863242418b768d1601633";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
