<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>使用openssl命令剖析RSA私钥文件格式 | 有组织在！</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="使用openssl命令剖析RSA私钥文件格式" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Openssl提供了强大证书功能，生成密钥对、证书，颁发证书、生成crl、验证证书、销毁证书等。本文将j介绍如何利用openssl的命令分析RSA私钥文件格式，同时也将简单介绍几种常见的私钥文件格式。 &nbsp; 1 生成私钥文件 openssl有多种方法生成私钥： genrsa生成RSA密钥。 req在生成req证书请求时同时产生密钥。 genpkey除了可以生成RSA密钥外，还可以生成DSA、DH密钥。 &nbsp;这里我使用genpkey命令生成RSA私钥文件，选择DES-EDE3-CBC算法进行加密，口令是1234： openssl genpkey -algorithm RSA -out privatekey.pem -pass pass:1234 -des-ede3-cbc 命令执行后输出私钥文件 privatekey.pem，默认输出为 PEM格式，密钥长度为1024，接下来使用文本工具直接打开该文件，可以看到如下内容：&nbsp; -----BEGINENCRYPTED PRIVATE KEY----- MIICxjBABgkqhkiG9w0BBQ0wMzAbBgkqhkiG9w0BBQwwDgQIhrQ3ApYYe1ACAggA MBQGCCqGSIb3DQMHBAgyM5zYLuXOdQSCAoAFqnCRqkpoHJTY0BpLeekzjsuzdTOq DkgxJMi4WRt1rZNyHqarbhHCZGC9Lug/xbLW5e2ZtjYVJ+ljmFb4lUaAch4nAgoz m0J5YyrbFKppiqlk6vkS5hKfpKbWrx5hkQzMt6OsVEQFj2U+EvOI8SVgI6LkjNmh 7qokYxv9Inx9joM6agEUY9fXdAu53CyfjpneX95vxUHIn7hHmhxH7MYua619N7x+ JVA65b3Kj45aH3cnY/kMAQ78EN9aLpqYXzn6j9GRdUd2JMuP0IrYlREw3/z8Qn68 CwGXzGtkYnlt0xHdOG/tnmKWqBg1cY9uVx6g6JT1BUabqwxVODaMqaSsFr4o3xJo 3TTh8TswK0V/+3JLkXtasI7V8cRj2dksccGApujmB5eymU3XXTlX3iXs481I4kmz JOZHbqfGOpyzW6WqhMO+LebIkyIGMlCGRiJ3PNSQI9w6bfZ9FoqC6OfFKY1OEmBN 6ALtPc+cYXeO5Msx9mbakIYRbcjlVmelPsLyvAceW/09OG909turflvYaGnM+SKd KzWn2gFr3YwF57WZlX2jifYUUnjHVMZW7s/k6hgOxcEnvBOg4Ug/cKdNPUEB7tJx nvsR+odHypyjgyphLEP8UmEiz3/hnPV8lhLDAPV7fKaK+zDglKqQYF3KBLh55q6h PPe1HqahifK9EKqWOl7m1HhFPIZTex4clLy98rB3gyXnL0qx4+A7WD6uLJbU285j IWMNq3f1c80ZPrpbhT6hd6Z9zUwfYT6gTO9gIIe4d5KVmfjNaFwSls5zaI6x7AJp d/Xl/m1u469+J0rWyeY3D4wtahvZrKMXRrILtJ5OgkWPak2FTyMu/Hs/ -----ENDENCRYPTED PRIVATE KEY----- 私钥经过PEM编码后在文件头尾都添加了标签，用以说明当前的文件格式。从标签内容也可以看出私钥是加密的，因为有“ ENCRYPTED”。中间的私钥内容是经过BASE64编码的，这样方便私钥的传递，例如在网络上传输，数据复制粘贴。 &nbsp; 例子只是PEM文件格式的其中一种，以下是平时可能会碰到的PEM私钥格式： PKCS#8 私钥加密格式 -----BEGIN ENCRYPTED PRIVATE KEY----- BASE64私钥内容 -----ENDENCRYPTED PRIVATE KEY----- PKCS#8 私钥非加密格式 -----BEGIN PRIVATE KEY----- BASE64私钥内容 -----END PRIVATEKEY----- Openssl ASN格式 -----BEGIN RSA PRIVATE KEY----- Proc-Type: 4,ENCRYPTED DEK-Info:DES-EDE3-CBC,4D5D1AF13367D726 BASE64私钥内容 -----END RSA PRIVATE KEY----- 除了以上几种，还有微软的PVK格式；以及DER编码格式，就是在使用PEM编码前的数据，由于没有密码保护，平时很少直接使用。 &nbsp; Openssl ASN格式在加密私钥数据时只能用MD5算法生成key，而且只迭代计算了1次。 所以从1.0.0开始Openssl把PKCS#8格式作为默认格式，可以为私钥文件提供更好的安全性和扩展性。 我们这里就针对PKCS#8格式的私钥进行讨论。 如果大家想要研究其他格式，可以使用以下命令： &nbsp;genrsa 生成ASN格式 &nbsp;rsa 生成或转换为PVK格式 openssl rsa -in privatekey.pem -out privatekey.pvk -outform PVK&nbsp;&nbsp; 2 分析私钥文件&nbsp; 使用asn1parse命令读取私钥ASN.1结构，其中–i表示输出使用缩进格式。 openssl asn1parse -i -in privatekey.pem&nbsp; 0:d=0 hl=4 l= 710 cons: SEQUENCE 4:d=1 hl=2 l= 64 cons: SEQUENCE 6:d=2 hl=2 l= 9 prim: OBJECT :PBES2 17:d=2 hl=2 l= 51 cons: SEQUENCE 19:d=3 hl=2 l= 27 cons: SEQUENCE 21:d=4 hl=2 l= 9 prim: OBJECT :PBKDF2 32:d=4 hl=2 l= 14 cons: SEQUENCE 34:d=5 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:7A61B055165A89CA 44:d=5 hl=2 l= 2 prim: INTEGER :0800 48:d=3 hl=2 l= 20 cons: SEQUENCE 50:d=4 hl=2 l= 8 prim: OBJECT :des-ede3-cbc 60:d=4 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:110E8A184EFEAB9C 70:d=1 hl=4 l= 640 prim: OCTET STRING [HEX DUMP]: C94F34F0CFF56B3E92D437C49559B1BD632BA2D8B22AF290B0E8EBB7F71C555115CED4DE87E3922A41436A20DA1DB01F1BD88EA3002E8AD4691C0B25F16AF4D196C2A96B99A1D49F704A21D3B81F8CC81C3F09412317B67F453151490D2573E1FD96D13BB55E7FCD4085ED0C4DD75EB1EFFC4ACE5431AFD708E6ECE5077BAB2B03965C6F2873C1DB5F475F861E9C04D61465C72A8A99DCF093190F746DD8959C0B0942E38A013B0FEC2D4A66F600EF75CE0326F3B4904C3128CB389204A1CC4F93EED7C8F2450603A42C6C16FB143FF4C9C01E714A43CC07B1F1B580A6C9DE4DC9B78CA0D5B874C75A0F56F6A55CFE4620F1AC639DCE4A8AF2BCBB69691DAF983BB26F6A6C859C371D1EBA7DA5C27FBDAC86C6529C48B32E3B89317FC7EBF03F9C105EAA1892437E9E789F0E2340979812A53CD1668EC07A45BBEAE088E7E27BB20B16C2D14280970BBF715D57005F194B97A1784E7BC563A0B84909A7EAB6C7E0BC6E2B467AA4009420D190617F93CD32FAEEE50003462DC8B26816040E891523E1375F339A3F05C43C9E90A4533BD4D3F75A2A33E60D91563542355D5ED1F46CF62594460694F459F0EC428BECE015F075895CFEB502EA22ECD9B53BF050B795074BE9A51194789F0B2970C21CCFE16284FB564F720C7899D5840362C48D248A50BAFA2720B0C1F7B417AD6EA183459BBB80679A85D96421C5AE3FA53A2135217F886759187123766914BB0169F6F9C3A36F1C46B6EB9300009A799D0F96C3E1FBE805F17A01FF2F5A9C941399E6130DBEE9825F4EB8937F2B8F0B3DE5F08644F3DC65028F2DE150D03D454AECFF9CAF26A00BB1B6D6D2C5255216E0A6769F14937618E31573811AAA464C3C42246A17DD70B1F77A87948FD5C7526D569BB8 ASN.1结构输出格式说明： 0:d=0 hl=4 l= 710 cons: SEQUENCE 0 表示节点在整个文件中的偏移长度 d=0 表示节点深度 hl=4&nbsp;表示节点头字节长度 l=710&nbsp;表示节点数据字节长度 cons 表示该节点为结构节点，表示包含子节点或者子结构数据 prim 表示该节点为原始节点，包含数据 SEQUENCE、OCTETSTRING等都是ASN.1中定义的数据类型，具体可以参考ASN.1格式说明。 &nbsp;最后一个节点OCTET STRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HEX DUMP]，就是加密后的私钥数据。 为了方便理解，下面给出相关的PKCS定义。 PCKS#8文件格式定义： PrivateKeyInfo ::= SEQUENCE { version Version, privateKeyAlgorithm PrivateKeyAlgorithmIdentifier, privateKey PrivateKey, attributes [0] IMPLICIT Attributes OPTIONAL } privateKey，加密后私钥数据，最后一个OCTET STRING数据块。 privateKeyAlgorithm，使用的私钥算法，详细格式在 PKCS#5&nbsp;2.0中的定义： PBES2-params ::= SEQUENCE { keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}}, encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} } keyDerivationFunc 加密密钥生成函数，现在默认使用的是sha1，还包含了salt，迭代次数iterationCount： PBKDF2-params ::= SEQUENCE { salt CHOICE { specified OCTET STRING, otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}} }, iterationCount INTEGER (1..MAX), keyLength INTEGER (1..MAX) OPTIONAL, prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1 } 对应数据： 19:d=3 hl=2 l= 27 cons: SEQUENCE 21:d=4 hl=2 l= 9 prim: OBJECT :PBKDF2 32:d=4 hl=2 l= 14 cons: SEQUENCE 34:d=5 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:7A61B055165A89CA 44:d=5 hl=2 l= 2 prim: INTEGER :0800 encryptionScheme 加密算法，例子中使用的是des-ede3-cbc，该结构中还包含初始化向量iv。 对应数据： 48:d=3 hl=2 l= 20 cons: SEQUENCE 50:d=4 hl=2 l= 8 prim: OBJECT :des-ede3-cbc 60:d=4 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:110E8A184EFEAB9C 解密流程： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 按PKCS#8和PCKS#5定义从文件中解析出相关参数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密密钥生成函数（KDF）PBKDF2； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密时使用的salt：7A61B055165A89CA，以及迭代次数iter：0x0800（2048次）； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密算法des-ede3-cbc，以及加密初始向量iv：110E8A184EFEAB9C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 解析出加密的私钥数据data，也就是最后一个OCTET STRING； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 生成加密密钥：key = KDF（pass（1234），salt，iter） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 解密 des-ede3-cbc（key， iv， data） &nbsp; 这一解密过程可以使用openssl的pkey命令完成，执行完成后得到privatekey.der文件，这个是没有加密的私钥文件，数据是ASN.1格式，并使用DER编码。 Openssl pkey -in privatekey.pem -out privatekey.der-passin pass:1234 &nbsp;&nbsp; 然后再次分析密钥数据，由于输入是der格式，需要使用inform参数说明： openssl asn1parse -in privatekey.der -inform DER &nbsp; 0:d=0 hl=4 l= 604 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=3 l= 129 prim:INTEGER : A11E66B0F965215AB4AD771581700477F62D9EDF2CFEBDF2E20C02DE4E95881F58CA898B6FC389CC83AE39DE95C0252BCF9FB98A6A21A20B751222DF2A4CBE1E08F8BDC8D443A59D4944723C33CED5601E1CF4A324E88B951626326783014CFF3BB7CF7278BF443AB003D1E1608B97CFC7783C6FD42B9A7C8F84C5633FB72DFB 139:d=1 hl=2 l= 3 prim: INTEGER :010001 144:d=1 hl=3 l= 129 prim:INTEGER : 9B2C9B7CD105AC851EC47E8FB0D541088489D59C5E4A8E88F15ADE1C5B953ABFEE154B39870FCD94B23247BBEF805A8C826FF413B239E8469E9F3404B949A643E1E2CCF9753822FD28345B7898148164DA2D858F672B52C7B3041F0A9F6FFFB97759D3C04AE3ED2E372E4ADD3A44202CE004D189566A81F19239649779F30DE9 276:d=1 hl=2 l= 65 prim: INTEGER : CE25257FDE50AFDAF926BDBEFE5A236C130F2714C5FC0C36A07B5AA5618E8F5039E313387C933A86EBDC2DEF8640069CB98B1D04C3E74B46C75F292A768083D5 343:d=1 hl=2 l= 65 prim: INTEGER : C8159573F6C413EAC0BB721B859A4B7920FF9DE151546CA28FDA3F43A0999C835DB9078AF5054CE503C4BC174ECB1F0C4DE033E116A296FD67B4158F869E628F 410:d=1 hl=2 l= 64 prim: INTEGER : 7329855D7DD10DAD02EB85AD216331CEBA87088A2E60B462001D697262A1C5A647F07758631FCCDE7AFD321C519F8B121B05805C9D24A58510F4348728547B51 476:d=1 hl=2 l= 64 prim: INTEGER : 53735D203EBDCD28CE35E003C69771FF155A47B92038BC0E993D07C1E70BEA9187D79263CC89E7666549FAC125E5E60F35B3DB2F78475BFE58F06D45AD7A05D5 542:d=1 hl=2 l= 64 prim: INTEGER : 4F454C491EAE6CD85ED812D8A26AFD5FD0F6D7DD12AD6D20EDA8C2D257943928B2AE66FDE336F40370D9CC30B85EB2F20D3B4FDAB61D168FE7936CB6AB5E8FE2 &nbsp;得到的数据与上次导出的格式是相同的，虽然看起来数据多，但是层次结构起始要简单，数据就是一个结构体（cons）SEQUENCE，包含9个整型的原始数据（prim）INTERGER，这个就是私钥结构，该 ASN.1结构在PKCS#1中定义如下： RSAPrivateKey ::= SEQUENCE { versionVersion, modulusINTEGER, -- n publicExponentINTEGER, -- e privateExponentINTEGER, -- d prime1INTEGER, -- p prime2INTEGER, -- q exponent1INTEGER, -- d mod (p-1) exponent2INTEGER, -- d mod (q-1) coefficientINTEGER, -- (inverse of q) mod p otherPrimeInfosOtherPrimeInfos OPTIONAL } 最后一个otherPrimeInfos是可选项，例子中没有该数据。 结构中包含了RSA密钥算法中用到的所有信息，每一项的具体定义可以参考PKCS#1。 &nbsp; 3 分析公钥 &nbsp;为了方便获取公钥，在私钥文件数据中起始包含了公钥信息： modulus INTEGER, -- n publicExponent INTEGER, -- e 公钥的ASN.1结构也在PKCS#1中定义： RSAPublicKey ::= SEQUENCE { modulus INTEGER, -- n publicExponentINTEGER -- e } 可以使用openssl命令导出公钥文件pubkey.pem，使用文本工具打开公钥文件，pem头尾格式和私钥类似的标签： openssl pkey -in privatekey.der -inform DER -out pubkey.pem-pubout &nbsp; -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQChHmaw+WUhWrStdxWBcAR39i2e 3yz+vfLiDALeTpWIH1jKiYtvw4nMg6453pXAJSvPn7mKaiGiC3USIt8qTL4eCPi9 yNRDpZ1JRHI8M87VYB4c9KMk6IuVFiYyZ4MBTP87t89yeL9EOrAD0eFgi5fPx3g8 b9QrmnyPhMVjP7ct+wIDAQAB -----END PUBLIC KEY----- 继续分析公钥文件的ASN.1格式： openssl asn1parse -in pubkey.pem -i &nbsp; 0:d=0 hl=3 l= 159 cons: SEQUENCE 3:d=1 hl=2 l= 13 cons: SEQUENCE 5:d=2 hl=2 l= 9 prim: OBJECT :rsaEncryption 16:d=2 hl=2 l= 0 prim: NULL 18:d=1 hl=3 l= 141 prim: BIT STRING 但是这里显示格式和上边给出的PKCS#1格式不一致，其实这是x.509中的定义的格式，在X.509证书文件中就是使用这个格式封装公钥数据，其中BIT STRING的内容就是PKCS#1格式的公钥数据，并说明了使用的公钥算法rsaEncryption。 SubjectPublicKeyInfo ::=SEQUENCE { algorithmAlgorithmIdentifier{{SupportedAlgorithms}}, subjectPublicKeyBIT STRING }&nbsp; 我们可以进一步使用asn1parse工具解析出BIT STRING内容，首先确定该数据块偏移是18，然后使用参数-strparse指定位置,可以看到输出的数据和私钥文件中的是一样的。 asn1parse -in pubkey.pem -strparse 18 &nbsp;输出公钥ASN.1格式： 0:d=0 hl=3 l= 137 cons: SEQUENCE 3:d=1 hl=3 l= 129 prim: INTEGER : A11E66B0F965215AB4AD771581700477F62D9EDF2CFEBDF2E20C02DE4E95881F58CA898B6FC389CC83AE39DE95C0252BCF9FB98A6A21A20B751222DF2A4CBE1E08F8BDC8D443A59D4944723C33CED5601E1CF4A324E88B951626326783014CFF3BB7CF7278BF443AB003D1E1608B97CFC7783C6FD42B9A7C8F84C5633FB72DFB 135:d=1 hl=2 l=3 prim: INTEGER :010001&nbsp; 4 公私钥操作 分析完私钥和公钥格式，以及之间的关系。接下来我们将继续使用openssl的rsautl测试它们之间的加解密、签名、验证等操作。 测试文件test，内容“1234567890”。 &nbsp; 4.1加解密 &nbsp;1）公钥加密 openssl rsautl -encrypt -in test -out test.enc -inkey asn1pub.pem -pubin &nbsp;2）私钥解密 openssl rsautl -decrypt -in test.enc -out test.dec -inkey asn1enc.pem &nbsp; 比较test和test.dec两个文件结果相同。 &nbsp; 4.2签名验证 1）私钥签名 openssl rsautl -sign -in test -out test.sig-inkey asn1enc.pem &nbsp; 2）公钥验证 openssl rsautl -verify -in test.sig -out test.vfy -inkey asn1pub.pem -pubin &nbsp; 比较test和test.vfy连个文件应该相同。 &nbsp; 阅读更多" />
<meta property="og:description" content="&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Openssl提供了强大证书功能，生成密钥对、证书，颁发证书、生成crl、验证证书、销毁证书等。本文将j介绍如何利用openssl的命令分析RSA私钥文件格式，同时也将简单介绍几种常见的私钥文件格式。 &nbsp; 1 生成私钥文件 openssl有多种方法生成私钥： genrsa生成RSA密钥。 req在生成req证书请求时同时产生密钥。 genpkey除了可以生成RSA密钥外，还可以生成DSA、DH密钥。 &nbsp;这里我使用genpkey命令生成RSA私钥文件，选择DES-EDE3-CBC算法进行加密，口令是1234： openssl genpkey -algorithm RSA -out privatekey.pem -pass pass:1234 -des-ede3-cbc 命令执行后输出私钥文件 privatekey.pem，默认输出为 PEM格式，密钥长度为1024，接下来使用文本工具直接打开该文件，可以看到如下内容：&nbsp; -----BEGINENCRYPTED PRIVATE KEY----- MIICxjBABgkqhkiG9w0BBQ0wMzAbBgkqhkiG9w0BBQwwDgQIhrQ3ApYYe1ACAggA MBQGCCqGSIb3DQMHBAgyM5zYLuXOdQSCAoAFqnCRqkpoHJTY0BpLeekzjsuzdTOq DkgxJMi4WRt1rZNyHqarbhHCZGC9Lug/xbLW5e2ZtjYVJ+ljmFb4lUaAch4nAgoz m0J5YyrbFKppiqlk6vkS5hKfpKbWrx5hkQzMt6OsVEQFj2U+EvOI8SVgI6LkjNmh 7qokYxv9Inx9joM6agEUY9fXdAu53CyfjpneX95vxUHIn7hHmhxH7MYua619N7x+ JVA65b3Kj45aH3cnY/kMAQ78EN9aLpqYXzn6j9GRdUd2JMuP0IrYlREw3/z8Qn68 CwGXzGtkYnlt0xHdOG/tnmKWqBg1cY9uVx6g6JT1BUabqwxVODaMqaSsFr4o3xJo 3TTh8TswK0V/+3JLkXtasI7V8cRj2dksccGApujmB5eymU3XXTlX3iXs481I4kmz JOZHbqfGOpyzW6WqhMO+LebIkyIGMlCGRiJ3PNSQI9w6bfZ9FoqC6OfFKY1OEmBN 6ALtPc+cYXeO5Msx9mbakIYRbcjlVmelPsLyvAceW/09OG909turflvYaGnM+SKd KzWn2gFr3YwF57WZlX2jifYUUnjHVMZW7s/k6hgOxcEnvBOg4Ug/cKdNPUEB7tJx nvsR+odHypyjgyphLEP8UmEiz3/hnPV8lhLDAPV7fKaK+zDglKqQYF3KBLh55q6h PPe1HqahifK9EKqWOl7m1HhFPIZTex4clLy98rB3gyXnL0qx4+A7WD6uLJbU285j IWMNq3f1c80ZPrpbhT6hd6Z9zUwfYT6gTO9gIIe4d5KVmfjNaFwSls5zaI6x7AJp d/Xl/m1u469+J0rWyeY3D4wtahvZrKMXRrILtJ5OgkWPak2FTyMu/Hs/ -----ENDENCRYPTED PRIVATE KEY----- 私钥经过PEM编码后在文件头尾都添加了标签，用以说明当前的文件格式。从标签内容也可以看出私钥是加密的，因为有“ ENCRYPTED”。中间的私钥内容是经过BASE64编码的，这样方便私钥的传递，例如在网络上传输，数据复制粘贴。 &nbsp; 例子只是PEM文件格式的其中一种，以下是平时可能会碰到的PEM私钥格式： PKCS#8 私钥加密格式 -----BEGIN ENCRYPTED PRIVATE KEY----- BASE64私钥内容 -----ENDENCRYPTED PRIVATE KEY----- PKCS#8 私钥非加密格式 -----BEGIN PRIVATE KEY----- BASE64私钥内容 -----END PRIVATEKEY----- Openssl ASN格式 -----BEGIN RSA PRIVATE KEY----- Proc-Type: 4,ENCRYPTED DEK-Info:DES-EDE3-CBC,4D5D1AF13367D726 BASE64私钥内容 -----END RSA PRIVATE KEY----- 除了以上几种，还有微软的PVK格式；以及DER编码格式，就是在使用PEM编码前的数据，由于没有密码保护，平时很少直接使用。 &nbsp; Openssl ASN格式在加密私钥数据时只能用MD5算法生成key，而且只迭代计算了1次。 所以从1.0.0开始Openssl把PKCS#8格式作为默认格式，可以为私钥文件提供更好的安全性和扩展性。 我们这里就针对PKCS#8格式的私钥进行讨论。 如果大家想要研究其他格式，可以使用以下命令： &nbsp;genrsa 生成ASN格式 &nbsp;rsa 生成或转换为PVK格式 openssl rsa -in privatekey.pem -out privatekey.pvk -outform PVK&nbsp;&nbsp; 2 分析私钥文件&nbsp; 使用asn1parse命令读取私钥ASN.1结构，其中–i表示输出使用缩进格式。 openssl asn1parse -i -in privatekey.pem&nbsp; 0:d=0 hl=4 l= 710 cons: SEQUENCE 4:d=1 hl=2 l= 64 cons: SEQUENCE 6:d=2 hl=2 l= 9 prim: OBJECT :PBES2 17:d=2 hl=2 l= 51 cons: SEQUENCE 19:d=3 hl=2 l= 27 cons: SEQUENCE 21:d=4 hl=2 l= 9 prim: OBJECT :PBKDF2 32:d=4 hl=2 l= 14 cons: SEQUENCE 34:d=5 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:7A61B055165A89CA 44:d=5 hl=2 l= 2 prim: INTEGER :0800 48:d=3 hl=2 l= 20 cons: SEQUENCE 50:d=4 hl=2 l= 8 prim: OBJECT :des-ede3-cbc 60:d=4 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:110E8A184EFEAB9C 70:d=1 hl=4 l= 640 prim: OCTET STRING [HEX DUMP]: C94F34F0CFF56B3E92D437C49559B1BD632BA2D8B22AF290B0E8EBB7F71C555115CED4DE87E3922A41436A20DA1DB01F1BD88EA3002E8AD4691C0B25F16AF4D196C2A96B99A1D49F704A21D3B81F8CC81C3F09412317B67F453151490D2573E1FD96D13BB55E7FCD4085ED0C4DD75EB1EFFC4ACE5431AFD708E6ECE5077BAB2B03965C6F2873C1DB5F475F861E9C04D61465C72A8A99DCF093190F746DD8959C0B0942E38A013B0FEC2D4A66F600EF75CE0326F3B4904C3128CB389204A1CC4F93EED7C8F2450603A42C6C16FB143FF4C9C01E714A43CC07B1F1B580A6C9DE4DC9B78CA0D5B874C75A0F56F6A55CFE4620F1AC639DCE4A8AF2BCBB69691DAF983BB26F6A6C859C371D1EBA7DA5C27FBDAC86C6529C48B32E3B89317FC7EBF03F9C105EAA1892437E9E789F0E2340979812A53CD1668EC07A45BBEAE088E7E27BB20B16C2D14280970BBF715D57005F194B97A1784E7BC563A0B84909A7EAB6C7E0BC6E2B467AA4009420D190617F93CD32FAEEE50003462DC8B26816040E891523E1375F339A3F05C43C9E90A4533BD4D3F75A2A33E60D91563542355D5ED1F46CF62594460694F459F0EC428BECE015F075895CFEB502EA22ECD9B53BF050B795074BE9A51194789F0B2970C21CCFE16284FB564F720C7899D5840362C48D248A50BAFA2720B0C1F7B417AD6EA183459BBB80679A85D96421C5AE3FA53A2135217F886759187123766914BB0169F6F9C3A36F1C46B6EB9300009A799D0F96C3E1FBE805F17A01FF2F5A9C941399E6130DBEE9825F4EB8937F2B8F0B3DE5F08644F3DC65028F2DE150D03D454AECFF9CAF26A00BB1B6D6D2C5255216E0A6769F14937618E31573811AAA464C3C42246A17DD70B1F77A87948FD5C7526D569BB8 ASN.1结构输出格式说明： 0:d=0 hl=4 l= 710 cons: SEQUENCE 0 表示节点在整个文件中的偏移长度 d=0 表示节点深度 hl=4&nbsp;表示节点头字节长度 l=710&nbsp;表示节点数据字节长度 cons 表示该节点为结构节点，表示包含子节点或者子结构数据 prim 表示该节点为原始节点，包含数据 SEQUENCE、OCTETSTRING等都是ASN.1中定义的数据类型，具体可以参考ASN.1格式说明。 &nbsp;最后一个节点OCTET STRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HEX DUMP]，就是加密后的私钥数据。 为了方便理解，下面给出相关的PKCS定义。 PCKS#8文件格式定义： PrivateKeyInfo ::= SEQUENCE { version Version, privateKeyAlgorithm PrivateKeyAlgorithmIdentifier, privateKey PrivateKey, attributes [0] IMPLICIT Attributes OPTIONAL } privateKey，加密后私钥数据，最后一个OCTET STRING数据块。 privateKeyAlgorithm，使用的私钥算法，详细格式在 PKCS#5&nbsp;2.0中的定义： PBES2-params ::= SEQUENCE { keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}}, encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} } keyDerivationFunc 加密密钥生成函数，现在默认使用的是sha1，还包含了salt，迭代次数iterationCount： PBKDF2-params ::= SEQUENCE { salt CHOICE { specified OCTET STRING, otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}} }, iterationCount INTEGER (1..MAX), keyLength INTEGER (1..MAX) OPTIONAL, prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1 } 对应数据： 19:d=3 hl=2 l= 27 cons: SEQUENCE 21:d=4 hl=2 l= 9 prim: OBJECT :PBKDF2 32:d=4 hl=2 l= 14 cons: SEQUENCE 34:d=5 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:7A61B055165A89CA 44:d=5 hl=2 l= 2 prim: INTEGER :0800 encryptionScheme 加密算法，例子中使用的是des-ede3-cbc，该结构中还包含初始化向量iv。 对应数据： 48:d=3 hl=2 l= 20 cons: SEQUENCE 50:d=4 hl=2 l= 8 prim: OBJECT :des-ede3-cbc 60:d=4 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:110E8A184EFEAB9C 解密流程： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 按PKCS#8和PCKS#5定义从文件中解析出相关参数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密密钥生成函数（KDF）PBKDF2； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密时使用的salt：7A61B055165A89CA，以及迭代次数iter：0x0800（2048次）； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密算法des-ede3-cbc，以及加密初始向量iv：110E8A184EFEAB9C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 解析出加密的私钥数据data，也就是最后一个OCTET STRING； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 生成加密密钥：key = KDF（pass（1234），salt，iter） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 解密 des-ede3-cbc（key， iv， data） &nbsp; 这一解密过程可以使用openssl的pkey命令完成，执行完成后得到privatekey.der文件，这个是没有加密的私钥文件，数据是ASN.1格式，并使用DER编码。 Openssl pkey -in privatekey.pem -out privatekey.der-passin pass:1234 &nbsp;&nbsp; 然后再次分析密钥数据，由于输入是der格式，需要使用inform参数说明： openssl asn1parse -in privatekey.der -inform DER &nbsp; 0:d=0 hl=4 l= 604 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=3 l= 129 prim:INTEGER : A11E66B0F965215AB4AD771581700477F62D9EDF2CFEBDF2E20C02DE4E95881F58CA898B6FC389CC83AE39DE95C0252BCF9FB98A6A21A20B751222DF2A4CBE1E08F8BDC8D443A59D4944723C33CED5601E1CF4A324E88B951626326783014CFF3BB7CF7278BF443AB003D1E1608B97CFC7783C6FD42B9A7C8F84C5633FB72DFB 139:d=1 hl=2 l= 3 prim: INTEGER :010001 144:d=1 hl=3 l= 129 prim:INTEGER : 9B2C9B7CD105AC851EC47E8FB0D541088489D59C5E4A8E88F15ADE1C5B953ABFEE154B39870FCD94B23247BBEF805A8C826FF413B239E8469E9F3404B949A643E1E2CCF9753822FD28345B7898148164DA2D858F672B52C7B3041F0A9F6FFFB97759D3C04AE3ED2E372E4ADD3A44202CE004D189566A81F19239649779F30DE9 276:d=1 hl=2 l= 65 prim: INTEGER : CE25257FDE50AFDAF926BDBEFE5A236C130F2714C5FC0C36A07B5AA5618E8F5039E313387C933A86EBDC2DEF8640069CB98B1D04C3E74B46C75F292A768083D5 343:d=1 hl=2 l= 65 prim: INTEGER : C8159573F6C413EAC0BB721B859A4B7920FF9DE151546CA28FDA3F43A0999C835DB9078AF5054CE503C4BC174ECB1F0C4DE033E116A296FD67B4158F869E628F 410:d=1 hl=2 l= 64 prim: INTEGER : 7329855D7DD10DAD02EB85AD216331CEBA87088A2E60B462001D697262A1C5A647F07758631FCCDE7AFD321C519F8B121B05805C9D24A58510F4348728547B51 476:d=1 hl=2 l= 64 prim: INTEGER : 53735D203EBDCD28CE35E003C69771FF155A47B92038BC0E993D07C1E70BEA9187D79263CC89E7666549FAC125E5E60F35B3DB2F78475BFE58F06D45AD7A05D5 542:d=1 hl=2 l= 64 prim: INTEGER : 4F454C491EAE6CD85ED812D8A26AFD5FD0F6D7DD12AD6D20EDA8C2D257943928B2AE66FDE336F40370D9CC30B85EB2F20D3B4FDAB61D168FE7936CB6AB5E8FE2 &nbsp;得到的数据与上次导出的格式是相同的，虽然看起来数据多，但是层次结构起始要简单，数据就是一个结构体（cons）SEQUENCE，包含9个整型的原始数据（prim）INTERGER，这个就是私钥结构，该 ASN.1结构在PKCS#1中定义如下： RSAPrivateKey ::= SEQUENCE { versionVersion, modulusINTEGER, -- n publicExponentINTEGER, -- e privateExponentINTEGER, -- d prime1INTEGER, -- p prime2INTEGER, -- q exponent1INTEGER, -- d mod (p-1) exponent2INTEGER, -- d mod (q-1) coefficientINTEGER, -- (inverse of q) mod p otherPrimeInfosOtherPrimeInfos OPTIONAL } 最后一个otherPrimeInfos是可选项，例子中没有该数据。 结构中包含了RSA密钥算法中用到的所有信息，每一项的具体定义可以参考PKCS#1。 &nbsp; 3 分析公钥 &nbsp;为了方便获取公钥，在私钥文件数据中起始包含了公钥信息： modulus INTEGER, -- n publicExponent INTEGER, -- e 公钥的ASN.1结构也在PKCS#1中定义： RSAPublicKey ::= SEQUENCE { modulus INTEGER, -- n publicExponentINTEGER -- e } 可以使用openssl命令导出公钥文件pubkey.pem，使用文本工具打开公钥文件，pem头尾格式和私钥类似的标签： openssl pkey -in privatekey.der -inform DER -out pubkey.pem-pubout &nbsp; -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQChHmaw+WUhWrStdxWBcAR39i2e 3yz+vfLiDALeTpWIH1jKiYtvw4nMg6453pXAJSvPn7mKaiGiC3USIt8qTL4eCPi9 yNRDpZ1JRHI8M87VYB4c9KMk6IuVFiYyZ4MBTP87t89yeL9EOrAD0eFgi5fPx3g8 b9QrmnyPhMVjP7ct+wIDAQAB -----END PUBLIC KEY----- 继续分析公钥文件的ASN.1格式： openssl asn1parse -in pubkey.pem -i &nbsp; 0:d=0 hl=3 l= 159 cons: SEQUENCE 3:d=1 hl=2 l= 13 cons: SEQUENCE 5:d=2 hl=2 l= 9 prim: OBJECT :rsaEncryption 16:d=2 hl=2 l= 0 prim: NULL 18:d=1 hl=3 l= 141 prim: BIT STRING 但是这里显示格式和上边给出的PKCS#1格式不一致，其实这是x.509中的定义的格式，在X.509证书文件中就是使用这个格式封装公钥数据，其中BIT STRING的内容就是PKCS#1格式的公钥数据，并说明了使用的公钥算法rsaEncryption。 SubjectPublicKeyInfo ::=SEQUENCE { algorithmAlgorithmIdentifier{{SupportedAlgorithms}}, subjectPublicKeyBIT STRING }&nbsp; 我们可以进一步使用asn1parse工具解析出BIT STRING内容，首先确定该数据块偏移是18，然后使用参数-strparse指定位置,可以看到输出的数据和私钥文件中的是一样的。 asn1parse -in pubkey.pem -strparse 18 &nbsp;输出公钥ASN.1格式： 0:d=0 hl=3 l= 137 cons: SEQUENCE 3:d=1 hl=3 l= 129 prim: INTEGER : A11E66B0F965215AB4AD771581700477F62D9EDF2CFEBDF2E20C02DE4E95881F58CA898B6FC389CC83AE39DE95C0252BCF9FB98A6A21A20B751222DF2A4CBE1E08F8BDC8D443A59D4944723C33CED5601E1CF4A324E88B951626326783014CFF3BB7CF7278BF443AB003D1E1608B97CFC7783C6FD42B9A7C8F84C5633FB72DFB 135:d=1 hl=2 l=3 prim: INTEGER :010001&nbsp; 4 公私钥操作 分析完私钥和公钥格式，以及之间的关系。接下来我们将继续使用openssl的rsautl测试它们之间的加解密、签名、验证等操作。 测试文件test，内容“1234567890”。 &nbsp; 4.1加解密 &nbsp;1）公钥加密 openssl rsautl -encrypt -in test -out test.enc -inkey asn1pub.pem -pubin &nbsp;2）私钥解密 openssl rsautl -decrypt -in test.enc -out test.dec -inkey asn1enc.pem &nbsp; 比较test和test.dec两个文件结果相同。 &nbsp; 4.2签名验证 1）私钥签名 openssl rsautl -sign -in test -out test.sig-inkey asn1enc.pem &nbsp; 2）公钥验证 openssl rsautl -verify -in test.sig -out test.vfy -inkey asn1pub.pem -pubin &nbsp; 比较test和test.vfy连个文件应该相同。 &nbsp; 阅读更多" />
<meta property="og:site_name" content="有组织在！" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-06-22T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Openssl提供了强大证书功能，生成密钥对、证书，颁发证书、生成crl、验证证书、销毁证书等。本文将j介绍如何利用openssl的命令分析RSA私钥文件格式，同时也将简单介绍几种常见的私钥文件格式。 &nbsp; 1 生成私钥文件 openssl有多种方法生成私钥： genrsa生成RSA密钥。 req在生成req证书请求时同时产生密钥。 genpkey除了可以生成RSA密钥外，还可以生成DSA、DH密钥。 &nbsp;这里我使用genpkey命令生成RSA私钥文件，选择DES-EDE3-CBC算法进行加密，口令是1234： openssl genpkey -algorithm RSA -out privatekey.pem -pass pass:1234 -des-ede3-cbc 命令执行后输出私钥文件 privatekey.pem，默认输出为 PEM格式，密钥长度为1024，接下来使用文本工具直接打开该文件，可以看到如下内容：&nbsp; -----BEGINENCRYPTED PRIVATE KEY----- MIICxjBABgkqhkiG9w0BBQ0wMzAbBgkqhkiG9w0BBQwwDgQIhrQ3ApYYe1ACAggA MBQGCCqGSIb3DQMHBAgyM5zYLuXOdQSCAoAFqnCRqkpoHJTY0BpLeekzjsuzdTOq DkgxJMi4WRt1rZNyHqarbhHCZGC9Lug/xbLW5e2ZtjYVJ+ljmFb4lUaAch4nAgoz m0J5YyrbFKppiqlk6vkS5hKfpKbWrx5hkQzMt6OsVEQFj2U+EvOI8SVgI6LkjNmh 7qokYxv9Inx9joM6agEUY9fXdAu53CyfjpneX95vxUHIn7hHmhxH7MYua619N7x+ JVA65b3Kj45aH3cnY/kMAQ78EN9aLpqYXzn6j9GRdUd2JMuP0IrYlREw3/z8Qn68 CwGXzGtkYnlt0xHdOG/tnmKWqBg1cY9uVx6g6JT1BUabqwxVODaMqaSsFr4o3xJo 3TTh8TswK0V/+3JLkXtasI7V8cRj2dksccGApujmB5eymU3XXTlX3iXs481I4kmz JOZHbqfGOpyzW6WqhMO+LebIkyIGMlCGRiJ3PNSQI9w6bfZ9FoqC6OfFKY1OEmBN 6ALtPc+cYXeO5Msx9mbakIYRbcjlVmelPsLyvAceW/09OG909turflvYaGnM+SKd KzWn2gFr3YwF57WZlX2jifYUUnjHVMZW7s/k6hgOxcEnvBOg4Ug/cKdNPUEB7tJx nvsR+odHypyjgyphLEP8UmEiz3/hnPV8lhLDAPV7fKaK+zDglKqQYF3KBLh55q6h PPe1HqahifK9EKqWOl7m1HhFPIZTex4clLy98rB3gyXnL0qx4+A7WD6uLJbU285j IWMNq3f1c80ZPrpbhT6hd6Z9zUwfYT6gTO9gIIe4d5KVmfjNaFwSls5zaI6x7AJp d/Xl/m1u469+J0rWyeY3D4wtahvZrKMXRrILtJ5OgkWPak2FTyMu/Hs/ -----ENDENCRYPTED PRIVATE KEY----- 私钥经过PEM编码后在文件头尾都添加了标签，用以说明当前的文件格式。从标签内容也可以看出私钥是加密的，因为有“ ENCRYPTED”。中间的私钥内容是经过BASE64编码的，这样方便私钥的传递，例如在网络上传输，数据复制粘贴。 &nbsp; 例子只是PEM文件格式的其中一种，以下是平时可能会碰到的PEM私钥格式： PKCS#8 私钥加密格式 -----BEGIN ENCRYPTED PRIVATE KEY----- BASE64私钥内容 -----ENDENCRYPTED PRIVATE KEY----- PKCS#8 私钥非加密格式 -----BEGIN PRIVATE KEY----- BASE64私钥内容 -----END PRIVATEKEY----- Openssl ASN格式 -----BEGIN RSA PRIVATE KEY----- Proc-Type: 4,ENCRYPTED DEK-Info:DES-EDE3-CBC,4D5D1AF13367D726 BASE64私钥内容 -----END RSA PRIVATE KEY----- 除了以上几种，还有微软的PVK格式；以及DER编码格式，就是在使用PEM编码前的数据，由于没有密码保护，平时很少直接使用。 &nbsp; Openssl ASN格式在加密私钥数据时只能用MD5算法生成key，而且只迭代计算了1次。 所以从1.0.0开始Openssl把PKCS#8格式作为默认格式，可以为私钥文件提供更好的安全性和扩展性。 我们这里就针对PKCS#8格式的私钥进行讨论。 如果大家想要研究其他格式，可以使用以下命令： &nbsp;genrsa 生成ASN格式 &nbsp;rsa 生成或转换为PVK格式 openssl rsa -in privatekey.pem -out privatekey.pvk -outform PVK&nbsp;&nbsp; 2 分析私钥文件&nbsp; 使用asn1parse命令读取私钥ASN.1结构，其中–i表示输出使用缩进格式。 openssl asn1parse -i -in privatekey.pem&nbsp; 0:d=0 hl=4 l= 710 cons: SEQUENCE 4:d=1 hl=2 l= 64 cons: SEQUENCE 6:d=2 hl=2 l= 9 prim: OBJECT :PBES2 17:d=2 hl=2 l= 51 cons: SEQUENCE 19:d=3 hl=2 l= 27 cons: SEQUENCE 21:d=4 hl=2 l= 9 prim: OBJECT :PBKDF2 32:d=4 hl=2 l= 14 cons: SEQUENCE 34:d=5 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:7A61B055165A89CA 44:d=5 hl=2 l= 2 prim: INTEGER :0800 48:d=3 hl=2 l= 20 cons: SEQUENCE 50:d=4 hl=2 l= 8 prim: OBJECT :des-ede3-cbc 60:d=4 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:110E8A184EFEAB9C 70:d=1 hl=4 l= 640 prim: OCTET STRING [HEX DUMP]: C94F34F0CFF56B3E92D437C49559B1BD632BA2D8B22AF290B0E8EBB7F71C555115CED4DE87E3922A41436A20DA1DB01F1BD88EA3002E8AD4691C0B25F16AF4D196C2A96B99A1D49F704A21D3B81F8CC81C3F09412317B67F453151490D2573E1FD96D13BB55E7FCD4085ED0C4DD75EB1EFFC4ACE5431AFD708E6ECE5077BAB2B03965C6F2873C1DB5F475F861E9C04D61465C72A8A99DCF093190F746DD8959C0B0942E38A013B0FEC2D4A66F600EF75CE0326F3B4904C3128CB389204A1CC4F93EED7C8F2450603A42C6C16FB143FF4C9C01E714A43CC07B1F1B580A6C9DE4DC9B78CA0D5B874C75A0F56F6A55CFE4620F1AC639DCE4A8AF2BCBB69691DAF983BB26F6A6C859C371D1EBA7DA5C27FBDAC86C6529C48B32E3B89317FC7EBF03F9C105EAA1892437E9E789F0E2340979812A53CD1668EC07A45BBEAE088E7E27BB20B16C2D14280970BBF715D57005F194B97A1784E7BC563A0B84909A7EAB6C7E0BC6E2B467AA4009420D190617F93CD32FAEEE50003462DC8B26816040E891523E1375F339A3F05C43C9E90A4533BD4D3F75A2A33E60D91563542355D5ED1F46CF62594460694F459F0EC428BECE015F075895CFEB502EA22ECD9B53BF050B795074BE9A51194789F0B2970C21CCFE16284FB564F720C7899D5840362C48D248A50BAFA2720B0C1F7B417AD6EA183459BBB80679A85D96421C5AE3FA53A2135217F886759187123766914BB0169F6F9C3A36F1C46B6EB9300009A799D0F96C3E1FBE805F17A01FF2F5A9C941399E6130DBEE9825F4EB8937F2B8F0B3DE5F08644F3DC65028F2DE150D03D454AECFF9CAF26A00BB1B6D6D2C5255216E0A6769F14937618E31573811AAA464C3C42246A17DD70B1F77A87948FD5C7526D569BB8 ASN.1结构输出格式说明： 0:d=0 hl=4 l= 710 cons: SEQUENCE 0 表示节点在整个文件中的偏移长度 d=0 表示节点深度 hl=4&nbsp;表示节点头字节长度 l=710&nbsp;表示节点数据字节长度 cons 表示该节点为结构节点，表示包含子节点或者子结构数据 prim 表示该节点为原始节点，包含数据 SEQUENCE、OCTETSTRING等都是ASN.1中定义的数据类型，具体可以参考ASN.1格式说明。 &nbsp;最后一个节点OCTET STRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HEX DUMP]，就是加密后的私钥数据。 为了方便理解，下面给出相关的PKCS定义。 PCKS#8文件格式定义： PrivateKeyInfo ::= SEQUENCE { version Version, privateKeyAlgorithm PrivateKeyAlgorithmIdentifier, privateKey PrivateKey, attributes [0] IMPLICIT Attributes OPTIONAL } privateKey，加密后私钥数据，最后一个OCTET STRING数据块。 privateKeyAlgorithm，使用的私钥算法，详细格式在 PKCS#5&nbsp;2.0中的定义： PBES2-params ::= SEQUENCE { keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}}, encryptionScheme AlgorithmIdentifier {{PBES2-Encs}} } keyDerivationFunc 加密密钥生成函数，现在默认使用的是sha1，还包含了salt，迭代次数iterationCount： PBKDF2-params ::= SEQUENCE { salt CHOICE { specified OCTET STRING, otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}} }, iterationCount INTEGER (1..MAX), keyLength INTEGER (1..MAX) OPTIONAL, prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1 } 对应数据： 19:d=3 hl=2 l= 27 cons: SEQUENCE 21:d=4 hl=2 l= 9 prim: OBJECT :PBKDF2 32:d=4 hl=2 l= 14 cons: SEQUENCE 34:d=5 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:7A61B055165A89CA 44:d=5 hl=2 l= 2 prim: INTEGER :0800 encryptionScheme 加密算法，例子中使用的是des-ede3-cbc，该结构中还包含初始化向量iv。 对应数据： 48:d=3 hl=2 l= 20 cons: SEQUENCE 50:d=4 hl=2 l= 8 prim: OBJECT :des-ede3-cbc 60:d=4 hl=2 l= 8 prim: OCTET STRING [HEX DUMP]:110E8A184EFEAB9C 解密流程： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 按PKCS#8和PCKS#5定义从文件中解析出相关参数： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密密钥生成函数（KDF）PBKDF2； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密时使用的salt：7A61B055165A89CA，以及迭代次数iter：0x0800（2048次）； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密算法des-ede3-cbc，以及加密初始向量iv：110E8A184EFEAB9C &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 解析出加密的私钥数据data，也就是最后一个OCTET STRING； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 生成加密密钥：key = KDF（pass（1234），salt，iter） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 解密 des-ede3-cbc（key， iv， data） &nbsp; 这一解密过程可以使用openssl的pkey命令完成，执行完成后得到privatekey.der文件，这个是没有加密的私钥文件，数据是ASN.1格式，并使用DER编码。 Openssl pkey -in privatekey.pem -out privatekey.der-passin pass:1234 &nbsp;&nbsp; 然后再次分析密钥数据，由于输入是der格式，需要使用inform参数说明： openssl asn1parse -in privatekey.der -inform DER &nbsp; 0:d=0 hl=4 l= 604 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=3 l= 129 prim:INTEGER : A11E66B0F965215AB4AD771581700477F62D9EDF2CFEBDF2E20C02DE4E95881F58CA898B6FC389CC83AE39DE95C0252BCF9FB98A6A21A20B751222DF2A4CBE1E08F8BDC8D443A59D4944723C33CED5601E1CF4A324E88B951626326783014CFF3BB7CF7278BF443AB003D1E1608B97CFC7783C6FD42B9A7C8F84C5633FB72DFB 139:d=1 hl=2 l= 3 prim: INTEGER :010001 144:d=1 hl=3 l= 129 prim:INTEGER : 9B2C9B7CD105AC851EC47E8FB0D541088489D59C5E4A8E88F15ADE1C5B953ABFEE154B39870FCD94B23247BBEF805A8C826FF413B239E8469E9F3404B949A643E1E2CCF9753822FD28345B7898148164DA2D858F672B52C7B3041F0A9F6FFFB97759D3C04AE3ED2E372E4ADD3A44202CE004D189566A81F19239649779F30DE9 276:d=1 hl=2 l= 65 prim: INTEGER : CE25257FDE50AFDAF926BDBEFE5A236C130F2714C5FC0C36A07B5AA5618E8F5039E313387C933A86EBDC2DEF8640069CB98B1D04C3E74B46C75F292A768083D5 343:d=1 hl=2 l= 65 prim: INTEGER : C8159573F6C413EAC0BB721B859A4B7920FF9DE151546CA28FDA3F43A0999C835DB9078AF5054CE503C4BC174ECB1F0C4DE033E116A296FD67B4158F869E628F 410:d=1 hl=2 l= 64 prim: INTEGER : 7329855D7DD10DAD02EB85AD216331CEBA87088A2E60B462001D697262A1C5A647F07758631FCCDE7AFD321C519F8B121B05805C9D24A58510F4348728547B51 476:d=1 hl=2 l= 64 prim: INTEGER : 53735D203EBDCD28CE35E003C69771FF155A47B92038BC0E993D07C1E70BEA9187D79263CC89E7666549FAC125E5E60F35B3DB2F78475BFE58F06D45AD7A05D5 542:d=1 hl=2 l= 64 prim: INTEGER : 4F454C491EAE6CD85ED812D8A26AFD5FD0F6D7DD12AD6D20EDA8C2D257943928B2AE66FDE336F40370D9CC30B85EB2F20D3B4FDAB61D168FE7936CB6AB5E8FE2 &nbsp;得到的数据与上次导出的格式是相同的，虽然看起来数据多，但是层次结构起始要简单，数据就是一个结构体（cons）SEQUENCE，包含9个整型的原始数据（prim）INTERGER，这个就是私钥结构，该 ASN.1结构在PKCS#1中定义如下： RSAPrivateKey ::= SEQUENCE { versionVersion, modulusINTEGER, -- n publicExponentINTEGER, -- e privateExponentINTEGER, -- d prime1INTEGER, -- p prime2INTEGER, -- q exponent1INTEGER, -- d mod (p-1) exponent2INTEGER, -- d mod (q-1) coefficientINTEGER, -- (inverse of q) mod p otherPrimeInfosOtherPrimeInfos OPTIONAL } 最后一个otherPrimeInfos是可选项，例子中没有该数据。 结构中包含了RSA密钥算法中用到的所有信息，每一项的具体定义可以参考PKCS#1。 &nbsp; 3 分析公钥 &nbsp;为了方便获取公钥，在私钥文件数据中起始包含了公钥信息： modulus INTEGER, -- n publicExponent INTEGER, -- e 公钥的ASN.1结构也在PKCS#1中定义： RSAPublicKey ::= SEQUENCE { modulus INTEGER, -- n publicExponentINTEGER -- e } 可以使用openssl命令导出公钥文件pubkey.pem，使用文本工具打开公钥文件，pem头尾格式和私钥类似的标签： openssl pkey -in privatekey.der -inform DER -out pubkey.pem-pubout &nbsp; -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQChHmaw+WUhWrStdxWBcAR39i2e 3yz+vfLiDALeTpWIH1jKiYtvw4nMg6453pXAJSvPn7mKaiGiC3USIt8qTL4eCPi9 yNRDpZ1JRHI8M87VYB4c9KMk6IuVFiYyZ4MBTP87t89yeL9EOrAD0eFgi5fPx3g8 b9QrmnyPhMVjP7ct+wIDAQAB -----END PUBLIC KEY----- 继续分析公钥文件的ASN.1格式： openssl asn1parse -in pubkey.pem -i &nbsp; 0:d=0 hl=3 l= 159 cons: SEQUENCE 3:d=1 hl=2 l= 13 cons: SEQUENCE 5:d=2 hl=2 l= 9 prim: OBJECT :rsaEncryption 16:d=2 hl=2 l= 0 prim: NULL 18:d=1 hl=3 l= 141 prim: BIT STRING 但是这里显示格式和上边给出的PKCS#1格式不一致，其实这是x.509中的定义的格式，在X.509证书文件中就是使用这个格式封装公钥数据，其中BIT STRING的内容就是PKCS#1格式的公钥数据，并说明了使用的公钥算法rsaEncryption。 SubjectPublicKeyInfo ::=SEQUENCE { algorithmAlgorithmIdentifier{{SupportedAlgorithms}}, subjectPublicKeyBIT STRING }&nbsp; 我们可以进一步使用asn1parse工具解析出BIT STRING内容，首先确定该数据块偏移是18，然后使用参数-strparse指定位置,可以看到输出的数据和私钥文件中的是一样的。 asn1parse -in pubkey.pem -strparse 18 &nbsp;输出公钥ASN.1格式： 0:d=0 hl=3 l= 137 cons: SEQUENCE 3:d=1 hl=3 l= 129 prim: INTEGER : A11E66B0F965215AB4AD771581700477F62D9EDF2CFEBDF2E20C02DE4E95881F58CA898B6FC389CC83AE39DE95C0252BCF9FB98A6A21A20B751222DF2A4CBE1E08F8BDC8D443A59D4944723C33CED5601E1CF4A324E88B951626326783014CFF3BB7CF7278BF443AB003D1E1608B97CFC7783C6FD42B9A7C8F84C5633FB72DFB 135:d=1 hl=2 l=3 prim: INTEGER :010001&nbsp; 4 公私钥操作 分析完私钥和公钥格式，以及之间的关系。接下来我们将继续使用openssl的rsautl测试它们之间的加解密、签名、验证等操作。 测试文件test，内容“1234567890”。 &nbsp; 4.1加解密 &nbsp;1）公钥加密 openssl rsautl -encrypt -in test -out test.enc -inkey asn1pub.pem -pubin &nbsp;2）私钥解密 openssl rsautl -decrypt -in test.enc -out test.dec -inkey asn1enc.pem &nbsp; 比较test和test.dec两个文件结果相同。 &nbsp; 4.2签名验证 1）私钥签名 openssl rsautl -sign -in test -out test.sig-inkey asn1enc.pem &nbsp; 2）公钥验证 openssl rsautl -verify -in test.sig -out test.vfy -inkey asn1pub.pem -pubin &nbsp; 比较test和test.vfy连个文件应该相同。 &nbsp; 阅读更多","@type":"BlogPosting","url":"/2012/06/22/d05240a652c63326e15064aeb92ee68a.html","headline":"使用openssl命令剖析RSA私钥文件格式","dateModified":"2012-06-22T00:00:00+08:00","datePublished":"2012-06-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"/2012/06/22/d05240a652c63326e15064aeb92ee68a.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-123344652-1');
    </script>
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-8889449066804352",
        enable_page_level_ads: true
      });
    </script>
    
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    
    <style>
      @media screen and (max-width:760px){
        .sm-hidden{display:none; }
      }
    </style>

  </head>
  <body>
    
        <amp-auto-ads type="adsense"
              data-ad-client="ca-pub-8889449066804352">
        </amp-auto-ads>
    
    <div class="wrapper">
      <header  class="without-description" >
        <h1>使用openssl命令剖析RSA私钥文件格式</h1>
        
        
        <ul>
            <li><a href="https://uzshare.com/" style="line-height: unset;" target="_blank"><strong>柚子社区</strong></a></li>
        </ul>
        
        
        
      </header>
      <section>

<div style="margin:0 0 8px 0;">
<style>
table.gsc-input {
    margin: 0;
}
.cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
    width: auto;
}
.gsc-search-box td {
    border-bottom: none;
}
</style>
<script>
  (function() {
    var cx = '004431708863642777669:qan2_6ugotw';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</div>
	

        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"> 
 <div class="htmledit_views"> 
  <p align="center">&nbsp;</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Openssl提供了强大证书功能，生成密钥对、证书，颁发证书、生成crl、验证证书、销毁证书等。本文将j介绍如何利用openssl的命令分析RSA私钥文件格式，同时也将简单介绍几种常见的私钥文件格式。</p> 
  <p>&nbsp;</p> 
  <h2>1 生成私钥文件</h2> 
  <p>openssl有多种方法生成私钥：</p> 
  <p></p> 
  <ul>
   <li>genrsa生成RSA密钥。</li>
   <li>req在生成req证书请求时同时产生密钥。</li>
   <li>genpkey除了可以生成RSA密钥外，还可以生成DSA、DH密钥。</li>
  </ul>
  <p></p> 
  <p>&nbsp;这里我使用genpkey命令生成RSA私钥文件，选择DES-EDE3-CBC算法进行加密，口令是1234：</p> 
  <p></p> 
  <pre><code class="language-plain"> openssl genpkey -algorithm RSA -out privatekey.pem -pass pass:1234 -des-ede3-cbc</code></pre>
  <br>
  <br> 命令执行后输出私钥文件
  <strong>privatekey.pem</strong>，默认输出为
  <strong>PEM</strong>格式，密钥长度为1024，接下来使用文本工具直接打开该文件，可以看到如下内容：&nbsp; 
  <p></p> 
  <p></p> 
  <pre><code class="language-html">-----BEGINENCRYPTED PRIVATE KEY-----
MIICxjBABgkqhkiG9w0BBQ0wMzAbBgkqhkiG9w0BBQwwDgQIhrQ3ApYYe1ACAggA
MBQGCCqGSIb3DQMHBAgyM5zYLuXOdQSCAoAFqnCRqkpoHJTY0BpLeekzjsuzdTOq
DkgxJMi4WRt1rZNyHqarbhHCZGC9Lug/xbLW5e2ZtjYVJ+ljmFb4lUaAch4nAgoz
m0J5YyrbFKppiqlk6vkS5hKfpKbWrx5hkQzMt6OsVEQFj2U+EvOI8SVgI6LkjNmh
7qokYxv9Inx9joM6agEUY9fXdAu53CyfjpneX95vxUHIn7hHmhxH7MYua619N7x+
JVA65b3Kj45aH3cnY/kMAQ78EN9aLpqYXzn6j9GRdUd2JMuP0IrYlREw3/z8Qn68
CwGXzGtkYnlt0xHdOG/tnmKWqBg1cY9uVx6g6JT1BUabqwxVODaMqaSsFr4o3xJo
3TTh8TswK0V/+3JLkXtasI7V8cRj2dksccGApujmB5eymU3XXTlX3iXs481I4kmz
JOZHbqfGOpyzW6WqhMO+LebIkyIGMlCGRiJ3PNSQI9w6bfZ9FoqC6OfFKY1OEmBN
6ALtPc+cYXeO5Msx9mbakIYRbcjlVmelPsLyvAceW/09OG909turflvYaGnM+SKd
KzWn2gFr3YwF57WZlX2jifYUUnjHVMZW7s/k6hgOxcEnvBOg4Ug/cKdNPUEB7tJx
nvsR+odHypyjgyphLEP8UmEiz3/hnPV8lhLDAPV7fKaK+zDglKqQYF3KBLh55q6h
PPe1HqahifK9EKqWOl7m1HhFPIZTex4clLy98rB3gyXnL0qx4+A7WD6uLJbU285j
IWMNq3f1c80ZPrpbhT6hd6Z9zUwfYT6gTO9gIIe4d5KVmfjNaFwSls5zaI6x7AJp
d/Xl/m1u469+J0rWyeY3D4wtahvZrKMXRrILtJ5OgkWPak2FTyMu/Hs/
-----ENDENCRYPTED PRIVATE KEY-----</code></pre>
  <br> 私钥经过PEM编码后在文件头尾都添加了标签，用以说明当前的文件格式。从标签内容也可以看出私钥是加密的，因为有“
  <span style="color:#FF0000;">ENCRYPTED</span>”。中间的私钥内容是经过BASE64编码的，这样方便私钥的传递，例如在网络上传输，数据复制粘贴。 
  <p></p> 
  <p>&nbsp;</p> 
  <p>例子只是PEM文件格式的其中一种，以下是平时可能会碰到的PEM私钥格式：</p> 
  <p></p> 
  <p><strong>PKCS#8 私钥加密格式</strong></p> 
  <pre><code class="language-html">-----BEGIN ENCRYPTED PRIVATE KEY-----
BASE64私钥内容
-----ENDENCRYPTED PRIVATE KEY-----</code></pre>
  <br>
  <strong>PKCS#8 私钥非加密格式</strong>
  <br>
  <p></p> 
  <pre><code class="language-html">-----BEGIN PRIVATE KEY-----
BASE64私钥内容
-----END PRIVATEKEY-----</code></pre> 
  <p></p> 
  <p><strong>Openssl ASN格式</strong></p> 
  <p></p> 
  <pre><code class="language-html">-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info:DES-EDE3-CBC,4D5D1AF13367D726
BASE64私钥内容
-----END RSA PRIVATE KEY-----</code></pre> 
  <p></p> 
  <p><br></p> 
  <p>除了以上几种，还有微软的PVK格式；以及DER编码格式，就是在使用PEM编码前的数据，由于没有密码保护，平时很少直接使用。</p> 
  <p>&nbsp;</p> 
  <p>Openssl ASN格式在加密私钥数据时只能用MD5算法生成key，而且只迭代计算了1次。</p> 
  <p>所以从1.0.0开始Openssl把PKCS#8格式作为默认格式，可以为私钥文件提供更好的安全性和扩展性。</p> 
  <p>我们这里就针对PKCS#8格式的私钥进行讨论。 如果大家想要研究其他格式，可以使用以下命令：</p> 
  <p>&nbsp;<strong>genrsa </strong>生成ASN格式</p> 
  <p>&nbsp;<strong>rsa </strong>生成或转换为PVK格式</p> 
  <p></p> 
  <pre><code class="language-html">openssl rsa -in privatekey.pem -out privatekey.pvk -outform PVK</code></pre>&nbsp;&nbsp; 
  <p></p> 
  <h2>2 分析私钥文件&nbsp;</h2> 
  <p>使用asn1parse命令读取私钥ASN.1结构，其中–i表示输出使用缩进格式。</p> 
  <p><span style="background-color:rgb(192,192,192);"><strong>openssl asn1parse -i -in privatekey.pem&nbsp;</strong></span></p> 
  <p></p> 
  <pre><code class="language-html">   0:d=0  hl=4 l= 710 cons: SEQUENCE
   4:d=1  hl=2 l=  64 cons: SEQUENCE
   6:d=2  hl=2 l=   9 prim:  OBJECT            :PBES2
  17:d=2  hl=2 l=  51 cons:  SEQUENCE
  19:d=3  hl=2 l=  27 cons:   SEQUENCE
  21:d=4  hl=2 l=   9 prim:    OBJECT            :PBKDF2
  32:d=4  hl=2 l=  14 cons:    SEQUENCE
  34:d=5  hl=2 l=   8 prim:     OCTET STRING      [HEX DUMP]:7A61B055165A89CA
  44:d=5  hl=2 l=   2 prim:     INTEGER           :0800
  48:d=3  hl=2 l=  20 cons:   SEQUENCE
  50:d=4  hl=2 l=   8 prim:    OBJECT            :des-ede3-cbc
  60:d=4  hl=2 l=   8 prim:    OCTET STRING      [HEX DUMP]:110E8A184EFEAB9C
  70:d=1  hl=4 l= 640 prim:  OCTET STRING      [HEX DUMP]:
C94F34F0CFF56B3E92D437C49559B1BD632BA2D8B22AF290B0E8EBB7F71C555115CED4DE87E3922A41436A20DA1DB01F1BD88EA3002E8AD4691C0B25F16AF4D196C2A96B99A1D49F704A21D3B81F8CC81C3F09412317B67F453151490D2573E1FD96D13BB55E7FCD4085ED0C4DD75EB1EFFC4ACE5431AFD708E6ECE5077BAB2B03965C6F2873C1DB5F475F861E9C04D61465C72A8A99DCF093190F746DD8959C0B0942E38A013B0FEC2D4A66F600EF75CE0326F3B4904C3128CB389204A1CC4F93EED7C8F2450603A42C6C16FB143FF4C9C01E714A43CC07B1F1B580A6C9DE4DC9B78CA0D5B874C75A0F56F6A55CFE4620F1AC639DCE4A8AF2BCBB69691DAF983BB26F6A6C859C371D1EBA7DA5C27FBDAC86C6529C48B32E3B89317FC7EBF03F9C105EAA1892437E9E789F0E2340979812A53CD1668EC07A45BBEAE088E7E27BB20B16C2D14280970BBF715D57005F194B97A1784E7BC563A0B84909A7EAB6C7E0BC6E2B467AA4009420D190617F93CD32FAEEE50003462DC8B26816040E891523E1375F339A3F05C43C9E90A4533BD4D3F75A2A33E60D91563542355D5ED1F46CF62594460694F459F0EC428BECE015F075895CFEB502EA22ECD9B53BF050B795074BE9A51194789F0B2970C21CCFE16284FB564F720C7899D5840362C48D248A50BAFA2720B0C1F7B417AD6EA183459BBB80679A85D96421C5AE3FA53A2135217F886759187123766914BB0169F6F9C3A36F1C46B6EB9300009A799D0F96C3E1FBE805F17A01FF2F5A9C941399E6130DBEE9825F4EB8937F2B8F0B3DE5F08644F3DC65028F2DE150D03D454AECFF9CAF26A00BB1B6D6D2C5255216E0A6769F14937618E31573811AAA464C3C42246A17DD70B1F77A87948FD5C7526D569BB8</code></pre>
  <br>
  <p></p> 
  <p>ASN.1结构输出格式说明：</p> 
  <p></p> 
  <pre><code class="language-html">0:d=0  hl=4 l= 710 cons: SEQUENCE</code></pre>
  <br>
  <strong>0 </strong>表示节点在整个文件中的偏移长度
  <br>
  <p><strong>d=0 </strong>表示节点深度</p> 
  <p><strong>hl=4&nbsp;</strong>表示节点头字节长度</p> 
  <p><strong>l=710&nbsp;</strong>表示节点数据字节长度</p> 
  <p><strong>cons </strong>表示该节点为结构节点，表示包含子节点或者子结构数据</p> 
  <p><strong>prim </strong>表示该节点为原始节点，包含数据</p> 
  <p><strong>SEQUENCE</strong>、<strong>OCTETSTRING</strong>等都是ASN.1中定义的数据类型，具体可以参考ASN.1格式说明。</p> 
  <p>&nbsp;最后一个节点OCTET STRING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HEX DUMP]，就是加密后的私钥数据。</p> 
  <p><br></p> 
  <p>为了方便理解，下面给出相关的PKCS定义。</p> 
  <p>PCKS#8文件格式定义：</p> 
  <p></p> 
  <pre><code class="language-html">PrivateKeyInfo ::= SEQUENCE {
        version                   Version,
        privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
        privateKey                PrivateKey,
        attributes           [0]  IMPLICIT Attributes OPTIONAL } </code></pre> 
  <p></p> 
  <p><strong><br></strong></p> 
  <p><strong><span style="font-size:12px;">privateKey</span></strong>，加密后私钥数据，最后一个OCTET STRING数据块。</p> 
  <br>
  <strong><span style="font-size:12px;">privateKeyAlgorithm</span>，</strong>使用的私钥算法，详细格式在
  <strong>PKCS#5&nbsp;2.0</strong>中的定义： 
  <p></p> 
  <pre><code class="language-html">PBES2-params ::= SEQUENCE {
       keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
       encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
   }</code></pre> 
  <p></p> 
  <p><strong><br></strong></p> 
  <p><strong><span style="font-size:12px;">keyDerivationFunc</span></strong></p> 
  <p>加密密钥生成函数，现在默认使用的是sha1，还包含了salt，迭代次数iterationCount：<br></p> 
  <pre><code class="language-html">PBKDF2-params ::= SEQUENCE {
       salt CHOICE {
         specified OCTET STRING,
         otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
       },
       iterationCount INTEGER (1..MAX),
       keyLength INTEGER (1..MAX) OPTIONAL,
       prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT
       algid-hmacWithSHA1
   }</code></pre>
  <pre><code class="language-html">对应数据：
  19:d=3  hl=2 l=  27 cons:   SEQUENCE
  21:d=4  hl=2 l=   9 prim:    OBJECT            :PBKDF2  
  32:d=4  hl=2 l=  14 cons:    SEQUENCE
  34:d=5  hl=2 l=   8 prim:     OCTET STRING      [HEX DUMP]:7A61B055165A89CA
  44:d=5  hl=2 l=   2 prim:     INTEGER           :0800
</code></pre>
  <strong><span style="font-size:12px;">encryptionScheme</span></strong> 
  <p>加密算法，例子中使用的是des-ede3-cbc，该结构中还包含初始化向量iv。</p> 
  <p></p> 
  <pre><code class="language-html">对应数据：
  48:d=3  hl=2 l=  20 cons:   SEQUENCE
  50:d=4  hl=2 l=   8 prim:    OBJECT            :des-ede3-cbc
  60:d=4  hl=2 l=   8 prim:    OCTET STRING      [HEX DUMP]:110E8A184EFEAB9C</code></pre>
  <br>
  <p></p> 
  <p>解密流程：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 按PKCS#8和PCKS#5定义从文件中解析出相关参数：</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密密钥生成函数（KDF）PBKDF2；</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密时使用的salt：7A61B055165A89CA，以及迭代次数iter：0x0800（2048次）；</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;加密算法des-ede3-cbc，以及加密初始向量iv：110E8A184EFEAB9C</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 解析出加密的私钥数据data，也就是最后一个OCTET STRING；</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 生成加密密钥：key = KDF（pass（1234），salt，iter）</p> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 解密 des-ede3-cbc（key， iv， data）</p> 
  <p>&nbsp;</p> 
  <p>这一解密过程可以使用openssl的pkey命令完成，执行完成后得到privatekey.der文件，这个是没有加密的私钥文件，数据是ASN.1格式，并使用DER编码。</p> 
  <p><span style="background-color:rgb(204,204,204);">Openssl pkey -in privatekey.pem -out privatekey.der-passin pass:1234</span></p> 
  <p>&nbsp;&nbsp;</p> 
  <p>然后再次分析密钥数据，由于输入是der格式，需要使用inform参数说明：</p> 
  <p><span style="background-color:rgb(204,204,204);">openssl asn1parse -in privatekey.der -inform DER</span></p> 
  <p>&nbsp;</p> 
  <pre><code class="language-html">   0:d=0  hl=4 l= 604 cons: SEQUENCE
   4:d=1  hl=2 l=   1 prim: INTEGER           :00
   7:d=1  hl=3 l= 129 prim:INTEGER           :
A11E66B0F965215AB4AD771581700477F62D9EDF2CFEBDF2E20C02DE4E95881F58CA898B6FC389CC83AE39DE95C0252BCF9FB98A6A21A20B751222DF2A4CBE1E08F8BDC8D443A59D4944723C33CED5601E1CF4A324E88B951626326783014CFF3BB7CF7278BF443AB003D1E1608B97CFC7783C6FD42B9A7C8F84C5633FB72DFB
 139:d=1  hl=2 l=   3 prim: INTEGER           :010001
 144:d=1  hl=3 l= 129 prim:INTEGER           :
9B2C9B7CD105AC851EC47E8FB0D541088489D59C5E4A8E88F15ADE1C5B953ABFEE154B39870FCD94B23247BBEF805A8C826FF413B239E8469E9F3404B949A643E1E2CCF9753822FD28345B7898148164DA2D858F672B52C7B3041F0A9F6FFFB97759D3C04AE3ED2E372E4ADD3A44202CE004D189566A81F19239649779F30DE9
 276:d=1  hl=2 l=  65 prim: INTEGER           :
CE25257FDE50AFDAF926BDBEFE5A236C130F2714C5FC0C36A07B5AA5618E8F5039E313387C933A86EBDC2DEF8640069CB98B1D04C3E74B46C75F292A768083D5
 343:d=1  hl=2 l=  65 prim: INTEGER           :
C8159573F6C413EAC0BB721B859A4B7920FF9DE151546CA28FDA3F43A0999C835DB9078AF5054CE503C4BC174ECB1F0C4DE033E116A296FD67B4158F869E628F
 410:d=1  hl=2 l=  64 prim: INTEGER           :
7329855D7DD10DAD02EB85AD216331CEBA87088A2E60B462001D697262A1C5A647F07758631FCCDE7AFD321C519F8B121B05805C9D24A58510F4348728547B51
 476:d=1  hl=2 l=  64 prim: INTEGER           :
53735D203EBDCD28CE35E003C69771FF155A47B92038BC0E993D07C1E70BEA9187D79263CC89E7666549FAC125E5E60F35B3DB2F78475BFE58F06D45AD7A05D5
 542:d=1  hl=2 l=  64 prim: INTEGER           :
4F454C491EAE6CD85ED812D8A26AFD5FD0F6D7DD12AD6D20EDA8C2D257943928B2AE66FDE336F40370D9CC30B85EB2F20D3B4FDAB61D168FE7936CB6AB5E8FE2</code></pre> 
  <p></p> 
  <p>&nbsp;得到的数据与上次导出的格式是相同的，虽然看起来数据多，但是层次结构起始要简单，数据就是一个结构体（cons）SEQUENCE，包含9个整型的原始数据（prim）INTERGER，这个就是私钥结构，该 ASN.1结构在PKCS#1中定义如下：</p> 
  <p></p> 
  <pre><code class="language-html">RSAPrivateKey ::= SEQUENCE {
versionVersion,
modulusINTEGER, -- n
publicExponentINTEGER, -- e
privateExponentINTEGER, -- d
prime1INTEGER, -- p
prime2INTEGER, -- q
exponent1INTEGER, -- d mod (p-1)
exponent2INTEGER, -- d mod (q-1)
coefficientINTEGER, -- (inverse of q) mod p
otherPrimeInfosOtherPrimeInfos OPTIONAL
}</code></pre>
  <br>
  <p></p> 
  <p>最后一个otherPrimeInfos是可选项，例子中没有该数据。</p> 
  <p>结构中包含了RSA密钥算法中用到的所有信息，每一项的具体定义可以参考PKCS#1。</p> 
  <p>&nbsp;</p> 
  <h2>3 分析公钥</h2> 
  <p>&nbsp;为了方便获取公钥，在私钥文件数据中起始包含了公钥信息：</p> 
  <p></p> 
  <pre><code class="language-html">modulus INTEGER, -- n
publicExponent INTEGER, -- e</code></pre>
  <br> 公钥的ASN.1结构也在PKCS#1中定义： 
  <p></p> 
  <p></p> 
  <pre><code class="language-html">RSAPublicKey ::= SEQUENCE  {
  modulus INTEGER, -- n
  publicExponentINTEGER -- e
 }</code></pre>
  <br>
  <p></p> 
  <p>可以使用openssl命令导出公钥文件pubkey.pem，使用文本工具打开公钥文件，pem头尾格式和私钥类似的标签：</p> 
  <p><span style="background-color:rgb(204,204,204);">openssl pkey -in privatekey.der -inform DER -out pubkey.pem-pubout</span></p> 
  <p>&nbsp;</p> 
  <pre><code class="language-html">-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQChHmaw+WUhWrStdxWBcAR39i2e
3yz+vfLiDALeTpWIH1jKiYtvw4nMg6453pXAJSvPn7mKaiGiC3USIt8qTL4eCPi9
yNRDpZ1JRHI8M87VYB4c9KMk6IuVFiYyZ4MBTP87t89yeL9EOrAD0eFgi5fPx3g8
b9QrmnyPhMVjP7ct+wIDAQAB
-----END PUBLIC KEY-----</code></pre>
  <br>
  <p></p> 
  <p>继续分析公钥文件的ASN.1格式：</p> 
  <p>openssl asn1parse -in pubkey.pem -i</p> 
  <p>&nbsp;</p> 
  <pre><code class="language-html">   0:d=0  hl=3 l= 159 cons: SEQUENCE
   3:d=1  hl=2 l=  13 cons: SEQUENCE
   5:d=2  hl=2 l=   9 prim:  OBJECT            :rsaEncryption
  16:d=2  hl=2 l=   0 prim:  NULL
  18:d=1  hl=3 l= 141 prim:  BIT STRING</code></pre> 
  <p><br></p> 
  <p>但是这里显示格式和上边给出的PKCS#1格式不一致，其实这是x.509中的定义的格式，在X.509证书文件中就是使用这个格式封装公钥数据，其中BIT STRING的内容就是PKCS#1格式的公钥数据，并说明了使用的公钥算法rsaEncryption。</p> 
  <p align="left"></p> 
  <pre><code class="language-html">SubjectPublicKeyInfo ::=SEQUENCE {
  algorithmAlgorithmIdentifier{{SupportedAlgorithms}},
  subjectPublicKeyBIT STRING
}</code></pre>&nbsp; 
  <p></p> 
  <p>我们可以进一步使用asn1parse工具解析出BIT STRING内容，首先确定该数据块偏移是18，然后使用参数-strparse指定位置,可以看到输出的数据和私钥文件中的是一样的。</p> 
  <p><span style="background-color:rgb(204,204,204);">asn1parse -in pubkey.pem -strparse 18</span></p> 
  <p>&nbsp;输出公钥ASN.1格式：</p> 
  <p></p> 
  <pre><code class="language-html">   0:d=0  hl=3 l= 137 cons: SEQUENCE
   3:d=1  hl=3 l= 129 prim: INTEGER           :
A11E66B0F965215AB4AD771581700477F62D9EDF2CFEBDF2E20C02DE4E95881F58CA898B6FC389CC83AE39DE95C0252BCF9FB98A6A21A20B751222DF2A4CBE1E08F8BDC8D443A59D4944723C33CED5601E1CF4A324E88B951626326783014CFF3BB7CF7278BF443AB003D1E1608B97CFC7783C6FD42B9A7C8F84C5633FB72DFB
   135:d=1  hl=2 l=3  prim: INTEGER           :010001</code></pre>&nbsp; 
  <p></p> 
  <h2>4 公私钥操作</h2> 
  <p>分析完私钥和公钥格式，以及之间的关系。接下来我们将继续使用openssl的rsautl测试它们之间的加解密、签名、验证等操作。</p> 
  <p><br></p> 
  <p>测试文件test，内容“1234567890”。</p> 
  <p>&nbsp;</p> 
  <h3>4.1加解密</h3> 
  <p>&nbsp;1）公钥加密</p> 
  <p><span style="background-color:rgb(204,204,204);">openssl rsautl -encrypt -in test -out test.enc -inkey asn1pub.pem -pubin</span></p> 
  <p><br></p> 
  <p>&nbsp;2）私钥解密</p> 
  <p><span style="background-color:rgb(204,204,204);">openssl rsautl -decrypt -in test.enc -out test.dec -inkey asn1enc.pem</span></p> 
  <p>&nbsp;</p> 
  <p>比较test和test.dec两个文件结果相同。</p> 
  <p>&nbsp;</p> 
  <h3>4.2签名验证</h3> 
  <p>1）私钥签名</p> 
  <p><span style="background-color:rgb(204,204,204);">openssl rsautl -sign -in test -out test.sig-inkey asn1enc.pem</span></p> 
  <p>&nbsp;</p> 
  <p>2）公钥验证</p> 
  <p><span style="background-color:rgb(204,204,204);">openssl rsautl -verify -in test.sig -out test.vfy -inkey asn1pub.pem -pubin</span></p> 
  <p>&nbsp;</p> 
  <p>比较test和test.vfy连个文件应该相同。</p> 
  <p>&nbsp;</p> 
 </div> 
</div> 
<div class="hide-article-box text-center"> 
 <a class="btn btn-red-hollow" id="btn-readmore" data-track-view="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Zhymax/article/details/7683925,&quot;}" data-track-click="{&quot;mod&quot;:&quot;popu_376&quot;,&quot;con&quot;:&quot;,https://blog.csdn.net/Zhymax/article/details/7683925,&quot;}">阅读更多</a> 
</div>

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<!-- 自定义广告 -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-8889449066804352"
	     data-ad-slot="1494696990"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
		(adsbygoogle = window.adsbygoogle || []).push({});
	</script>


        <br />
        <a href="https://uzshare.com/">更多精彩内容</a>
      </section>
      
      <header style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
        <ul style="display: block;">
          <li><a href="/" style="line-height: 40px;padding-top:0px;">回首页</a></li>
        </ul>
      </header>
      <header class="sm-hidden" style="right: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/imgqcode.png" style="width:160px;" />
      </header>
      
      <header class="sm-hidden" style="left: 0;position: fixed;bottom: 60px;z-index: 100;background: none;border-bottom:none;">
          <img src="https://uzzz.org.cn/hou_imgqcode.png" style="width:160px;">
      </header>
    </div>
    
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ee64533f3c6a7a284cd39a37ee732c8b";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

  </body>
</html>
